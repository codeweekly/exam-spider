-- --------------------------------------------------------
-- 主机:                           cdb-67dcvdgk.bj.tencentcdb.com
-- 服务器版本:                        5.7.18-20170830-log - 20170531
-- 服务器OS:                        Linux
-- HeidiSQL 版本:                  10.2.0.5599
-- --------------------------------------------------------

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET NAMES utf8 */;
/*!50503 SET NAMES utf8mb4 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;

-- Dumping structure for table we7.ims_goouc_practice_question
CREATE TABLE IF NOT EXISTS `ims_goouc_practice_question` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `weid` int(11) DEFAULT '0',
  `poolid` int(11) DEFAULT '0' COMMENT '题库ID',
  `type` int(11) DEFAULT '0' COMMENT '1 判断 2单选 3多选 4 填空  5 解答',
  `level` int(11) DEFAULT '0' COMMENT '难度',
  `question` text COMMENT '问题',
  `thumb` varchar(255) DEFAULT '' COMMENT '问题图片',
  `audio` varchar(255) DEFAULT '' COMMENT '问题音频',
  `video` varchar(255) DEFAULT '' COMMENT '问题视频',
  `answer` text COMMENT '答案',
  `isimg` tinyint(1) DEFAULT '0' COMMENT '答案是否包含图片',
  `explain` text COMMENT '讲解',
  `explain_video` text COMMENT '讲解视频',
  `fansnum` int(11) DEFAULT '0' COMMENT '多少人做过',
  `correctnum` int(11) DEFAULT '0' COMMENT '多少人正确',
  `items` text,
  `img_items` text,
  PRIMARY KEY (`id`),
  KEY `idx_poolid` (`poolid`),
  KEY `idx_type` (`type`),
  KEY `idx_weid` (`weid`)
) ENGINE=InnoDB AUTO_INCREMENT=863 DEFAULT CHARSET=utf8;

-- Dumping data for table we7.ims_goouc_practice_question: ~523 rows (大约)
/*!40000 ALTER TABLE `ims_goouc_practice_question` DISABLE KEYS */;
INSERT IGNORE INTO `ims_goouc_practice_question` (`id`, `weid`, `poolid`, `type`, `level`, `question`, `thumb`, `audio`, `video`, `answer`, `isimg`, `explain`, `explain_video`, `fansnum`, `correctnum`, `items`, `img_items`) VALUES
	(1, 4, 1, 2, 3, '车辆驶近停在车站的公交车辆时，为预防公交车突然起步或行人从车前穿出，应怎样做？', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"减速，保持足够间距，随时准备停车";i:1;s:24:"保持正常车速行驶";i:2;s:24:"随时准备紧急制动";i:3;s:30:"鸣喇叭提醒，加速通过";i:4;N;i:5;N;}', NULL),
	(2, 4, 1, 3, 6, '现在驾照考试需要哪几个科目？', '', '', '', 'F', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"科目1";i:1;s:7:"科目2";i:2;s:7:"科目3";i:3;s:7:"科目4";i:4;s:7:"科目5";i:5;s:7:"科目6";}', NULL),
	(3, 4, 1, 1, 10, '车辆长时间停放时，应选择停车场停车。', '', '', '', '1', 0, '', NULL, 0, 0, NULL, NULL),
	(21, 4, 1, 3, 1, '多选abc', '', '', '', 'ABC', 0, 'qqq', '', 0, 0, 'a:6:{i:0;s:1:"1";i:1;s:1:"2";i:2;s:1:"3";i:3;s:1:"4";i:4;s:1:"5";i:5;s:0:"";}', NULL),
	(22, 4, 1, 4, 1, '填空题，每个空用【】标记，支持多空', '', '', '', '【你】【好】', 0, '', '', 0, 0, '', NULL),
	(23, 4, 1, 1, 1, '判断', '', '', '', '1', 0, 'aaa', '', 0, 0, '', NULL),
	(24, 4, 3, 2, 5, '【2015年4月真题】 C++语言是从早期的C语言逐渐发展演变而来的，与C语言相比，C++在求解问题方法上进行的最大改进是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"面向过程";i:1;s:12:"面向对象";i:2;s:9:"安全性";i:3;s:9:"复用性";i:4;N;i:5;N;}', NULL),
	(25, 4, 3, 2, 5, '【2015年4月真题】设x和y均为bool量，则x＆＆y为真的条件是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"它们均为真";i:1;s:18:"其中一个为真";i:2;s:15:"它们均为假";i:3;s:18:"其中一个为假";i:4;N;i:5;N;}', NULL),
	(26, 4, 3, 2, 5, '【2015年4月真题】在C++语言中，080是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"八进制数";i:1;s:12:"十进制数";i:2;s:15:"十六进制数";i:3;s:9:"非法数";i:4;N;i:5;N;}', NULL),
	(27, 4, 3, 2, 5, '【2015年10月真题】在C++语言中用于注释的标识符是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"&";i:1;s:6:"／／";i:2;s:1:"*";i:3;s:3:"／";i:4;N;i:5;N;}', NULL),
	(28, 4, 3, 2, 5, '【2015年10月真题】设x=8，执行语句Y=x++，则y等于（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"6";i:1;s:1:"7";i:2;s:1:"9";i:3;s:1:"8";i:4;N;i:5;N;}', NULL),
	(29, 4, 3, 2, 5, '【2015年10月真题】下列运算符中，优先级最高的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"*";i:1;s:4:"一>";i:2;s:2:"&&";i:3;s:2:">=";i:4;N;i:5;N;}', NULL),
	(30, 4, 3, 2, 5, '【2016年4月真题】按照标识符的要求,不能组成标识符的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"连接符";i:1;s:9:"下划线";i:2;s:15:"大小写字母";i:3;s:12:"数字字母";i:4;N;i:5;N;}', NULL),
	(31, 4, 3, 2, 5, '【2016年10月真题】在编译指令中，宏定义使用指令（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"define";i:1;s:7:"include";i:2;s:7:"typedef";i:3;s:6:"friend";i:4;N;i:5;N;}', NULL),
	(32, 4, 3, 2, 5, '【2017年4月真题】若有定义int *p=new int(0) ，则下列说法正确的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:49:"系统用指针变量p来表示所指整型变量";i:1;s:58:"声明一个指针变量p，指向名为new的存储单元";i:2;s:61:"系统为指针变量p分配一个整型数据的存储空间";i:3;s:103:"通过运算符new，分配-一个整型数据的存储空间，并将其内存地址赋予指针变量";i:4;N;i:5;N;}', NULL),
	(33, 4, 3, 2, 5, '【2017年4月真题】在C++中，字符型数据在内存中的存放形式为（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"原码";i:1;s:6:"BCD码";i:2;s:5:"ASCII";i:3;s:6:"反码";i:4;N;i:5;N;}', NULL),
	(34, 4, 3, 2, 5, '【2017年4月真题】下列变量命名中，非法的是（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"A**LONG";i:1;s:5:"MyCar";i:2;s:6:"my_car";i:3;s:3:"a48";i:4;N;i:5;N;}', NULL),
	(35, 4, 3, 2, 5, '【2017年4月真题】已知:“int a=5;char c=\'a\' ;”则输出语句cout<<c+1 <<a<<c;的显示结果是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"65a";i:1;s:4:"985a";i:2;s:6:"98\'5\'a";i:3;s:6:" 65\'a\'";i:4;N;i:5;N;}', NULL),
	(36, 4, 3, 2, 5, '【2017年4月真题】C++语言的跳转语句中,对于break和continue说法正确的是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:35:"break语句只应用于循环体中";i:1;s:39:" continue语句只应用于循环体中";i:2;s:46:" break是无条件跳转语句, continue不是";i:3;s:65:" break和continue的跳转范围不够明确，容易产生问题";i:4;N;i:5;N;}', NULL),
	(37, 4, 3, 2, 5, '【2017年4月真题】有以下程序段,其输出结果是（ ）\n  #include < iostream>\nusing namespace std ;\nvoid main( )\n  { char b[] =”Hello,you" ;\nb[5]=’!’ ;\ncout<<b << endl;\n  }', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"Hello, you";i:1;s:5:"Hello";i:2;s:10:"Hello! you";i:3;s:1:"!";i:4;N;i:5;N;}', NULL),
	(38, 4, 3, 2, 5, '【2017年10月真题】下面不能够判断字符串S是空串的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"if(S[0]=0)";i:1;s:15:"if(strlen(S)=0)";i:2;s:22:"if(strcmp(S,””)=0)";i:3;s:15:"if(S==’\\0’)";i:4;N;i:5;N;}', NULL),
	(39, 4, 3, 2, 5, '【2017年10月真题】关于引用,下列的说法中错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"引用是给被引用的变量取一个别名";i:1;s:60:"引用主要是用来作函数的形参和函数的返回值";i:2;s:52:"在声明引引用时,要给它另开辟内存单元";i:3;s:46:"在声明引用时,必须同时使它初始化";i:4;N;i:5;N;}', NULL),
	(40, 4, 3, 2, 5, '【2015年4月真题】结构化程序设计所规定的三种基本控制结构是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"输入、处理、输出";i:1;s:24:"树形、网形、环形";i:2;s:24:"顺序、选择、循环";i:3;s:30:"主程序、子程序、函数";i:4;N;i:5;N;}', NULL),
	(41, 4, 3, 4, 5, '【2015年4月真题】面向对象编程的英文缩写是【】。', '', '', '', '【OOP】', 0, '', NULL, 0, 0, NULL, NULL),
	(42, 4, 3, 4, 5, '【2015年10月真题】已知int*p=NULL，使用new为指针P申请一个存储大小为10的存放int型的空间，代码为【】。', '', '', '', '【p=new int[10];】', 0, '', NULL, 0, 0, NULL, NULL),
	(43, 4, 3, 4, 5, '【2016年4月真题】使用new为int数组动态分配10个存储空间是【】。', '', '', '', '【new int[10];】', 0, '', NULL, 0, 0, NULL, NULL),
	(44, 4, 3, 4, 5, '【2016年4月真题】假设int a=1,b=2;则表达式( ++a/b) *b--的值为【】 。', '', '', '', '【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(45, 4, 3, 4, 5, '【2016年10月真题】C++程序有且只能有一个名为【】的主函数。', '', '', '', '【main】', 0, '', NULL, 0, 0, NULL, NULL),
	(46, 4, 3, 4, 5, '【2016年10月真题】所谓″【】″就是将一个新标识符和一块已经存在的存储区域相关联。', '', '', '', '【引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(47, 4, 3, 4, 5, '【2017年4月真题】执行3条语句“inta,b, *c=&a;int *p=c;p =&b;"后,c指向 【】。', '', '', '', '【a】', 0, '', NULL, 0, 0, NULL, NULL),
	(48, 4, 3, 4, 5, '【2017年4月真题】若有以下定义:double w[9] ;则w数组元素下标的下限是0,上限是【】。', '', '', '', '【8】', 0, '', NULL, 0, 0, NULL, NULL),
	(49, 4, 3, 4, 5, '【2017年4月真题】设int x[3][4];则x数组中含有【】个int类型的数组元素。', '', '', '', '【12】', 0, '', NULL, 0, 0, NULL, NULL),
	(50, 4, 3, 4, 5, '【2017年4月真题】C++为结构动态分配内存的一般格式是“指针名=【】; ”，当不再使用这个空间时必须用“delete指针名;”释放空间。', '', '', '', '【new结构名】', 0, '', NULL, 0, 0, NULL, NULL),
	(51, 4, 3, 4, 5, '【2017年10月真题】#include<iostream.h>命令中，include的意义是【】   。', '', '', '', '【包含头文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(52, 4, 3, 4, 5, '【2017年10月真题】设在成程序中使用如下语句申请了一个对象数组；Point*ptr=new Point[2];当要释放ptr指向的动态数组对象时，所使用的语句是【】           。', '', '', '', '【delete[ ]ptr;】', 0, '', NULL, 0, 0, NULL, NULL),
	(53, 4, 3, 4, 5, '【2015年4月真题】按照联编进行阶段的不同，联编方法可分为两种：动态联编和【】。.', '', '', '', '【静态联编】', 0, '', NULL, 0, 0, NULL, NULL),
	(54, 4, 4, 2, 5, '【2015年4月真题】在C++语言中，能代表逻辑值“假”的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:"小于0的数";i:1;s:13:"大于0的数";i:2;s:10:"非0整数";i:3;s:1:"0";i:4;N;i:5;N;}', NULL),
	(55, 4, 4, 2, 5, '【2015年4月真题】已知：int m=10；在下列表示引用的方法中，下列哪一项是正确的（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"int＆x=m";i:1;s:8:"int&y=10";i:2;s:7:"int＆z";i:3;s:12:"float&t=＆m";i:4;N;i:5;N;}', NULL),
	(56, 4, 4, 2, 5, '【2015年10月真题】关于new运算符的下列描述中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"它可以用来动态创建对象和对象数组";i:1;s:72:"使用它创建的对象和对象数组可以使用运算符delete删除";i:2;s:45:"使用它创建对象时要调用构造函数";i:3;s:51:"使用它创建对象数组时必须指定初始值";i:4;N;i:5;N;}', NULL),
	(57, 4, 4, 2, 5, '【2015年10月真题】存储下列数据，占用存储字节最多的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:" 0";i:1;s:7:"‘0’";i:2;s:7:"〝0〞";i:3;s:3:"0.0";i:4;N;i:5;N;}', NULL),
	(58, 4, 4, 2, 5, '【2015年10月真题】下列说明语句中正确的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:23:"inta，&ra=a，&&ref=ra";i:1;s:12:"int&refa[10]";i:2;s:28:"int a，&ra=a，＆*refp=&ra";i:3;s:18:"int*pi，*&pref=pi";i:4;N;i:5;N;}', NULL),
	(59, 4, 4, 2, 5, '【2016年10月真题】若有说明：int n=2，*P=＆n，*q=p；，则以下非法的赋值语句是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"n=*q";i:1;s:3:"P=n";i:2;s:3:"P=q";i:3;s:5:"*q=*P";i:4;N;i:5;N;}', NULL),
	(60, 4, 4, 2, 5, '【2016年10月真题】下列字符常量的写法中，错误的是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"′＼t′";i:1;s:7:"′b′";i:2;s:7:"′*′";i:3;s:7:"′a′";i:4;N;i:5;N;}', NULL),
	(61, 4, 4, 2, 5, '【2017年4月真题】以下说法中不正确的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:95:" C++程序中必须有个主函数 main( )，而且是从 main( )的第一条语句开始执行";i:1;s:93:"非主函数都是在执行主函数时，通过函数调用或嵌套调用而得以执行的";i:2;s:36:"主函数可以在任何地方出现";i:3;s:36:"主函数必须出现在固定位置";i:4;N;i:5;N;}', NULL),
	(62, 4, 4, 2, 5, '【2017年4月真题】下面程序的输出结果是（ ）\n#include. <iostream>\nusing namespacc std ;\nint main( )\n{inta=1,b= -2,c=3;\nif(a<b)\nif(b<0)c=0;\nelse C+ =1;\ncout<<c << endl;\nreturn 0;\n}', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"0";i:1;s:1:"2";i:2;s:1:"3";i:3;s:1:"4";i:4;N;i:5;N;}', NULL),
	(63, 4, 4, 2, 5, '【2017年10月真题】按照标识符的要求,不能组成标识符的符号是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"连接符";i:1;s:9:"下划线";i:2;s:15:"大小写字母";i:3;s:12:"数字字符";i:4;N;i:5;N;}', NULL),
	(64, 4, 4, 2, 5, '【2017年10月真题】if与else在使用过程中为避免嵌套出现二义性,C++中规定与else子句配对的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:26:"其之前最近的if语句";i:1;s:41:"其之前最近且尚未配对的if语句";i:2;s:29:"缩排位置相同的if语句";i:3;s:26:"其之后最近的if语句";i:4;N;i:5;N;}', NULL),
	(65, 4, 4, 2, 5, '【2017年10月真题】对使用关键字new所开辟的动态存储空间,释放时必须使用（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"free";i:1;s:6:"create";i:2;s:6:"delete";i:3;s:7:"release";i:4;N;i:5;N;}', NULL),
	(66, 4, 4, 2, 5, '【2017年10月真题】逻辑运算符两侧运算对象的数据（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"是逻掛型数据";i:1;s:21:"只能是整型数据";i:2;s:33:"只能是整型或字符型数据";i:3;s:30:"可以是任何类型的数据";i:4;N;i:5;N;}', NULL),
	(67, 4, 4, 2, 5, '【2017年10月真题】若二维数组y有m列,则位于y[i][j]之前的元素数量是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"j*m+I";i:1;s:5:"i*m+j";i:2;s:7:"i*m+j-1";i:3;s:7:"i&m+j+1";i:4;N;i:5;N;}', NULL),
	(68, 4, 4, 2, 5, '【2017年10月真题】下面叙述中错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"处理命令都必须以“”开始";i:1;s:70:"在程序中凡是以“#”开始的语句行都是顶处理命令行";i:2;s:63:"C++程序在程序执行过程中对预处理命令进行处理";i:3;s:36:"一行只能写一条预处理命令";i:4;N;i:5;N;}', NULL),
	(69, 4, 4, 2, 5, '【2015年10月真题】编写C++程序一般需经过的几个步骤依次是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"编辑、调试、编译、连接";i:1;s:33:"编译、调试、编辑、连接";i:2;s:33:"编译、编辑、连接、运行";i:3;s:33:"编辑、编译、连接、运行";i:4;N;i:5;N;}', NULL),
	(70, 4, 4, 4, 5, '【2015年4月真题】设有定义int x=3，y=4；则表达式x*=y+5的值为【】   。', '', '', '', '【27】', 0, '', NULL, 0, 0, NULL, NULL),
	(71, 4, 4, 4, 5, '【2015年10月真题】在编译指令中，宏定义使用【】指令。', '', '', '', '【define】', 0, '', NULL, 0, 0, NULL, NULL),
	(72, 4, 4, 4, 5, '【2015年10月真题】局部对象和全局对象中，在同一程序中【】生存期最长。', '', '', '', '【全局对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(73, 4, 4, 4, 5, '【2016年10月真题】动态分配内存使用关键字【】，释放内存使用关键字delete。', '', '', '', '【new】', 0, '', NULL, 0, 0, NULL, NULL),
	(74, 4, 4, 4, 5, '【2016年10月真题】表达式″20／3*sqrt(4.0)／5″值的数据类型是【】   。', '', '', '', '【double】', 0, '', NULL, 0, 0, NULL, NULL),
	(75, 4, 4, 4, 5, '【2017年4月真题】C++语言中提供了3种循环语句:【】循环语句、for 循环语句和do_while 循环语句。', '', '', '', '【while】', 0, '', NULL, 0, 0, NULL, NULL),
	(76, 4, 4, 4, 5, '【2017年4月真题】在“int a=10, *p= &a;”语句中,p的值是【】。', '', '', '', '【变量a的地址】', 0, '', NULL, 0, 0, NULL, NULL),
	(77, 4, 4, 4, 5, '【2017年4月真题】源程序文档化要求程序应加注释，注释-般分为序言性注释和【】。', '', '', '', '【功能性注释】', 0, '', NULL, 0, 0, NULL, NULL),
	(78, 4, 4, 4, 5, '【2017年4月真题】定义以下变量并假设已赋确定的值:“char w;int x;foat y ;double z;”，则表达式“w *x+z-y”的数据类型是【】。', '', '', '', '【double】', 0, '', NULL, 0, 0, NULL, NULL),
	(79, 4, 4, 4, 5, '【2017年10月真题】书写程序语句时，适当增加空行和程序注释以增加程序的【】。', '', '', '', '【可读性】', 0, '', NULL, 0, 0, NULL, NULL),
	(80, 4, 4, 4, 5, '【2017年10月真题】C++语言的【】提供了与要操作的元素类型无关的算法。', '', '', '', '【[\'标准模板库\', \'STL\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(81, 4, 4, 4, 5, '【2017年10月真题】若int a=8;int b=(++a)++;则b=【】。', '', '', '', '【9】', 0, '', NULL, 0, 0, NULL, NULL),
	(82, 4, 4, 4, 5, '【2017年4月真题】一般C++语言源程序文件的后缀是. Cpp；经过编译后，生成文件的后缀是.obj ；经过连接后，生成文件的后级是【】。', '', '', '', '【.exe】', 0, '', NULL, 0, 0, NULL, NULL),
	(83, 4, 5, 2, 5, '【2015年10月真题】关于对象概念的描述中，说法错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:34:"对象就是C语言中的结构体";i:1;s:54:"对象代表着正在创建的系统中的一个实体";i:2;s:27:"对象是类的一个变量";i:3;s:51:"对象之间的信息传递是通过消息进行的";i:4;N;i:5;N;}', NULL),
	(84, 4, 5, 2, 5, '【2017年4月真题】以下有关类与对象的叙述中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"对象是类的一个实例";i:1;s:30:"一个类可以有多个对象";i:2;s:48:"任何一个对象都归属于一个具体的类";i:3;s:84:"只要是某个类的对象，那么该对象就可以访问这个类的所有成员";i:4;N;i:5;N;}', NULL),
	(85, 4, 5, 2, 5, '【2017年4月真题】关于对类的描述中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"类是创建对象的样板";i:1;s:36:"类是具有唯一标识符的实体";i:2;s:34:"类就是C语言中的结构类型";i:3;s:57:"类是具有共同行为的若干对象的统一描述体";i:4;N;i:5;N;}', NULL),
	(86, 4, 5, 2, 5, '【2017年4月真题】下面关于对象概念的插述中错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"任何对象都必须有继承性";i:1;s:36:"对象是属性和方法的封装体";i:2;s:33:"对象间的通信靠消息传递";i:3;s:30:"操作是对象的动态属性";i:4;N;i:5;N;}', NULL),
	(87, 4, 5, 2, 5, '【2018年10月真题】下列对静态成员的描述中,不正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:50:" 静态成员不属于对象,是类的共享成员";i:1;s:49:" 静态数据成员要在类外定义和初始化";i:2;s:96:" 调用静态成员函数时要通过类或对象激活,所以静态成员函数拥有this指针";i:3;s:55:" 非静态成员函数也可以操作静态数据成员";i:4;N;i:5;N;}', NULL),
	(88, 4, 5, 2, 5, '【2018年10月真题】拷贝构造函数应该是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:28:" 不带参数的构造函数";i:1;s:34:" 带有一个参数的构造函数";i:2;s:34:" 带有两个参数的构造函数";i:3;s:19:" 缺省构造函数";i:4;N;i:5;N;}', NULL),
	(89, 4, 5, 4, 5, '【2015年10月真题】每个对象都是所属类的一个 【】               。', '', '', '', '【实例】', 0, '', NULL, 0, 0, NULL, NULL),
	(90, 4, 5, 4, 5, '【2019年04月真题】面向对象程序设计将表示属性特征的数据和对数据进行操作的【】   \n封装在一起,构成一个完整的对象。', '', '', '', '【方法】', 0, '', NULL, 0, 0, NULL, NULL),
	(91, 4, 5, 4, 5, '【2019年04月真题】对象成员是指该对象所属类中定义的成员,包括数据成员和【】     。', '', '', '', '【成员函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(92, 4, 5, 4, 5, '【2016年4月真题】C++程序的源文件扩展名为【】           。', '', '', '', '【CPP】', 0, '', NULL, 0, 0, NULL, NULL),
	(93, 4, 5, 4, 5, '【2016年4月真题】下面程序运行的结果是【】 。\n#include < iostream. h >\nvoid main() {\ncout. fill(‘* ‘);\ncout. width(6) ;\ncout <<" hello"<< endl;\ncout. clear();}', '', '', '', '【*hello】', 0, '', NULL, 0, 0, NULL, NULL),
	(94, 4, 5, 4, 5, '【2016年10月真题】面向对象的程序设计方法是以 【】        代表求解问题的中心环节。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(95, 4, 5, 4, 5, '【2016年10月真题】对象的 【】只能由这个对象的操作来存取。', '', '', '', '【属性】', 0, '', NULL, 0, 0, NULL, NULL),
	(96, 4, 5, 4, 5, '【2016年10月真题】 【】是类的实例。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(97, 4, 5, 4, 5, '【2016年10月真题】关键字private、public和【】以后的成员分别叫做私有成员、公有成员和保护成员。', '', '', '', '【protected】', 0, '', NULL, 0, 0, NULL, NULL),
	(98, 4, 5, 4, 5, '【2015年4月真题】对象的核心概念就是通常所说的继承、封装和【】   。', '', '', '', '【多态性】', 0, '', NULL, 0, 0, NULL, NULL),
	(99, 4, 5, 4, 5, '【2016年4月真题】C++程序的编译是以【】为单位进行的。', '', '', '', '【文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(100, 4, 5, 4, 5, '【2016年4月真题】举出C++中两种代码复用的方式【】      、复用。', '', '', '', '【继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(101, 4, 5, 4, 5, '【2018年10月真题】当一个成员函数被调用时,该成员函数的【】指向调用它的对象。', '', '', '', '【this指针】', 0, '', NULL, 0, 0, NULL, NULL),
	(102, 4, 5, 4, 5, '【2016年4月真题】执行下列代码\n  sring str(" NihaoC++" );\n  cout << str. substr(5,3);\n  程序的输出结果是【】   。', '', '', '', '【C++】', 0, '', NULL, 0, 0, NULL, NULL),
	(103, 4, 5, 4, 5, '【2017年4月真题】C++ 程序中使用string类定义存储字符串的对象时,必须在程序中包含这个类的头文件，即使用语句【】  。', '', '', '', '【#include<string>】', 0, '', NULL, 0, 0, NULL, NULL),
	(104, 4, 6, 2, 5, '【2017年4月真题】考虑函数原型void pass( int x,int y =5,char z=\' *\'),下面的函数调用中，属于不合法调用的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"pass(5)";i:1;s:9:"pass(5,8)";i:2;s:11:"pass(6,\'#\')";i:3;s:13:"pass(0,0,\'*\')";i:4;N;i:5;N;}', NULL),
	(105, 4, 6, 2, 5, '【2017年10月真题】已知:pint()函数是一个类的常成员函数,无返回值,下列表示中正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"void print() const";i:1;s:18:"void print (const)";i:2;s:18:"void const print()";i:3;s:18:"const void print()";i:4;N;i:5;N;}', NULL),
	(106, 4, 6, 2, 5, '【2017年10月真题】在C++中,函数原型不能标识（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"函数的返回类型";i:1;s:21:"函数参数的个数";i:2;s:18:"函数参数类型";i:3;s:15:"函数的功能";i:4;N;i:5;N;}', NULL),
	(107, 4, 6, 2, 5, '【2017年10月真题】下列列说法不正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:64:"主函数main中定义的变量在整个文件或程序中有效";i:1;s:49:"不同函数中,可以使用相同名字的变量";i:2;s:27:"形式参数是局部变量";i:3;s:98:"在一个函数内部,可以在复合语句中定义变量,这些变量只在复合语句中有效";i:4;N;i:5;N;}', NULL),
	(108, 4, 6, 2, 5, '【2017年10月真题】非数组指针或引用型变量做实参时,它和对应虚参之间的数据传递方式是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"地址传递";i:1;s:15:"单向值传递";i:2;s:15:"双向值传递";i:3;s:27:"由用户指定传递方式";i:4;N;i:5;N;}', NULL),
	(109, 4, 6, 2, 5, '【2015年4月真题】以下叙述中不正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"在一个函数中，可以有多条return语句";i:1;s:60:"函数的定义不能嵌套，但函数的调用可以嵌套";i:2;s:24:"函数必须有返回值";i:3;s:51:"不同的函数中可以使用相同名字的变量";i:4;N;i:5;N;}', NULL),
	(110, 4, 6, 2, 5, '【2015年4月真题】下列哪个类型函数不适合声明为内联函数（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"函数体语句较多";i:1;s:21:"函数体语句较少";i:2;s:24:"函数执行时间较短";i:3;s:24:"函数执行时间过长";i:4;N;i:5;N;}', NULL),
	(111, 4, 6, 2, 5, '【2015年10月真题】要求通过函数来实现一种不太复杂的功能，并且要求加快执行速度，选用（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"内联函数";i:1;s:12:"重载函数";i:2;s:12:"内部函数";i:3;s:12:"函数模板";i:4;N;i:5;N;}', NULL),
	(112, 4, 6, 2, 5, '【2016年4月真题】适宜采用inline定义函数情况是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"函数体含有循环语句";i:1;s:27:"函数体含有递归语句";i:2;s:30:"函数代码多、不常调用";i:3;s:30:"函数代码少、频繁调用";i:4;N;i:5;N;}', NULL),
	(113, 4, 6, 2, 5, '【2016年10月真题】一个函数的功能不太复杂，但要求被频繁调用，选用最适合的是（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"内联函数";i:1;s:12:"重载函数";i:2;s:12:"递归函数";i:3;s:12:"嵌套函数";i:4;N;i:5;N;}', NULL),
	(114, 4, 6, 2, 5, '【2015年4月真题】关于函数模板，描述错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"函数模板必须由程序员实例化为可执行的函数模板";i:1;s:42:"函数模板的实例化由编译器实现";i:2;s:75:"一个类定义中，只要有一个函数模板，则这个类是类模板";i:3;s:99:"类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化";i:4;N;i:5;N;}', NULL),
	(115, 4, 6, 2, 5, '【2016年4月真题】实现两个相同类型数加法的函数模板的声明是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"add(Tx,Ty)";i:1;s:10:"T add(x,y)";i:2;s:11:"T add(Tx,y)";i:3;s:12:"T add(Tx,Ty)";i:4;N;i:5;N;}', NULL),
	(116, 4, 6, 2, 5, '【2016年4月真题】关于函数模板，描述错误的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:67:"函数模板必须由程序员实例化为可执行的函数模板;";i:1;s:43:"函数模板的实例化由编译器实现;";i:2;s:76:"一个类定义中，只要有一个函数模板，则这个类是类模板;";i:3;s:101:" 类模板的成员函数都是函数模板，类模板实例化后，成员函数也随之实例化;";i:4;N;i:5;N;}', NULL),
	(117, 4, 6, 2, 5, '【2016年4月真题】假设声明了以下的西数模板，错误的调用语句是（ ）  \nTemplate<class T>\nT max(T x，T y){ return（x>y）? x:y；}\n并定义了int I;char c;', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"max（i,i）";i:1;s:12:"max（c,c）";i:2;s:21:"max（（int）c,i）";i:3;s:12:"max（i,c）";i:4;N;i:5;N;}', NULL),
	(118, 4, 6, 4, 5, '【2015年4月真题】在C++中，函数鲢参数有两种传递方式，它们是【】和地址或指针或引用传递。', '', '', '', '【值传递】', 0, '', NULL, 0, 0, NULL, NULL),
	(119, 4, 6, 4, 5, '【2015年4月真题】如果一个函数直接或间接地调用自身，这样的调用称为【】调用。', '', '', '', '【递归】', 0, '', NULL, 0, 0, NULL, NULL),
	(120, 4, 6, 4, 5, '【2015年10月真题】在C++中有两种参数传递方式：传值和传【】。', '', '', '', '【引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(121, 4, 6, 4, 5, '【2016年10月真题】将对象作为函数参数，是将实参对象的值传递给【】。', '', '', '', '【形参对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(122, 4, 6, 4, 5, '【2017年10月真题】C++语言中如果调用函数时,需要改变实参或者返回多个值,应该采取【】方式。', '', '', '', '【传地址或引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(123, 4, 6, 4, 5, '【2017年10月真题】将指向对象的引用作为函数的形参,形参是对象的引用,实参是【】。', '', '', '', '【对象名】', 0, '', NULL, 0, 0, NULL, NULL),
	(124, 4, 6, 4, 5, '【2015年10月真题】C++函数的返回值类型可以是【】和函数以外的任何类型。', '', '', '', '【数组】', 0, '', NULL, 0, 0, NULL, NULL),
	(125, 4, 6, 4, 5, '【2016年10月真题】使用关键字inline说明的函数称为【】函数。', '', '', '', '【内联】', 0, '', NULL, 0, 0, NULL, NULL),
	(126, 4, 6, 4, 5, '【2017年10月真题】在函数前面用【】保留字修饰时,则表示该函数为内联函数。', '', '', '', '【inline】', 0, '', NULL, 0, 0, NULL, NULL),
	(127, 4, 6, 4, 5, '【2015年4月真题】在C++中，函数在定义时可以预先定义出默认的形参值。默认形参值必须按【】的顺序定义。因为在调用时，实参初始化形参是按从左到右的顺序。', '', '', '', '【从右到左】', 0, '', NULL, 0, 0, NULL, NULL),
	(128, 4, 6, 4, 5, '【2015年4月真题】函数模板中紧随template之后尖括号内的类型参数都要冠以保留字【】。', '', '', '', '【class】', 0, '', NULL, 0, 0, NULL, NULL),
	(129, 4, 6, 4, 5, '【2015年4月真题】设函数sum是由函数模板实现的，并且sum(3，6)和sum(4.6，8)都是正确的函数调用，则函数模板具有【】个类型参数。', '', '', '', '【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(130, 4, 6, 4, 5, '【2017年4月真题】模板函数的真正代码是在源程序中【】时产生。', '', '', '', '【调用函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(131, 4, 7, 2, 5, '【2015年4月真题】作用域运算符“：：”的功能是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"标识作用域的级别的";i:1;s:27:"指出作用域的范围的";i:2;s:27:"给定作用域的大小的";i:3;s:33:"标识成员是属于哪个类的";i:4;N;i:5;N;}', NULL),
	(132, 4, 7, 2, 5, '【2015年4月真题】以下关键字不能用来声明类的访问权限的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"public";i:1;s:7:"private";i:2;s:5:"stadc";i:3;s:9:"protected";i:4;N;i:5;N;}', NULL),
	(133, 4, 7, 2, 5, '【2015年4月真题】有如下类声明“class A{int x；…}；”，则A类的成员x是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"公有数据成员";i:1;s:18:"私有数据成员";i:2;s:18:"公有成员函数";i:3;s:18:"私有成员函数";i:4;N;i:5;N;}', NULL),
	(134, 4, 7, 2, 5, '【2015年10月真题】关于类和对象不正确的说法是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"类是一种类型，它封装了数据和操作";i:1;s:21:"对象是类的实例";i:2;s:30:"一个类的对象只有一个";i:3;s:30:"一个对象必属于某个类";i:4;N;i:5;N;}', NULL),
	(135, 4, 7, 2, 5, '【2015年10月真题】类中定义的成员默认访问属性为（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"public";i:1;s:7:"private";i:2;s:9:"protected";i:3;s:6:"friend";i:4;N;i:5;N;}', NULL),
	(136, 4, 7, 2, 5, '【2016年4月真题】已知:fune() 函数是个类的常成员函数，它无返回值，下列表示中，是正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"void func() const;";i:1;s:18:"const void func();";i:2;s:19:"void const fune( );";i:3;s:18:"void fune( const);";i:4;N;i:5;N;}', NULL),
	(137, 4, 7, 2, 5, '【2017年4月真题】以下叙述中正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"类成员的定义必须放在类体内部";i:1;s:63:"在类中，不作特别说明的数据成员均为私有类型";i:2;s:63:"在类中，不作特别说明的数据成员均为公有类型";i:3;s:66:"类成员的定义必须是成员变量在前，成员函数在后";i:4;N;i:5;N;}', NULL),
	(138, 4, 7, 2, 5, '【2017年10月真题】所谓数据封装就是将一组数据和与这组数据有关標作组装在一起,形成一个实体,这实体也就是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"类";i:1;s:6:"对象";i:2;s:9:"函数体";i:3;s:9:"数据块";i:4;N;i:5;N;}', NULL),
	(139, 4, 7, 2, 5, '【2017年10月真题】下列关于类的权限的描述错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"类本身的成员函数只能访问自身的私有成员";i:1;s:45:"类的对象只能访问该类的公有成员";i:2;s:73:"普通函数不能直接访问类的公有成员,必须通过对象访问";i:3;s:51:"一个类可以将另一个类的对象作为成员";i:4;N;i:5;N;}', NULL),
	(140, 4, 7, 2, 5, '【2015年4月真题】采用重载函数的目的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"实现共享";i:1;s:12:"减少空间";i:2;s:12:"提高速度";i:3;s:30:"使用方便，提高可读性";i:4;N;i:5;N;}', NULL),
	(141, 4, 7, 2, 5, '【2015年4月真题】下列不是构造函数的特征的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"构造函数的函数名与类名相同";i:1;s:24:"构造函数可以重载";i:2;s:36:"构造函数可以设置缺省参数";i:3;s:24:"构造函数不能重载";i:4;N;i:5;N;}', NULL),
	(142, 4, 7, 2, 5, '【2015年4月真题】通常的拷贝构造函数的参数是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"某个对象名";i:1;s:21:"某个对象成员名";i:2;s:21:"某个对象的引用";i:3;s:24:"某个对象的指针名";i:4;N;i:5;N;}', NULL),
	(143, 4, 7, 2, 5, '【2015年10月真题】下列有关构造函数的描述中，正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"构造函数可以带有返回值";i:1;s:42:"构造函数的名字与类名完全相同";i:2;s:30:"构造函数必须带有参数";i:3;s:39:"构造函数必须定义，不能缺省";i:4;N;i:5;N;}', NULL),
	(144, 4, 7, 4, 5, '【2015年10月真题】在类内部定义的公有(public)数据可以在类外进行存取，但【】和私有(private)数据不能在类外直接存取。', '', '', '', '【[\'保护\', \'protected\', \'数据\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(145, 4, 7, 4, 5, '【2016年4月真题】在用class定义一个类时，数据成员和成员函数的默认访问权限是【】。', '', '', '', '【[\'private\', \'私有\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(146, 4, 7, 4, 5, '【2016年10月真题】类对象一般都包括数据成员和【】。', '', '', '', '【成员函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(147, 4, 7, 4, 5, '【2017年10月真题】为了在对象生存期结東时释放其指针成员所指向的动态存储空间,通常为该类定义【】。', '', '', '', '【析构函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(148, 4, 7, 4, 5, '【2017年10月真题】在保护派生中,基类权限为public的成员在派生类中为【】。', '', '', '', '【[\'保护类型\', \' protect\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(149, 4, 7, 4, 5, '【2017年10月真题】面向对象的四个基本特性是多态性、继承性、封装性、【】。', '', '', '', '【抽象】', 0, '', NULL, 0, 0, NULL, NULL),
	(150, 4, 7, 4, 5, '【2015年4月真题】通假如一个类的名称为MyClass，使用这个类的一个对象初始化该类的另一个对象时，可以调用【】构造函数来完成此功能。', '', '', '', '【[\'复制\', \'拷贝\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(151, 4, 7, 4, 5, '【2016年4月真题】通常使用对象的引用来初始化创建中的对象【】。', '', '', '', '【拷贝构造函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(152, 4, 8, 2, 5, '【2015年10月真题】拷贝构造函数的参数是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"某个对象名";i:1;s:24:"某个对象的成员名";i:2;s:24:"某个对象的引用名";i:3;s:24:"某个对象的指针名";i:4;N;i:5;N;}', NULL),
	(153, 4, 8, 2, 5, '【2016年4月真题】通常拷贝构造函数的参数是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"某个对象的成员名";i:1;s:24:"某个对象的指针名";i:2;s:24:"某个对象的引用名";i:3;s:15:"某个对象名";i:4;N;i:5;N;}', NULL),
	(154, 4, 8, 2, 5, '【2016年4月真题】假定一个类的构造函数为A(int aa,int bb){a=aa ++ ;b=a* ++bb;}，则执行Ax(4,5) ;语句后，x.a和x. b的值分别为（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"4和5";i:1;s:6:"4和20";i:2;s:6:"4和24";i:3;s:6:"20和5";i:4;N;i:5;N;}', NULL),
	(155, 4, 8, 2, 5, '【2017年4月真题】以下有关构造函数的叙述中，错误的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"构造函数名必须和类名- -致";i:1;s:42:"构造函数在定义对象时自动执行";i:2;s:45:"在一个类中构造函数有且仅有一个";i:3;s:54:"构造函数可以在类体内声明在类体外实现";i:4;N;i:5;N;}', NULL),
	(156, 4, 8, 2, 5, '【2017年10月真题】关于构造函数的说法,不正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:52:"没有定义构造函数时,系统将不会调用它";i:1;s:27:"其名与类名完全相同";i:2;s:45:"它在对象被创建时由系统自动谓用";i:3;s:15:"没有返回值";i:4;N;i:5;N;}', NULL),
	(157, 4, 8, 2, 5, '【2016年10月真题】假定有类AB，有相应的构造函数定义，能正确执行“AB a(4)，b(5)，c[3]，*p[2]={&a，&b}；”语句，请问执行完此语句后共调用该类析构函数的次数为（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:"14";i:1;s:1:"5";i:2;s:1:"3";i:3;s:1:"1";i:4;N;i:5;N;}', NULL),
	(158, 4, 8, 2, 5, '【2016年10月真题】在下面有关析构函数特征的描述中，正确的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"一个类中可以定义多个析构函数";i:1;s:36:"析构函数名与类名完全相同";i:2;s:36:"析构函数不能指定返回类型";i:3;s:42:"析构函数可以有一个或多个参数";i:4;N;i:5;N;}', NULL),
	(159, 4, 8, 2, 5, '【2016年10月真题】下面说法正确的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"生成对象时调用析构函数";i:1;s:45:"定义类时必须写出该类的构造函数";i:2;s:66:"调用构造函数时必须在主函数中明确写出调用格式";i:3;s:27:"析构函数不可以重载";i:4;N;i:5;N;}', NULL),
	(160, 4, 8, 2, 5, '【2016年10月真题】用运算符delete删除—个动态对象时（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:72:"首先为该动态对象调用构造函数，再释放其占用的内存";i:1;s:72:"首先释放该动态对象占用的内存，再为其调用构造函数";i:2;s:72:"首先为该动态对象调用析构函数，荐释放其占用的内存";i:3;s:72:"首先释放该动态对象占用的内存，再为其调用析构函数";i:4;N;i:5;N;}', NULL),
	(161, 4, 8, 2, 5, '【2015年10月真题】下列有关重载函数的说法中正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"重载函数必须具有不同的返回值类型";i:1;s:36:"重载函数参数个数必须相同";i:2;s:42:"重载函数必须有不同的形参列表";i:3;s:27:"重载函数名可以不同";i:4;N;i:5;N;}', NULL),
	(162, 4, 8, 2, 5, '【2016年4月真题】关于this指针的说法错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:" this 指针必须显式声明";i:1;s:53:"当创建一个对象后,this指针就指向该对象";i:2;s:34:"动态成员函数拥有this指针";i:3;s:37:"静态成员函数不拥有this指针";i:4;N;i:5;N;}', NULL),
	(163, 4, 8, 2, 5, '【2016年4月真题】在编译指令中，宏定义使用哪个指令（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"#if";i:1;s:8:"#include";i:2;s:7:"#define";i:3;s:6:"#error";i:4;N;i:5;N;}', NULL),
	(164, 4, 8, 2, 5, '【2017年4月真题】对于下面定义的类Myclass ,在函数f( )中将对象成员n的值修改为50的语句应该是（  ）\nclass Myclass\n{ public:\nMyclass(int i){n=i;}\nvoid SetNum(int x){n=x;}\nprivate:\nint n;\n  };\nint f( )\n  {Myclass * p =new Myclass(45) ;\n}', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:17:"p一> SetNum( 50)";i:1;s:10:"SetNum(50)";i:2;s:9:"p一>n=50";i:3;s:17:"*p一> SetNum(50)";i:4;N;i:5;N;}', NULL),
	(165, 4, 8, 4, 5, '【2017年4月真题】若有一个Myclass类,则执行语句”MyClass obj1 ，obj2[2], *p;”后，自动调用该类的构造函数【】次。', '', '', '', '【3】', 0, '', NULL, 0, 0, NULL, NULL),
	(166, 4, 8, 4, 5, '【2017年10月真题】假定AB为一个类,则执行语句ABa[10];时,系统自动调用该类的构造函数的次数为【】。', '', '', '', '【10】', 0, '', NULL, 0, 0, NULL, NULL),
	(167, 4, 8, 4, 5, '【2016年10月真题】对MyFirst类定义析构函数是【】。', '', '', '', '【[\'~ MyFirst\', \'{}\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(168, 4, 8, 4, 5, '【2015年10月真题】在C++中，访问一个指针所指向的对象的成员所用的指向运算符是【】。', '', '', '', '【->】', 0, '', NULL, 0, 0, NULL, NULL),
	(169, 4, 8, 4, 5, '【2017年4月真题】this指针保证每个对象拥有自己的数据成员,又共享处理这些数据成员的【】。', '', '', '', '【代码】', 0, '', NULL, 0, 0, NULL, NULL),
	(170, 4, 8, 4, 5, '【2017年10月真题】this指针始终指向调用成员函数的【】。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(171, 4, 8, 4, 5, '【2017年4月真题】在类中定义和实现的函数可以成为【】，它能够加快程序执行速度。', '', '', '', '【内联函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(172, 4, 9, 2, 5, '【2015年10月真题】类中能访问静态成员的函数是（ ）', '', '', '', 'B', 0, '', NULL, 1, 1, 'a:6:{i:0;s:9:"虚函数";i:1;s:18:"静态成员函数";i:2;s:12:"构造函数";i:3;s:12:"析构函数";i:4;N;i:5;N;}', NULL),
	(173, 4, 9, 2, 5, '【2016年4月真题】下列关于对静态数据成员的描述中，正确的是（ ）', '', '', '', 'B', 0, '', NULL, 1, 0, 'a:6:{i:0;s:48:"静态数据成员不能用public控制符修饰";i:1;s:63:"静态数据成员可以直接用类名或者对象名来调用";i:2;s:48:"静态数据成员不可以被类的对象调用";i:3;s:49:"静态数据成员不能用private控制符修饰";i:4;N;i:5;N;}', NULL),
	(174, 4, 9, 2, 5, '【2016年4月真题】已知类A是类B的友元,类B是类C的友元，则（ ）', '', '', '', 'C', 0, '', NULL, 1, 1, 'a:6:{i:0;s:26:"类A一定是类C的友元";i:1;s:26:"类C一定是类A的友元";i:2;s:59:"类C的成员函数可以访问类B的对象的任何成员";i:3;s:59:"类A的成员函数可以访问类B的对象的任何成员";i:4;N;i:5;N;}', NULL),
	(175, 4, 9, 2, 5, '【2015年4月真题】对于友元描述正确的是（ ）', '', '', '', 'B', 0, '', NULL, 1, 0, 'a:6:{i:0;s:30:"友元是本类的成员函数";i:1;s:33:"友元不是本类的成员函数";i:2;s:18:"友元不是函数";i:3;s:36:"友元不能访问本类私有成员";i:4;N;i:5;N;}', NULL),
	(176, 4, 9, 2, 5, '【2015年10月真题】关于友元函数的描述中，错误的是（ ）', '', '', '', 'B', 0, '', NULL, 1, 0, 'a:6:{i:0;s:30:"友元函数不是成员函数";i:1;s:42:"友元函数只能访问类中私有成员";i:2;s:42:"友元函数破坏隐藏性，尽量少用";i:3;s:54:"友元函数说明在类体内，使用关键字friend";i:4;N;i:5;N;}', NULL),
	(177, 4, 9, 2, 5, '【2016年4月真题】下列不是类的成员函数的是（ ）', '', '', '', 'A', 0, '', NULL, 1, 0, 'a:6:{i:0;s:12:"友元函数";i:1;s:12:"构造函数";i:2;s:12:"析构函数";i:3;s:18:"拷贝构造函数";i:4;N;i:5;N;}', NULL),
	(178, 4, 9, 2, 5, '【2016年10月真题】下列哪个函数不是类的成员函数（ ）', '', '', '', 'C', 0, '', NULL, 1, 0, 'a:6:{i:0;s:12:"构造函数";i:1;s:12:"析构函数";i:2;s:12:"友元函数";i:3;s:18:"拷贝构造函数";i:4;N;i:5;N;}', NULL),
	(179, 4, 9, 2, 5, '【2016年10月真题】类模板template<class T>class?({…}；，其中友元函数f对特定类型T(如int)，使函数f(X<int>&)成为X<hat>模板类的友元，则其说明应为（ ）', '', '', '', 'B', 0, '', NULL, 1, 1, 'a:6:{i:0;s:18:"friend void“)；";i:1;s:25:"friend void f(X<T>＆)；";i:2;s:25:"friend void A：：f()；";i:3;s:19:"friend void C(T)；";i:4;N;i:5;N;}', NULL),
	(180, 4, 9, 2, 5, '【2017年4月真题】友元函数的主要作用是（ ）', '', '', '', 'A', 0, '', NULL, 1, 0, 'a:6:{i:0;s:21:"提高程序的效率";i:1;s:21:"加强类的封装性";i:2;s:24:"实现数据的隐蔽性";i:3;s:27:"增加成员函数的种类";i:4;N;i:5;N;}', NULL),
	(181, 4, 9, 2, 5, '【2017年10月真题】下列关于友元函数的描述,正确的是（）', '', '', '', 'A', 0, '', NULL, 1, 0, 'a:6:{i:0;s:66:"友元函数可以存取私有成员、公有成员和保护成员";i:1;s:33:"友元函数不可以是一个类";i:2;s:54:"友元函数的作用之一是实现数据的隐藏性";i:3;s:67:"在类中说明的友元函数,函数的定义不可在类体之外";i:4;N;i:5;N;}', NULL),
	(182, 4, 9, 2, 5, '【2016年4月真题】要求指针p既不可修改其本身的内容，也不可修改其所指向地址的内容，定义正确的是（ ）', '', '', '', 'D', 0, '', NULL, 1, 0, 'a:6:{i:0;s:27:"const char *p=“ABCD”；";i:1;s:27:"char * const p=“ ABCD”;";i:2;s:27:"char const *p=“ABCD”；";i:3;s:32:"const char * const p=“ABCD”;";i:4;N;i:5;N;}', NULL),
	(183, 4, 9, 2, 5, '【2015年10月真题】假定a为一个整型数组名，则元素a[4]的字节地址为（  ）', '', '', '', 'C', 0, '', NULL, 1, 0, 'a:6:{i:0;s:3:"a+4";i:1;s:3:"a+8";i:2;s:4:"a+16";i:3;s:4:"a+32";i:4;N;i:5;N;}', NULL),
	(184, 4, 9, 2, 5, '【2016年4月真题】以下能正确定义数组并正确赋初值的语句是（ ）', '', '', '', 'D', 0, '', NULL, 1, 0, 'a:6:{i:0;s:18:" int N =5,b[N][N];";i:1;s:28:" int a[2]={{1},{3},{4},{5}};";i:2;s:27:" int c[2][ ]={{1,2},{3,4}};";i:3;s:27:" int d[3][2]={{1,2},{3,4}};";i:4;N;i:5;N;}', NULL),
	(185, 4, 9, 2, 5, '【2017年10月真题】下面关于C++字符数组的叙述中,错误的是（ ）', '', '', '', 'D', 0, '', NULL, 1, 0, 'a:6:{i:0;s:30:"字符数组可以放字符串";i:1;s:48:"字符数组的字符可以整体输入、输出";i:2;s:77:"可以在赋值语句中通过值运算符“=”X对字符数组整体赋值";i:3;s:51:"可以用关系运算符对字符数组比较大小";i:4;N;i:5;N;}', NULL),
	(186, 4, 9, 2, 5, '【2016年4月真题】已知:p是一个指向类A数据成员m的指针，A1是类A的一个对象。如果要给m赋值为5，正确的是（ ）', '', '', '', 'D', 0, '', NULL, 1, 0, 'a:6:{i:0;s:8:" Al.p=5;";i:1;s:9:" A1->p=5;";i:2;s:11:" Al.≠p=5;";i:3;s:11:" °*A1.p=5;";i:4;N;i:5;N;}', NULL),
	(187, 4, 9, 4, 5, '【2015年4月真题】建立一个对象时，对象的状态是不确定的。为了使对象的状态确定，必须对其进行正确的【】。', '', '', '', '【初始化】', 0, '', NULL, 1, 0, NULL, NULL),
	(188, 4, 9, 4, 5, '【2015年10月真题】静态成员函数、友元函数、构造函数和析构函数中，不属于成员函数的是【】。', '', '', '', '【友元函数】', 0, '', NULL, 1, 0, NULL, NULL),
	(189, 4, 9, 4, 5, '【2015年10月真题】假定类AB中有一个公用属性的静态数据成员static int bb；在类外不通过对象名给该成员bb赋值为10的写法：【】。', '', '', '', '【int AB;bb=10;】', 0, '', NULL, 1, 0, NULL, NULL),
	(190, 4, 9, 4, 5, '【2015年10月真题】如果要把类B的成员函数void fun( )说明为类A的友元函数，则应在类A中加入语句【】。', '', '', '', '【[\'friend void B::fun\', \';\']】', 0, '', NULL, 1, 0, NULL, NULL),
	(191, 4, 9, 4, 5, '【2017年10月真题】如果要把A类成员函数f()且返回值为void声明为类B的友元函数,则应在类B的定义中加人语句【】。', '', '', '', '【[\'friend void A::f\', \';\']】', 0, '', NULL, 1, 0, NULL, NULL),
	(192, 4, 9, 4, 5, '【2015年4月真题】一个const对象只能访问【】成员函数。', '', '', '', '【常】', 0, '', NULL, 1, 0, NULL, NULL),
	(193, 4, 9, 4, 5, '【2015年10月真题】由const修饰的对象称为【】。', '', '', '', '【常对象】', 0, '', NULL, 1, 0, NULL, NULL),
	(194, 4, 9, 4, 5, '【2016年10月真题】使用关键字const修饰的数据成员称为【】数据成员。', '', '', '', '【常】', 0, '', NULL, 1, 0, NULL, NULL),
	(195, 4, 9, 4, 5, '【2015年4月真题】A是一个类，已有语句“A*p；P=new A[10]；”。要释放由P指向的动态空间，正确的语句应该是【】。', '', '', '', '【delete *p】', 0, '', NULL, 1, 0, NULL, NULL),
	(196, 4, 10, 2, 5, '【2016年4月真题】在C++中，类与类之间的继承关系具有（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"自反性";i:1;s:9:"对称性";i:2;s:9:"传递性";i:3;s:12:"反对称性";i:4;N;i:5;N;}', NULL),
	(197, 4, 10, 2, 5, '【2016年10月真题】派生类的对象对它的哪一类基类成员是可以访问的（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"公有继承的基类的公有成员";i:1;s:36:"公有继承的基类的保护成员";i:2;s:36:"公有继承的基类的私有成员";i:3;s:36:"保护继承的基类的公有成员";i:4;N;i:5;N;}', NULL),
	(198, 4, 10, 2, 5, '【2016年10月真题】下列有关重载函数的说法中错误的是（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"重载函数必须具有不同的返回值类型";i:1;s:27:"重载函数名必须相同";i:2;s:36:"重载丞数参数个数可以不同";i:3;s:42:"重载函数必须有不同的形参列表";i:4;N;i:5;N;}', NULL),
	(199, 4, 10, 2, 5, '【2016年10月真题】C++类体系中，不能被派生类继承的有（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"静态数据成员";i:1;s:12:"构造函数";i:2;s:9:"康函数";i:3;s:18:"静态成员函数";i:4;N;i:5;N;}', NULL),
	(200, 4, 10, 2, 5, '【2016年10月真题】下列对派生类的描述中，错误的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"派生类至少应有一个基类";i:1;s:81:"派生类的成员除了自己定义的成员外，还包含了它的基类成员";i:2;s:63:"基类中成员访闽权限继承到派生类中都保持不变";i:3;s:54:"一个派生类可以作为另一个派生类的基类";i:4;N;i:5;N;}', NULL),
	(201, 4, 10, 2, 5, '【2017年10月真题】下列关于类的维承描述中,错误的是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"基类不一定具有派生类的全部属性和方法";i:1;s:88:"派生类可以访问基类的所有数据成员,也能调用基类的所有成员函数";i:2;s:85:"继承描述类的层次关系,派生类可以具有与基类相同的属性和方法";i:3;s:73:"一个基类可以有多个派生类,一个派生类可以有多个基类";i:4;N;i:5;N;}', NULL),
	(202, 4, 10, 2, 5, '【2015年4月真题】当一个派生类公有继承一个基类时，基类中的所有公有成员成为派生类的（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"public成员";i:1;s:13:"private成员";i:2;s:15:"protected成员";i:3;s:6:"友元";i:4;N;i:5;N;}', NULL),
	(203, 4, 10, 4, 5, '【2015年4月真题】如果一个派生类只有一个唯一的基类，则这样的继承关系称为【】。', '', '', '', '【单继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(204, 4, 10, 4, 5, '【2015年4月真题】如果通过同一个基类派生一系列的类，则将这些类总称为【】。', '', '', '', '【类族】', 0, '', NULL, 0, 0, NULL, NULL),
	(205, 4, 10, 4, 5, '【2015年10月真题】如果通过同一个基类派生一系列的类，则将这些类总称为【】    。', '', '', '', '【类族】', 0, '', NULL, 0, 0, NULL, NULL),
	(206, 4, 10, 4, 5, '【2015年10月真题】为了实现运行时的多态性，派生类需重新定义基类中的【】 。', '', '', '', '【虚函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(207, 4, 10, 4, 5, '【2017年4月真题】C++语言中，派生类继承了基类的全部数据成员和除构造函数及【】之外的全部函数。', '', '', '', '【析构函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(208, 4, 10, 4, 5, '【2017年10月真题】一个抽象类的派生类可以实例化的必要条件是实现了所有的【】。', '', '', '', '【纯虚函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(209, 4, 10, 4, 5, '【2017年10月真题】派生类的主要用途是可以定义其基类中【】。', '', '', '', '【不具有的成员】', 0, '', NULL, 0, 0, NULL, NULL),
	(210, 4, 10, 4, 5, '【2015年10月真题】基类的公有成员在派生类中的访问权限由【】决定。', '', '', '', '【访问控制方式或继承方式】', 0, '', NULL, 0, 0, NULL, NULL),
	(211, 4, 10, 4, 5, '【2016年4月真题】C++中有两种继承:单一继承和【】。', '', '', '', '【多重继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(212, 4, 11, 2, 5, '【2015年10月真题】关于类模板的说法正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"类模板的主要作用是生成抽象类";i:1;s:78:"类模板实例化时，编译器将根据给出的模板实参生成一个类";i:2;s:48:"在类模板中的数据成员具有同样类型";i:3;s:42:"类模板中的成员函数没有返回值";i:4;N;i:5;N;}', NULL),
	(213, 4, 11, 2, 5, '【2018年04月真题】下列有关模板的描述中,错误的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:72:"模板把数据类型作为一个设计参数称为参数化程序设计";i:1;s:80:"使用时,模板参数与函数参数相同,是按位置而不是名称对应的";i:2;s:51:"模板实例化参数类型包括数据类型和值";i:3;s:39:"类模板与模板类是同一个概念";i:4;N;i:5;N;}', NULL),
	(214, 4, 11, 2, 5, '【2018年10月真题】以下类模板定义正确的为（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:19:" template <class T>";i:1;s:32:" template <class T, class int i>";i:2;s:31:" template <class T, typename T>";i:3;s:24:" template <class T1, T2>";i:4;N;i:5;N;}', NULL),
	(215, 4, 11, 2, 5, '【2018年10月真题】允许用户为类定义一种模式,使得类中的某些数据成员及某些成员函数的返回值能取任意类型,这是一个（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"类模板";i:1;s:9:"模板类";i:2;s:12:"函数模板";i:3;s:12:"模板函数";i:4;N;i:5;N;}', NULL),
	(216, 4, 11, 4, 5, '【2017年10月真题】在C++中,利用向量类模板定义一个具有10个int的向量A,其元素均被置为1,实现此操作的语句是                  【】。', '', '', '', '【[\'vector<int>A\', \'10\']】【1)】', 0, '', NULL, 0, 0, NULL, NULL),
	(217, 4, 11, 4, 5, '【2018年04月真题】在类体外面定义成员函数时,必须用关键字【】重写类模板声明。', '', '', '', '【template】', 0, '', NULL, 0, 0, NULL, NULL),
	(218, 4, 11, 4, 5, '【2016年4月真题】vector 类中用于删除向量中的所有对象的函数是【】 。', '', '', '', '【clear（）】', 0, '', NULL, 0, 0, NULL, NULL),
	(219, 4, 11, 4, 5, '【2016年4月真题】已知有20个元素int类型向最VI，若用VI初始化为V2向量，语句是 【】 。', '', '', '', '【[\'vector<int>V2\', \'V1\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(220, 4, 11, 4, 5, '【2016年10月真题】insert(iterator it，const T&)是向it所指向量位置前【】个对象。', '', '', '', '【插入】', 0, '', NULL, 0, 0, NULL, NULL),
	(221, 4, 12, 2, 5, '【2015年10月真题】有关多态性说法不正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:72:"C++语言的多态性分为编译时的多态性和运行时的多态性";i:1;s:48:"编译时的多态性可通过函数重载实现";i:2;s:54:"运行时的多态性可通过模板和虚函数实现";i:3;s:54:"实现运行时多态性的机制称为动态多态性";i:4;N;i:5;N;}', NULL),
	(222, 4, 12, 2, 5, '【2017年4月真题】不能作为函数重载的判断依据的是（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"const";i:1;s:12:"返回类型";i:2;s:12:"参数个数";i:3;s:12:"参数类型";i:4;N;i:5;N;}', NULL),
	(223, 4, 12, 2, 5, '【2015年4月真题】下面函数原型声明中，声明了fun为虚函数的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"void fun()=0";i:1;s:20:"virtual void fun()=O";i:2;s:18:"virtual void fun()";i:3;s:20:"virtual void fun(){}";i:4;N;i:5;N;}', NULL),
	(224, 4, 12, 2, 5, '【2015年4月真题】下列虚基类的声明中，正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:26:"class virtual B：public A";i:1;s:26:"class B：virtual public A";i:2;s:26:"class B：public A virtual";i:3;s:26:"virtual class B：public A";i:4;N;i:5;N;}', NULL),
	(225, 4, 12, 2, 5, '【2016年4月真题】类Cat是类Animal的公有派生类，类Animal和类Cat中都定义了虚函数func()，P是一个指向类Animal对象的指针则p -> Animal: :func()将（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"调用类Animal中的函数func()";i:1;s:30:"调用类Cat中的函数func()";i:2;s:82:"根据p所指的对象类型而确定调用类Animal中或类Cat中的函数func()";i:3;s:58:"既调用类Animal中函数，也调用类 Cat中的函数";i:4;N;i:5;N;}', NULL),
	(226, 4, 12, 2, 5, '【2016年4月真题】以下基类中的成员函数表示纯虚函数的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:" virtual void vf( int)";i:1;s:16:" void vf(int) =0";i:2;s:21:" virtual void vf() =0";i:3;s:23:" virtual void yf(int){}";i:4;N;i:5;N;}', NULL),
	(227, 4, 12, 2, 5, '【2017年4月真题】下列函数的说明中,表示纯虚函数的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:20:"virtual int vf( int}";i:1;s:15:"void vf(int) =0";i:2;s:20:"virual void vf( ) =0";i:3;s:23:"virtual void vf( int){}";i:4;N;i:5;N;}', NULL),
	(228, 4, 12, 2, 5, '【2017年4月真题】下列关于虚函数的描述中,正确的是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"使用虚函数就一定产生多态性";i:1;s:73:"虚函数只能是类中的一一个成员函数,但不能是静态成员";i:2;s:46:"一个类中仅可以声明-一个纯虚函数";i:3;s:66:"在构造函数和析构函数中调用虚函数采用动态联编";i:4;N;i:5;N;}', NULL),
	(229, 4, 12, 2, 5, '【2015年10月真题】当一个类的某个函数被说明为virtual时，在该类的所有派生类中的同原型函数（ ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"都是虚函数";i:1;s:39:"只有被重新说明时才是虚函数";i:2;s:18:"都不是虚函数";i:3;s:49:"只有被重新说明为virtual时才是虚函数";i:4;N;i:5;N;}', NULL),
	(230, 4, 12, 2, 5, '【2016年10月真题】如果A是抽象类，刚下面正确的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"A中没有纯虚函数";i:1;s:6:"A a；";i:2;s:9:"A a[3]；";i:3;s:7:"A*pa；";i:4;N;i:5;N;}', NULL),
	(231, 4, 12, 2, 5, '【2016年10月真题】下列关于纯虚函数与抽象类的描述中，错误的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:69:"纯虚函数是一种特殊的函数，它允许没有具体的实现";i:1;s:39:"抽象类是指具有纯虚函数的类";i:2;s:87:"一个基类的说疆中有纯虚函数，该基类的派生类一定不再是抽象类";i:3;s:81:"抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出";i:4;N;i:5;N;}', NULL),
	(232, 4, 12, 2, 5, '【2016年10月真题】动态编联所支持的多态性称为运行时的多态性，支持的函数是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"构造函数";i:1;s:12:"友元函数";i:2;s:6:"继承";i:3;s:9:"虚函数";i:4;N;i:5;N;}', NULL),
	(233, 4, 12, 4, 5, '【2015年10月真题】函数重载时，编译系统会根据【】或形参的个数来区分。', '', '', '', '【形参的类型】', 0, '', NULL, 0, 0, NULL, NULL),
	(234, 4, 12, 4, 5, '【2016年4月真题】C++ 支持两种多态性:【】时的多态性和运行时的多态性。', '', '', '', '【编译】', 0, '', NULL, 0, 0, NULL, NULL),
	(235, 4, 12, 4, 5, '【2016年4月真题】重载函数在参数类型或参数个数上不同，但【】必须相同。', '', '', '', '【函数名】', 0, '', NULL, 0, 0, NULL, NULL),
	(236, 4, 12, 4, 5, '【2016年10月真题】函数重载可使一个函数名具有多种功能，称这种特性为【】。', '', '', '', '【多态性】', 0, '', NULL, 0, 0, NULL, NULL),
	(237, 4, 12, 4, 5, '【2017年4月真题】不重载函数必须有不同的【】。', '', '', '', '【形参列表】', 0, '', NULL, 0, 0, NULL, NULL),
	(238, 4, 12, 4, 5, '【2016年4月真题】抽象类中至少要有一个【】函数。', '', '', '', '【纯虚】', 0, '', NULL, 0, 0, NULL, NULL),
	(239, 4, 12, 4, 5, '【2016年10月真题】说明纯虚函数的一般形式为”class类名{ 【】函数类型函数名(参数列表)=0；}；″。', '', '', '', '【virtual】', 0, '', NULL, 0, 0, NULL, NULL),
	(240, 4, 12, 4, 5, '【2017年10月真题】定义虚函数所用的关键字是【】。', '', '', '', '【virtual】', 0, '', NULL, 0, 0, NULL, NULL),
	(241, 4, 13, 2, 5, '【2015年4月真题】下列运算符中，在C++语言中不能重载的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"*";i:1;s:2:">=";i:2;s:6:"：：";i:3;s:3:"／";i:4;N;i:5;N;}', NULL),
	(242, 4, 13, 2, 5, '【2016年4月真题】如果表达式++a中的“++”是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:16:"a.operator ++(1)";i:1;s:15:"operator ++ (a)";i:2;s:15:"operator++(a,1)";i:3;s:16:"a. operator ++()";i:4;N;i:5;N;}', NULL),
	(243, 4, 13, 2, 5, '【2016年4月真题】下列运算符中，在C++语言中不能重载的是（ ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"*";i:1;s:2:">=";i:2;s:2:"::";i:3;s:1:"/";i:4;N;i:5;N;}', NULL),
	(244, 4, 13, 2, 5, '【2017年4月真题】以下关于运算符重载的描述中，错误的是（ ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"运算符重载其实就是函数重载";i:1;s:46:"成员运算符比友元运算符少-个参数";i:2;s:29:"需要使用关键字operator";i:3;s:48:"成员运算符比友元运算符多一个参数";i:4;N;i:5;N;}', NULL),
	(245, 4, 13, 2, 5, '【2017年10月真题】下列输出语句中,正确的是（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"cout<<("%c\\n","student")";i:1;s:22:"cout<<("%s\\n","hello")";i:2;s:17:"cout<<("%c\\n,"n")";i:3;s:17:"cout<<("%s\\n",&a)";i:4;N;i:5;N;}', NULL),
	(246, 4, 13, 2, 5, '【2017年10月真题】下列输出字符\'d\'的方法中,错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"cout<<put(‘d’)";i:1;s:13:"cout<<‘d’";i:2;s:17:"cout.put(‘d’)";i:3;s:22:"char a=’d’;cout<<a";i:4;N;i:5;N;}', NULL),
	(247, 4, 13, 2, 5, '【2016年10月真题】cout是C++的（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"关键字";i:1;s:6:"对象";i:2;s:3:"类";i:3;s:9:"运算符";i:4;N;i:5;N;}', NULL),
	(248, 4, 13, 2, 5, '【2016年10月真题】进行文件操作时需要包含头文件（ ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"iostream";i:1;s:7:"fstream";i:2;s:5:"stdio";i:3;s:6:"stdlib";i:4;N;i:5;N;}', NULL),
	(249, 4, 13, 4, 5, '【2015年4月真题】重载运算符的含义必须清楚，不能有【】        。', '', '', '', '【二义性】', 0, '', NULL, 0, 0, NULL, NULL),
	(250, 4, 13, 4, 5, '【2016年4月真题】重载的运算符保持其原有的操作数、【】         和结合性不变。', '', '', '', '【优先级】', 0, '', NULL, 0, 0, NULL, NULL),
	(251, 4, 13, 4, 5, '【2016年10月真题】运算符重载需要使用关键字″ 【】  ″。', '', '', '', '【operator】', 0, '', NULL, 0, 0, NULL, NULL),
	(252, 4, 13, 4, 5, '【2017年10月真题】重戴的运算符保持其原有的【】 、优先级和结合性不变。', '', '', '', '【操作数】', 0, '', NULL, 0, 0, NULL, NULL),
	(253, 4, 13, 4, 5, '【2015年4月真题】cin后面的符号是：>>，cout后面的符号是【】 。', '', '', '', '【<<】', 0, '', NULL, 0, 0, NULL, NULL),
	(254, 4, 13, 4, 5, '【2015年4月真题】执行下列代码：         \n    double  pi=3.1415926；cout<<setprecision(5)<<pi：\n    程序的输出结果是【】 。', '', '', '', '【3.1416】', 0, '', NULL, 0, 0, NULL, NULL),
	(255, 4, 13, 4, 5, '【2015年10月真题】C语言中scanf命令在C++中改用：【】。', '', '', '', '【cin】', 0, '', NULL, 0, 0, NULL, NULL),
	(256, 4, 13, 4, 5, '【2015年10月真题】执行下列程序double a=3.1415926，b=3.14；cout<<setprecision(5)<<a<<〝,〞<<setprecision(5)<<b<<endl；程序的输出结果是【】 。', '', '', '', '【3.1416】【3.14】', 0, '', NULL, 0, 0, NULL, NULL),
	(257, 4, 13, 4, 5, '【2015年10月真题】C++中ostream的直接基类 【】       。', '', '', '', '【ios】', 0, '', NULL, 0, 0, NULL, NULL),
	(258, 4, 13, 4, 5, '【2016年4月真题】C++流库预定义了4个流，它们分别是cin、cout、clog和 【】   。', '', '', '', '【cerr】', 0, '', NULL, 0, 0, NULL, NULL),
	(259, 4, 13, 4, 5, '【2016年10月真题】语句″  【】         ；″用来向屏幕输出显示信息″Hello!″。', '', '', '', '【eout<<" Hello!"】', 0, '', NULL, 0, 0, NULL, NULL),
	(260, 4, 13, 4, 5, '【2017年4月真题】在C++中输人输出是通过流来完成的，输出操作是将一个对象的状态转换成一个 【】序列。', '', '', '', '【字符】', 0, '', NULL, 0, 0, NULL, NULL),
	(261, 4, 13, 4, 5, '【2017年10月真题】cin的输入流istream的一个对象，处理标准输入对象,【】是输出流ostream的一个对象，处理标准输出。', '', '', '', '【cout】', 0, '', NULL, 0, 0, NULL, NULL),
	(262, 4, 13, 4, 5, '【2015年4月真题】设要把一个文件输出流对象myFile与文件“f：＼myText.txt”相关联，所用的C++语句是【】   。', '', '', '', '【[\'ifstream myFile\', \'”f:\\\\myText.txt”\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(263, 4, 14, 2, 5, '要求指纯p既不可修改其本身的内容，也不可修改其所指向地址的内容定义正确的是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"const char*p=“ABCD";";i:1;s:24:" char *const p=“ABCD";";i:2;s:23:"char const*p=“ABCD”";i:3;s:29:" const char *const p=“ABCD"";i:4;N;i:5;N;}', NULL),
	(264, 4, 14, 2, 5, '在C++中,类与类之间的继承关系具有', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"自反性";i:1;s:9:"对称性";i:2;s:9:"传递性";i:3;s:13:" 反对称性";i:4;N;i:5;N;}', NULL),
	(265, 4, 14, 2, 5, '下列关于对静态数据成员的描述中,正确的是', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"静态数据成员不能用public控制符修饰";i:1;s:63:"静态数据成员可以直接用类名或者对象名来调用";i:2;s:48:"静态数据成员不可以被类的对象调用";i:3;s:49:"静态数据成员不能用private控制符修饰";i:4;N;i:5;N;}', NULL),
	(266, 4, 14, 2, 5, '适宜采用inline定义函数情况是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"函数体含有循环语句";i:1;s:27:"函数体含有递归语句";i:2;s:30:"函数代码多，不常调用";i:3;s:30:"函数代码少，频繁调用";i:4;N;i:5;N;}', NULL),
	(267, 4, 14, 2, 5, '通常拷贝构造函数的参数是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"某个对象的成员名";i:1;s:24:"某个对象的指针名";i:2;s:24:"某个对象的引用名";i:3;s:15:"某个对象名";i:4;N;i:5;N;}', NULL),
	(268, 4, 14, 2, 5, '下列不是类的成员函数的是', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"友元函数";i:1;s:30:"构造函数     C析构函数";i:2;s:18:"拷贝构造函数";i:3;N;i:4;N;i:5;N;}', NULL),
	(269, 4, 14, 2, 5, '类Cat是类Animal的公有派生类，类 Animnl和类Cat中都定义了虚函数 func(  ), p\n是一个指向类Animal对象的指针,则P -> Animal::func(   )将', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:35:"调用类Animal中的函数func(  )";i:1;s:32:"调用类Cat中的函数func(  )";i:2;s:80:"根护p所指的对象 型而确定调用类Animal中类cat中的函数func(  )";i:3;s:59:" 既调用类Animal中函数，也调用类Cat中的函数";i:4;N;i:5;N;}', NULL),
	(270, 4, 14, 2, 5, '如果表达式++a中的“++”是作为成员函数重载的运算符，若采用运算符函数调用格式，则可表示为', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:19:" a.operator ++(1)";i:1;s:15:"operator ++(a)";i:2;s:17:" operator++(a.1)";i:3;s:17:"a. operator++( )";i:4;N;i:5;N;}', NULL),
	(271, 4, 14, 2, 5, '实现两个相同类型数加法的函效模板的声明是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:14:" add(T x,T y)";i:1;s:10:"T add(x,y)";i:2;s:12:"T add(T x,y)";i:3;s:17:" T add(T x,Ty)";i:4;N;i:5;N;}', NULL),
	(272, 4, 14, 2, 5, '以下基类中的成员函数表示纯虚函数的是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:23:" virtual void vf(int)";i:1;s:19:" void vf( int)=0";i:2;s:26:" virtual void vf(  )=0";i:3;s:25:"virtual void  yf(int)||";i:4;N;i:5;N;}', NULL),
	(273, 4, 14, 2, 5, '假定一个类的构造函数为A(int aa, int bb)|a=aa ++;b=a* ++bb;|，则执行Ax (4,5) ;语句后,x.a和x. b的值分别为', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"4和5";i:1;s:6:"4和20";i:2;s:6:"4和24";i:3;s:6:"20和5";i:4;N;i:5;N;}', NULL),
	(274, 4, 14, 2, 5, '下列运算符中,在C++语言中不能重载的是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:" *";i:1;s:2:">=";i:2;s:4:" ::";i:3;s:3:" /";i:4;N;i:5;N;}', NULL),
	(275, 4, 14, 2, 5, '在编译指令中,宏定义使用哪个指令', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:" #if";i:1;s:8:"#include";i:2;s:7:"#define";i:3;s:6:"#error";i:4;N;i:5;N;}', NULL),
	(276, 4, 14, 2, 5, '以下能正确定义数组并正确赋初值的语句是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"int N=5 ,b[N][N];";i:1;s:27:"int a[2]={{1},{3},{4},{5}};";i:2;s:28:"Int c[2][ ]={{1,2},{3,4}} ;";i:3;s:28:"int d[3][2]={{1,2},{3,4}} ;";i:4;N;i:5;N;}', NULL),
	(277, 4, 14, 2, 5, '关于函数模板，描述错误的是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:67:"函数模板必须由程序员实例化为可执行的函数模板;";i:1;s:45:"函数模板的实例化由编译器实现；";i:2;s:74:"一个类定义中，只要有一个函数模板,则这个类是类模板;";i:3;s:96:"类模板的成员函数都是函数模板,类模板实例化后,成员函数也随之实例化;";i:4;N;i:5;N;}', NULL),
	(278, 4, 14, 2, 5, '按照标识符的要求，不能组成标识符的是', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"连接符";i:1;s:9:"下划线";i:2;s:15:"大小写字母";i:3;s:12:"数字字母";i:4;N;i:5;N;}', NULL),
	(279, 4, 14, 2, 5, '已知类A是类B的友元,类B是类C的友元，则', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:26:"类A一定是类C的友元";i:1;s:26:"类C一定是类A的友元";i:2;s:59:"类C的成员函数可以访问类B的对象的任何成员";i:3;s:59:"类A的成员函数可以访问类B的对象的任何成员";i:4;N;i:5;N;}', NULL),
	(280, 4, 14, 2, 5, '已知：P是一个指向类A数据成员m的指针,A1是类A的一个对象。如果要给m赋值为5,正确的是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"A1.p=5；";i:1;s:13:"A1→p=5 ；";i:2;s:8:"A1.*p=5;";i:3;s:8:"*A1:p=5;";i:4;N;i:5;N;}', NULL),
	(281, 4, 14, 2, 5, '关于this指针的说法错误的是', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:" this指针必须显式声明";i:1;s:55:"当创建一个对象后，this指什就指向该对象";i:2;s:34:"动态成员函数拥有this指针";i:3;s:37:"静态成员函数不拥有this指针";i:4;N;i:5;N;}', NULL),
	(282, 4, 14, 2, 5, '已知:func( )函数是一个类的常成员函数,它无返回值，下列表示中，是正确的是', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:23:" void func( ) const;";i:1;s:19:"const void func( );";i:2;s:22:" vold const func( )";i:3;s:18:"void func(const);";i:4;N;i:5;N;}', NULL),
	(283, 4, 14, 4, 5, '【】通常使用对象的引用来初始化创建中的对象。', '', '', '', '【拷贝构造函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(284, 4, 14, 4, 5, '抽象类中至少要有一个【】函数。', '', '', '', '【纯虚】', 0, '', NULL, 0, 0, NULL, NULL),
	(285, 4, 14, 4, 5, 'vector类中用干删除向量中的所有对象的函数是【】。', '', '', '', '【clear】', 0, '', NULL, 0, 0, NULL, NULL),
	(286, 4, 14, 4, 5, '重载的运算符保持其原有的操作数、【】  和结合性不变。', '', '', '', '【优先级】', 0, '', NULL, 0, 0, NULL, NULL),
	(287, 4, 14, 4, 5, '执行下列代码\n string str("NihaoC++");\ncout << str. substr(5,3);\n程序的输出结果是【】。', '', '', '', '【C++】', 0, '', NULL, 0, 0, NULL, NULL),
	(288, 4, 14, 4, 5, 'C++中有两种继承，单一继承和【】。', '', '', '', '【多重继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(289, 4, 14, 4, 5, 'C++支持两种多态性:  【】时的多态性和运行时的多态性。', '', '', '', '【编译】', 0, '', NULL, 0, 0, NULL, NULL),
	(290, 4, 14, 4, 5, '在用class定义一个类时，数据成员和成员函数的默认访问权限是【】。', '', '', '', '【[\'Private\', \'私有\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(291, 4, 14, 4, 5, 'C++流库预定义了4个流，它们分别是cin、cout sclog和【】。', '', '', '', '【cerr】', 0, '', NULL, 0, 0, NULL, NULL),
	(292, 4, 14, 4, 5, '在C++中，有两种给出注释的方法。一种是沿用C语言的注释符,即/**/。另一种是从它开始 ,直到它所在行尾的字符部为注释的注释符,即【】。', '', '', '', '【//】', 0, '', NULL, 0, 0, NULL, NULL),
	(293, 4, 14, 4, 5, '使用new为int数组动态分配10个存储空问是【】。', '', '', '', '【new  int[10]】', 0, '', NULL, 0, 0, NULL, NULL),
	(294, 4, 14, 4, 5, '假设int a=1,b =2;则表达式( ++a/b) *b--的值为【】。', '', '', '', '【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(295, 4, 14, 4, 5, 'C++程序的源文件扩展名为【】。', '', '', '', '【OPP】', 0, '', NULL, 0, 0, NULL, NULL),
	(296, 4, 14, 4, 5, '语句序列\nifstream infile; \n infile. open(" data. dat");\n的功能可用一个语句实现,这个语句是【】。', '', '', '', '【[\'ifstream  infile\', \'"data\']】【dat")】', 0, '', NULL, 0, 0, NULL, NULL),
	(297, 4, 14, 4, 5, '已如有20个元素int类型向量VI,若用VI初始化为V2向量，语句是【】。', '', '', '', '【[\'vector <int>V2\', \'V1\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(298, 4, 14, 4, 5, '为了避免可能出现的歧义 C++对if~else语句配对规则规定为:else总是与【】。', '', '', '', '【上面最近的if】', 0, '', NULL, 0, 0, NULL, NULL),
	(299, 4, 14, 4, 5, 'C++程序的编译是以【】为单位进行的。', '', '', '', '【文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(300, 4, 14, 4, 5, '重载函数在参数类型或参数个数上不同，但，【】必须相同。', '', '', '', '【函数名】', 0, '', NULL, 0, 0, NULL, NULL),
	(301, 4, 14, 4, 5, '举出C++中两种代码复用的方式:  【】、复用。', '', '', '', '【继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(302, 4, 14, 4, 5, '下面程序运行的结果是 【】\n #include < iostream.h>\nvoid main(  ){\ncoul. fIl(‘* );\ncout. widh(6);\n cou<<" hello" << endl;\ncout, clear(  )；', '', '', '', '【*hello】', 0, '', NULL, 0, 0, NULL, NULL),
	(303, 4, 15, 2, 5, '一个函数的功能不太复杂，但要求被频繁调用，选用最适合的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"内联函数";i:1;s:12:"重载函数";i:2;s:12:"递归函数";i:3;s:12:"嵌套函数";i:4;N;i:5;N;}', NULL),
	(304, 4, 15, 2, 5, '假定有类AB，有相应的构造函数定义，能正确执行“AB a(4)，b(5)，c[3]，*p[2]=\n{&a，&b}；”语句，请问执行完此语句后共调用该类析构函数的次数为（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:"14";i:1;s:1:"5";i:2;s:1:"3";i:3;s:1:"1";i:4;N;i:5;N;}', NULL),
	(305, 4, 15, 2, 5, '在下面有关析构函数特征的描述中，正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"一个类中可以定义多个析构函数";i:1;s:36:"析构函数名与类名完全相同";i:2;s:36:"析构函数不能指定返回类型";i:3;s:42:"析构函数可以有一个或多个参数";i:4;N;i:5;N;}', NULL),
	(306, 4, 15, 2, 5, '派生类的对象对它的哪一类基类成员是可以访问的（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"公有继承的基类的公有成员";i:1;s:36:"公有继承的基类的保护成员";i:2;s:36:"公有继承的基类的私有成员";i:3;s:36:"保护继承的基类的公有成员";i:4;N;i:5;N;}', NULL),
	(307, 4, 15, 2, 5, '如果A是抽象类，刚下面正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"A中没有纯虚函数";i:1;s:6:"A a；";i:2;s:9:"A a[3]；";i:3;s:7:"A*pa；";i:4;N;i:5;N;}', NULL),
	(308, 4, 15, 2, 5, '下列关于纯虚函数与抽象类的描述中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:69:"纯虚函数是一种特殊的函数，它允许没有具体的实现";i:1;s:39:"抽象类是指具有纯虚函数的类";i:2;s:87:"一个基类的说疆中有纯虚函数，该基类的派生类一定不再是抽象类";i:3;s:81:"抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出";i:4;N;i:5;N;}', NULL),
	(309, 4, 15, 2, 5, 'cout是C++的（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"关键字";i:1;s:6:"对象";i:2;s:3:"类";i:3;s:9:"运算符";i:4;N;i:5;N;}', NULL),
	(310, 4, 15, 2, 5, '下列哪个函数不是类的成员函数（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"构造函数";i:1;s:12:"析构函数";i:2;s:12:"友元函数";i:3;s:18:"拷贝构造函数";i:4;N;i:5;N;}', NULL),
	(311, 4, 15, 2, 5, '下列有关重载函数的说法中错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"重载函数必须具有不同的返回值类型";i:1;s:27:"重载函数名必须相同";i:2;s:36:"重载丞数参数个数可以不同";i:3;s:42:"重载函数必须有不同的形参列表";i:4;N;i:5;N;}', NULL),
	(312, 4, 15, 2, 5, '下面说法正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"生成对象时调用析构函数";i:1;s:45:"定义类时必须写出该类的构造函数";i:2;s:66:"调用构造函数时必须在主函数中明确写出调用格式";i:3;s:27:"析构函数不可以重载";i:4;N;i:5;N;}', NULL),
	(313, 4, 15, 2, 5, '在编译指令中，宏定义使用指令（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"#define";i:1;s:8:"#include";i:2;s:8:"#typedef";i:3;s:7:"#friend";i:4;N;i:5;N;}', NULL),
	(314, 4, 15, 2, 5, '假设声明了以下的西数模板，错误的调用语句是（  ）\nTemplate<class T>\nT max(T x，T y){ return（x>y）? x:y；}\n并定义了int I;char c;', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"max（i,i）";i:1;s:12:"max（c,c）";i:2;s:21:"max（（int）c,i）";i:3;s:12:"max（i,c）";i:4;N;i:5;N;}', NULL),
	(315, 4, 15, 2, 5, '若有说明：int n=2，*P=＆n，*q=p；，则以下非法的赋值语句是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"n=*q";i:1;s:3:"P=n";i:2;s:3:"P=q";i:3;s:5:"*q=*P";i:4;N;i:5;N;}', NULL),
	(316, 4, 15, 2, 5, '进行文件操作时需要包含头文件（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"iostream";i:1;s:7:"fstream";i:2;s:5:"stdio";i:3;s:6:"stdlib";i:4;N;i:5;N;}', NULL),
	(317, 4, 15, 2, 5, '类模板template<class T>class?({…}；，其中友元函数f对特定类型T(如int)，使函数f(X<int>&)成为X<hat>模板类的友元，则其说明应为（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"friend void“)；";i:1;s:25:"friend void f(X<T>＆)；";i:2;s:25:"friend void A：：f()；";i:3;s:19:"friend void C(T)；";i:4;N;i:5;N;}', NULL),
	(318, 4, 15, 2, 5, '动态编联所支持的多态性称为运行时的多态性，支持的函数是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"构造函数";i:1;s:12:"友元函数";i:2;s:6:"继承";i:3;s:9:"虚函数";i:4;N;i:5;N;}', NULL),
	(319, 4, 15, 2, 5, '用运算符delete删除—个动态对象时（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:72:"首先为该动态对象调用构造函数，再释放其占用的内存";i:1;s:72:"首先释放该动态对象占用的内存，再为其调用构造函数";i:2;s:72:"首先为该动态对象调用析构函数，荐释放其占用的内存";i:3;s:72:"首先释放该动态对象占用的内存，再为其调用析构函数";i:4;N;i:5;N;}', NULL),
	(320, 4, 15, 2, 5, '下列字符常量的写法中，错误的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"′＼t′";i:1;s:7:"′b′";i:2;s:7:"′*′";i:3;s:7:"′a′";i:4;N;i:5;N;}', NULL),
	(321, 4, 15, 2, 5, 'C++类体系中，不能被派生类继承的有（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"静态数据成员";i:1;s:12:"构造函数";i:2;s:9:"康函数";i:3;s:18:"静态成员函数";i:4;N;i:5;N;}', NULL),
	(322, 4, 15, 2, 5, '下列对派生类的描述中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"派生类至少应有一个基类";i:1;s:81:"派生类的成员除了自己定义的成员外，还包含了它的基类成员";i:2;s:63:"基类中成员访闽权限继承到派生类中都保持不变";i:3;s:54:"一个派生类可以作为另一个派生类的基类";i:4;N;i:5;N;}', NULL),
	(323, 4, 15, 4, 5, 'C++注释方式″／／″的有效范围从″／／″至【】结束。', '', '', '', '【本行】', 0, '', NULL, 0, 0, NULL, NULL),
	(324, 4, 15, 4, 5, 'C++程序有且只能有一个名为【】的主函数。', '', '', '', '【main】', 0, '', NULL, 0, 0, NULL, NULL),
	(325, 4, 15, 4, 5, '语句″【】；″用来向屏幕输出显示信息″Hello!″。', '', '', '', '【eout<<"Hello!"】', 0, '', NULL, 0, 0, NULL, NULL),
	(326, 4, 15, 4, 5, '所谓″ 【】  ″就是将一个新标识符和一块已经存在的存储区域相关联。', '', '', '', '【引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(327, 4, 15, 4, 5, '动态分配内存使用关键字【】，释放内存使用关键字delete。', '', '', '', '【new】', 0, '', NULL, 0, 0, NULL, NULL),
	(328, 4, 15, 4, 5, '表达式″20／3*sqrt(4．0)／5″值的数据类型是  【】  。', '', '', '', '【double】', 0, '', NULL, 0, 0, NULL, NULL),
	(329, 4, 15, 4, 5, '面向对象的程序设计方法是以【】 代表求解问题的中心环节。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(330, 4, 15, 4, 5, '对象的【】只能由这个对象的操作来存取。', '', '', '', '【属性】', 0, '', NULL, 0, 0, NULL, NULL),
	(331, 4, 15, 4, 5, '使用关键字inline说明的函数称为【】函数。', '', '', '', '【内联】', 0, '', NULL, 0, 0, NULL, NULL),
	(332, 4, 15, 4, 5, '类对象一般都包括数据成员和【】。', '', '', '', '【成员函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(333, 4, 15, 4, 5, '将对象作为函数参数，是将实参对象的值传递给【】。', '', '', '', '【形参对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(334, 4, 15, 4, 5, 'C++函数的返回值类型可以是除【】和函数以外的任何类型。', '', '', '', '【数组】', 0, '', NULL, 0, 0, NULL, NULL),
	(335, 4, 15, 4, 5, '函数重载可使一个函数名具有多种功能，称这种特性为【】。', '', '', '', '【多态性】', 0, '', NULL, 0, 0, NULL, NULL),
	(336, 4, 15, 4, 5, '【】是类的实例。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(337, 4, 15, 4, 5, '关键字private、public和 【】 以后的成员分别叫做私有成员、公有成员和保护成员。', '', '', '', '【protected】', 0, '', NULL, 0, 0, NULL, NULL),
	(338, 4, 15, 4, 5, '使用关键字const修饰的数据成员称为【】数据成员。', '', '', '', '【常】', 0, '', NULL, 0, 0, NULL, NULL),
	(339, 4, 15, 4, 5, '对MyFirst类定义析构函数是【】。', '', '', '', '【[\'~MyFirst\', \'{}\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(340, 4, 15, 4, 5, 'insert(iterator it，const T&)是向it所指向量位置前【】个对象。', '', '', '', '【插入】', 0, '', NULL, 0, 0, NULL, NULL),
	(341, 4, 15, 4, 5, '说明纯虚函数的一般形式为”class类名{ 【】函数类型函数名(参数列表)\n=0；}；″。', '', '', '', '【virtual】', 0, '', NULL, 0, 0, NULL, NULL),
	(342, 4, 15, 4, 5, '运算符重载需要使用关键字″  【】     ″。', '', '', '', '【operator】', 0, '', NULL, 0, 0, NULL, NULL),
	(343, 4, 16, 2, 5, '以下说法中不正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:93:"C++程序中必须有个主函数 main()，而且是从 main( )的第一条语句开始执行";i:1;s:93:"非主函数都是在执行主函数时，通过函数调用或嵌套调用而得以执行的";i:2;s:36:"主函数可以在任何地方出现";i:3;s:36:"主函数必须出现在固定位置";i:4;N;i:5;N;}', NULL),
	(344, 4, 16, 2, 5, '若有定义int *p=new int(0) ，则下列说法正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:49:"系统用指针变量p来表示所指整型变量";i:1;s:58:"声明一个指针变量p，指向名为new的存储单元";i:2;s:61:"系统为指针变量p分配一个整型数据的存储空间";i:3;s:103:"通过运算符new，分配-一个整型数据的存储空间，并将其内存地址赋予指针变量";i:4;N;i:5;N;}', NULL),
	(345, 4, 16, 2, 5, '以下有关类与对象的叙述中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"对象是类的一个实例";i:1;s:30:"一个类可以有多个对象";i:2;s:48:"任何一个对象都归属于一个具体的类";i:3;s:84:"只要是某个类的对象，那么该对象就可以访问这个类的所有成员";i:4;N;i:5;N;}', NULL),
	(346, 4, 16, 2, 5, '以下有关构造函数的叙述中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"构造函数名必须和类名- -致";i:1;s:42:"构造函数在定义对象时自动执行";i:2;s:45:"在一个类中构造函数有且仅有一个";i:3;s:54:"构造函数可以在类体内声明在类体外实现";i:4;N;i:5;N;}', NULL),
	(347, 4, 16, 2, 5, '以下叙述中正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"类成员的定义必须放在类体内部";i:1;s:63:"在类中，不作特别说明的数据成员均为私有类型";i:2;s:63:"在类中，不作特别说明的数据成员均为公有类型";i:3;s:66:"类成员的定义必须是成员变量在前，成员函数在后";i:4;N;i:5;N;}', NULL),
	(348, 4, 16, 2, 5, '友元函数的主要作用是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"提高程序的效率";i:1;s:21:"加强类的封装性";i:2;s:24:"实现数据的隐蔽性";i:3;s:27:"增加成员函数的种类";i:4;N;i:5;N;}', NULL),
	(349, 4, 16, 2, 5, '在C++中，字符型数据在内存中的存放形式为（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"原码";i:1;s:6:"BCD码";i:2;s:5:"ASCII";i:3;s:6:"反码";i:4;N;i:5;N;}', NULL),
	(350, 4, 16, 2, 5, '下列变量命名中，非法的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"A**LONG";i:1;s:5:"MyCar";i:2;s:6:"my_car";i:3;s:3:"a48";i:4;N;i:5;N;}', NULL),
	(351, 4, 16, 2, 5, '关于对类的描述中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"类是创建对象的样板";i:1;s:36:"类是具有唯一标识符的实体";i:2;s:34:"类就是C语言中的结构类型";i:3;s:57:"类是具有共同行为的若干对象的统一描述体";i:4;N;i:5;N;}', NULL),
	(352, 4, 16, 2, 5, '不能作为函数重载的判断依据的是（  ）\nA．const', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"返回类型";i:1;s:12:"参数个数";i:2;s:12:"参数类型";i:3;N;i:4;N;i:5;N;}', NULL),
	(353, 4, 16, 2, 5, '已知:“int a=5;char c=\'a\' ;”则输出语句cout<<c+1 <<a<<c;的显示结果是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"65a";i:1;s:4:"985a";i:2;s:6:"98\'5\'a";i:3;s:5:"65\'a\'";i:4;N;i:5;N;}', NULL),
	(354, 4, 16, 2, 5, '下面程序的输出结果是（  ）\n#include. < iostream >\nusing namespacc std ;\nint main( )\n  {inta=1,b= -2,c=3;\nif(a<b)\n  if(b<0)c=0;\nelse C+ =1;\n  cout <<c << endl;\nreturn 0;\n}', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"0";i:1;s:1:"2";i:2;s:1:"3";i:3;s:1:"4";i:4;N;i:5;N;}', NULL),
	(355, 4, 16, 2, 5, 'C++语言的跳转语句中,对于break和continue说法正确的是（  ）\nA．break语句只应用于循环体中', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:" continue语句只应用于循环体中";i:1;s:46:" break是无条件跳转语句, continue不是";i:2;s:65:" break和continue的跳转范围不够明确，容易产生问题";i:3;N;i:4;N;i:5;N;}', NULL),
	(356, 4, 16, 2, 5, '下列函数的说明中,表示纯虚函数的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:20:"virtual int vf( int}";i:1;s:15:"void vf(int) =0";i:2;s:20:"virual void vf( ) =0";i:3;s:23:"virtual void vf( int){}";i:4;N;i:5;N;}', NULL),
	(357, 4, 16, 2, 5, '以下关于运算符重载的描述中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"运算符重载其实就是函数重载";i:1;s:46:"成员运算符比友元运算符少-个参数";i:2;s:29:"需要使用关键字operator";i:3;s:48:"成员运算符比友元运算符多一个参数";i:4;N;i:5;N;}', NULL),
	(358, 4, 16, 2, 5, '对于下面定义的类Myclass ,在函数f( )中将对象成员n的值修改为50的语句应该是（ ）\n  class Myclass\n  { public:\n       Myclass( int i){n=i;}\n       void SetNum( int x){n=x;}\n  private:\n        int n;\n  };\nint f( )\n  {Myclass * p = new Myclass(45) ;\n                                 }', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:17:"p一> SetNum( 50)";i:1;s:10:"SetNum(50)";i:2;s:9:"p一>n=50";i:3;s:17:"*p一> SetNum(50)";i:4;N;i:5;N;}', NULL),
	(359, 4, 16, 2, 5, '下面关于对象概念的插述中错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"任何对象都必须有继承性";i:1;s:36:"对象是属性和方法的封装体";i:2;s:33:"对象间的通信靠消息传递";i:3;s:30:"操作是对象的动态属性";i:4;N;i:5;N;}', NULL),
	(360, 4, 16, 2, 5, '考虑函数原型void pass( int x,int y =5,char z=\' *\'),下面的函数调用中，属于不合法调用的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"pass (5)";i:1;s:10:"pass (5,8)";i:2;s:12:"pass (6,\'#\')";i:3;s:15:"pass (0,0,\' *\')";i:4;N;i:5;N;}', NULL),
	(361, 4, 16, 2, 5, '下列关于虚函数的描述中,正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"使用虚函数就一定产生多态性";i:1;s:73:"虚函数只能是类中的一一个成员函数,但不能是静态成员";i:2;s:46:"一个类中仅可以声明-一个纯虚函数";i:3;s:66:"在构造函数和析构函数中调用虚函数采用动态联编";i:4;N;i:5;N;}', NULL),
	(362, 4, 16, 2, 5, '有以下程序段,其输出结果是（  ）\n  #include < iostream>\n  using namespace std ;\n  void main( )\n  { char b[] =”Hello,you" ;\nb[5]=’!’ ;\n  cout <<b << endl;\n  }\nA Hello, you', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:" Hello";i:1;s:11:" Hello! you";i:2;s:2:" !";i:3;N;i:4;N;i:5;N;}', NULL),
	(363, 4, 16, 4, 5, '一般C++语言源程序文件的后缀是. Cpp；经过编译后，生成文件的后缀是. obj ；经过\n连接后，生成文件的后缀是【】。', '', '', '', '【exe】', 0, '', NULL, 0, 0, NULL, NULL),
	(364, 4, 16, 4, 5, 'C++语言中提供了3种循环语句:【】循环语句、for 循环语句和do_ while 循环语句。', '', '', '', '【while】', 0, '', NULL, 0, 0, NULL, NULL),
	(365, 4, 16, 4, 5, '在“int a=10, *p= &a;”语句中,p的值是  【】    。', '', '', '', '【变量a的地址】', 0, '', NULL, 0, 0, NULL, NULL),
	(366, 4, 16, 4, 5, '执行3条语句“inta,b, *c=&a;int *p=c;p =&b;"后,c指向【】 。', '', '', '', '【a】', 0, '', NULL, 0, 0, NULL, NULL),
	(367, 4, 16, 4, 5, '若有以下定义:double w[9] ;则w数组元素下标的下限是0,上限是【】 。', '', '', '', '【8】', 0, '', NULL, 0, 0, NULL, NULL),
	(368, 4, 16, 4, 5, '设int x[3][4];则x数组中含有【】个int类型的数组元素。', '', '', '', '【12】', 0, '', NULL, 0, 0, NULL, NULL),
	(369, 4, 16, 4, 5, '将数学表达式 ab+〖a^2+b〗^2/2ab 写成C++语言表达式为:【】  。', '', '', '', '【[\'a*b+\', \'a*a+b*b\', \'/\', \'2*a*b\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(370, 4, 16, 4, 5, '模板函数的真正代码是在源程序中  【】    时产生。', '', '', '', '【调用函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(371, 4, 16, 4, 5, '源程序文档化要求程序应加注释，注释-般分为序言性注释和【】   。', '', '', '', '【功能性注释】', 0, '', NULL, 0, 0, NULL, NULL),
	(372, 4, 16, 4, 5, '重载函数必须有不同的  【】   。', '', '', '', '【形参列表】', 0, '', NULL, 0, 0, NULL, NULL),
	(373, 4, 16, 4, 5, '在类中定义和实现的函数可以成为【】，它能够加快程序执行速度。', '', '', '', '【内联函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(374, 4, 16, 4, 5, '在C++中输人输出是通过流来完成的，输出操作是将一个对象的状态转换成一个\n【】序列。', '', '', '', '【字符】', 0, '', NULL, 0, 0, NULL, NULL),
	(375, 4, 16, 4, 5, 'C++语言中，派生类继承了基类的全部数据成员和除构造函数及【】之外的\n全部函数。', '', '', '', '【析构函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(376, 4, 16, 4, 5, '定义以下变量并假设已赋确定的值:“char w;int x;foat y ;double z;”，则表达式“w *x+z-y”的数据类型是【】 。', '', '', '', '【double】', 0, '', NULL, 0, 0, NULL, NULL),
	(377, 4, 16, 4, 5, '若有一个Myclass类,则执行语句”MyClass obj1 ，obj2[2], *p;”后，自动调用该类的构造函数【】       次。', '', '', '', '【3】', 0, '', NULL, 0, 0, NULL, NULL),
	(378, 4, 16, 4, 5, 'this指针保证每个对象拥有自己的数据成员,又共享处理这些数据成员的【】。', '', '', '', '【代码】', 0, '', NULL, 0, 0, NULL, NULL),
	(379, 4, 16, 4, 5, '若有整型变量a=1,b= -2,c=3;则表达式a-b>b? c:a+b的值为【】   。', '', '', '', '【3】', 0, '', NULL, 0, 0, NULL, NULL),
	(380, 4, 16, 4, 5, '所谓“引用”就是将一个新标识符和一块已经存在的【】相关联，通常用于函\n数的参数表中或者作为函数的返回值。', '', '', '', '【存储区域】', 0, '', NULL, 0, 0, NULL, NULL),
	(381, 4, 16, 4, 5, 'C++为结构动态分配内存的一般格式是“指针名=【】  ; ”，当不再使用这个空间时必须用“delete指针名;”释放空间。', '', '', '', '【new结构名】', 0, '', NULL, 0, 0, NULL, NULL),
	(382, 4, 16, 4, 5, 'C++程序中使用string类定义存储字符串的对象时,必须在程序中包含这个类的头文\n件，即使用语句 【】    。', '', '', '', '【#include<string>】', 0, '', NULL, 0, 0, NULL, NULL),
	(383, 4, 17, 2, 5, '按照标识符的要求,不能组成标识符的符号是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"连接符";i:1;s:9:"下划线";i:2;s:15:"大小写字母";i:3;s:12:"数字字符";i:4;N;i:5;N;}', NULL),
	(384, 4, 17, 2, 5, '下列输出语句中,正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"cout<<("%c\\n","student")";i:1;s:22:"cout<<("%s\\n","hello")";i:2;s:17:"cout<<("%c\\n,"n")";i:3;s:17:"cout<<("%s\\n",&a)";i:4;N;i:5;N;}', NULL),
	(385, 4, 17, 2, 5, '已知:pint()函数是一个类的常成员函数,无返回值,下列表示中正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:19:"void print( ) const";i:1;s:18:"void print (const)";i:2;s:19:"void const print( )";i:3;s:19:"const void print( )";i:4;N;i:5;N;}', NULL),
	(386, 4, 17, 2, 5, 'if与else在使用过程中为避免嵌套出现二义性,C++中规定与else子句配对的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:25:"其之前最近的i语句";i:1;s:42:"其之前最近且尚未配对的证语句";i:2;s:30:"缩排位置相同的ⅱ语句";i:3;s:27:"其之后最近的讧语句";i:4;N;i:5;N;}', NULL),
	(387, 4, 17, 2, 5, '对使用关键字new所开辟的动态存储空间,释放时必须使用（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"free";i:1;s:6:"create";i:2;s:6:"delete";i:3;s:7:"release";i:4;N;i:5;N;}', NULL),
	(388, 4, 17, 2, 5, '逻辑运算符两侧运算对象的数据（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"是逻掛型数据";i:1;s:21:"只能是整型数据";i:2;s:33:"只能是整型或字符型数据";i:3;s:30:"可以是任何类型的数据";i:4;N;i:5;N;}', NULL),
	(389, 4, 17, 2, 5, '关于构造函数的说法,不正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:52:"没有定义构造函数时,系统将不会调用它";i:1;s:27:"其名与类名完全相同";i:2;s:45:"它在对象被创建时由系统自动谓用";i:3;s:15:"没有返回值";i:4;N;i:5;N;}', NULL),
	(390, 4, 17, 2, 5, '所谓数据封装就是将一组数据和与这组数据有关標作组装在一起,形成一个实体,这实体也就是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"类";i:1;s:6:"对象";i:2;s:9:"函数体";i:3;s:9:"数据块";i:4;N;i:5;N;}', NULL),
	(391, 4, 17, 2, 5, '下列关于类的维承描述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"基类不一定具有派生类的全部属性和方法";i:1;s:88:"派生类可以访问基类的所有数据成员,也能调用基类的所有成员函数";i:2;s:85:"继承描述类的层次关系,派生类可以具有与基类相同的属性和方法";i:3;s:73:"一个基类可以有多个派生类,一个派生类可以有多个基类";i:4;N;i:5;N;}', NULL),
	(392, 4, 17, 2, 5, '在C++中,函数原型不能标识（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"函数的返回类型";i:1;s:21:"函数参数的个数";i:2;s:18:"函数参数类型";i:3;s:15:"函数的功能";i:4;N;i:5;N;}', NULL),
	(393, 4, 17, 2, 5, '若二维数组y有m列,则位于y[i][j]之前的元素数量是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"j*m+I";i:1;s:5:"i*m+j";i:2;s:7:"i*m+j-1";i:3;s:7:"i&m+j+1";i:4;N;i:5;N;}', NULL),
	(394, 4, 17, 2, 5, '下列关于类的权限的描述错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"类本身的成员函数只能访问自身的私有成员";i:1;s:45:"类的对象只能访问该类的公有成员";i:2;s:73:"普通函数不能直接访问类的公有成员,必须通过对象访问";i:3;s:51:"一个类可以将另一个类的对象作为成员";i:4;N;i:5;N;}', NULL),
	(395, 4, 17, 2, 5, '下面不能够判断字符申S是空串的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"if(S[0]=0)";i:1;s:15:"if(strlen(S)=0)";i:2;s:22:"if(strcmp(S,””)=0)";i:3;s:15:"if(S==’\\0’)";i:4;N;i:5;N;}', NULL),
	(396, 4, 17, 2, 5, '下列输出字符\'d\'的方法中,错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"cout<<put(‘d’)";i:1;s:13:"cout<<‘d’";i:2;s:17:"cout.put(‘d’)";i:3;s:22:"char a=’d’;cout<<a";i:4;N;i:5;N;}', NULL),
	(397, 4, 17, 2, 5, '关于引用,下列的说法中错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"引用是给被引用的变量取一个别名";i:1;s:60:"引用主要是用来作函数的形参和函数的返回值";i:2;s:52:"在声明引引用时,要给它另开辟内存单元";i:3;s:46:"在声明引用时,必须同时使它初始化";i:4;N;i:5;N;}', NULL),
	(398, 4, 17, 2, 5, '下面关于C++字符数组的叙述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"字符数组可以放字符串";i:1;s:48:"字符数组的字符可以整体输入、输出";i:2;s:77:"可以在赋值语句中通过值运算符“=”X对字符数组整体赋值";i:3;s:51:"可以用关系运算符对字符数组比较大小";i:4;N;i:5;N;}', NULL),
	(399, 4, 17, 2, 5, '下列列说法不正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:64:"主函数main中定义的变量在整个文件或程序中有效";i:1;s:49:"不同函数中,可以使用相同名字的变量";i:2;s:27:"形式参数是局部变量";i:3;s:98:"在一个函数内部,可以在复合语句中定义变量,这些变量只在复合语句中有效";i:4;N;i:5;N;}', NULL),
	(400, 4, 17, 2, 5, '非数组指针或引用型变量做实参时,它和对应虚参之间的数据传递方式是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"地址传递";i:1;s:15:"单向值传递";i:2;s:15:"双向值传递";i:3;s:27:"由用户指定传递方式";i:4;N;i:5;N;}', NULL),
	(401, 4, 17, 2, 5, '下面叙述中错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"处理命令都必须以“”开始";i:1;s:70:"在程序中凡是以“#”开始的语句行都是顶处理命令行";i:2;s:63:"C++程序在程序执行过程中对预处理命令进行处理";i:3;s:36:"一行只能写一条预处理命令";i:4;N;i:5;N;}', NULL),
	(402, 4, 17, 2, 5, '下列关于友元函数的描述,正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"友元函数可以存取私有成员、公有成员和保护成员";i:1;s:33:"友元函数不可以是一个类";i:2;s:54:"友元函数的作用之一是实现数据的隐藏性";i:3;s:67:"在类中说明的友元函数,函数的定义不可在类体之外";i:4;N;i:5;N;}', NULL),
	(403, 4, 17, 4, 5, '#include<iostream.h>命令中，include的意义是 【】   。', '', '', '', '【包含头文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(404, 4, 17, 4, 5, 'this指针始终指向调用成员函数的   【】     。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(405, 4, 17, 4, 5, '假定AB为一个类,则执行语句ABa[10];时,系统自动调用该类的构造函数的次数为  【】 。', '', '', '', '【10】', 0, '', NULL, 0, 0, NULL, NULL),
	(406, 4, 17, 4, 5, '一个抽象类的派生类可以实例化的必要条件是实现了所有的 【】  。', '', '', '', '【纯虚函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(407, 4, 17, 4, 5, 'cin的输入流istream的一个对象，处理标准输入对象,  【】   是输出流ostream的一个对象，处理标准输出。', '', '', '', '【cout】', 0, '', NULL, 0, 0, NULL, NULL),
	(408, 4, 17, 4, 5, '定义虚函数所用的关键字是  【】     。', '', '', '', '【virtual】', 0, '', NULL, 0, 0, NULL, NULL),
	(409, 4, 17, 4, 5, '设在成程序中使用如下语句申请了一个对象数组；Point*ptr=new Point[2];当要释放ptr指向的动态数组对象时，所使用的语句是 【】   。', '', '', '', '【delete[ ]ptr】', 0, '', NULL, 0, 0, NULL, NULL),
	(410, 4, 17, 4, 5, '书写程序语句时，适当增加空行和程序注释以增加程序的   【】  。', '', '', '', '【可读性】', 0, '', NULL, 0, 0, NULL, NULL),
	(411, 4, 17, 4, 5, 'C++语言中如果调用函数时,需要改变实参或者返回多个值,应该采取 【】 方式。', '', '', '', '【传地址或引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(412, 4, 17, 4, 5, '如果要把A类成员函数f()且返回值为void声明为类B的友元函数,则应在类B的定义中加人语句   【】  。', '', '', '', '【friend void A::f()】', 0, '', NULL, 0, 0, NULL, NULL),
	(413, 4, 17, 4, 5, 'C++语言的  【】 提供了与要操作的元素类型无关的算法。', '', '', '', '【[\'标准模板库\', \' STL\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(414, 4, 17, 4, 5, '为了在对象生存期结東时释放其指针成员所指向的动态存储空间,通常为该类定义 【】                       。', '', '', '', '【析构函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(415, 4, 17, 4, 5, '在保护派生中,基类权限为public的成员在派生类中为 【】 。', '', '', '', '【[\'保护类型\', \'protect\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(416, 4, 17, 4, 5, '在函数前面用 【】  保留字修饰时,则表示该函数为内联函数。', '', '', '', '【inline】', 0, '', NULL, 0, 0, NULL, NULL),
	(417, 4, 17, 4, 5, '面向对象的四个基本特性是多态性、继承性、封装性、 【】 。', '', '', '', '【抽象】', 0, '', NULL, 0, 0, NULL, NULL),
	(418, 4, 17, 4, 5, '派生类的主要用途是可以定义其基类中 【】  。', '', '', '', '【不具有的成员】', 0, '', NULL, 0, 0, NULL, NULL),
	(419, 4, 17, 4, 5, '若int a=8;int b=(++a)++;则b=    【】   。', '', '', '', '【9】', 0, '', NULL, 0, 0, NULL, NULL),
	(420, 4, 17, 4, 5, '在C++中,利用向量类模板定义一个具有10个int的向量A,其元素均被置为1,实现此操作的语句是  【】   。', '', '', '', '【[\'vector<int>A\', \'10\']】【1)】', 0, '', NULL, 0, 0, NULL, NULL),
	(421, 4, 17, 4, 5, '将指向对象的引用作为函数的形参,形参是对象的引用,实参是 【】  。', '', '', '', '【对象名】', 0, '', NULL, 0, 0, NULL, NULL),
	(422, 4, 17, 4, 5, '重戴的运算符保持其原有的  【】 、优先级和结合性不变。', '', '', '', '【操作数】', 0, '', NULL, 0, 0, NULL, NULL),
	(423, 4, 18, 2, 5, '下列关于C++标识符的命名不合法的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"Pad";i:1;s:6:"name_1";i:2;s:4:"A#bc";i:3;s:4:"_a12";i:4;N;i:5;N;}', NULL),
	(424, 4, 18, 2, 5, '若有以下类型标识符定义:int x=2;char w=’a’;float y=23.45f;double z=45.6789;则表达式w*x+y-z的结果类型是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"float";i:1;s:4:"char";i:2;s:3:"int";i:3;s:6:"double";i:4;N;i:5;N;}', NULL),
	(425, 4, 18, 2, 5, '局部变量可以隐藏全局变量,那么在有同名全局变量和局部变量的情形时,可以用下列哪一项提供对全局变量的访问（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"作用域运算符";i:1;s:15:"指针运算符";i:2;s:15:"提取运算符";i:3;s:15:"插入运算符";i:4;N;i:5;N;}', NULL),
	(426, 4, 18, 2, 5, '下列关于delete运算符的描述中,错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"它必须用于new返回的指针";i:1;s:45:"对一个指针可以使用多次该运算符";i:2;s:24:"它也适用于空指针";i:3;s:64:"指针名前只用一对方括号,不管所删除数组的维数";i:4;N;i:5;N;}', NULL),
	(427, 4, 18, 2, 5, '在C++中,类与类之间的继承关系具有（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"自反性";i:1;s:9:"对称性";i:2;s:9:"传递性";i:3;s:12:"反对称性";i:4;N;i:5;N;}', NULL),
	(428, 4, 18, 2, 5, '对类中声明的变量,下列描述中正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"属于全局变量";i:1;s:64:"属于该类,某些情况下也可被该类不同实例所共享";i:2;s:15:"只属于该类";i:3;s:48:"任何情况下都可被该类所有实例共享";i:4;N;i:5;N;}', NULL),
	(429, 4, 18, 2, 5, '在类定义的外部,可以被访问的成员有（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"所有类成员";i:1;s:31:"private或protected的类成员";i:2;s:18:"public的类成员";i:3;s:28:"public或private的类成员";i:4;N;i:5;N;}', NULL),
	(430, 4, 18, 2, 5, '已知:int m=10;下列表示引用的方法中,正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"int&z";i:1;s:7:"int&t=I";i:2;s:7:"int&x=m";i:3;s:10:"float&f=&m";i:4;N;i:5;N;}', NULL),
	(431, 4, 18, 2, 5, '对于int*pa[5];的描述中,正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:72:"pa是一个指向数组的指针，所指向的数组是5个int型元素";i:1;s:78:"pa是一个指向某数组中第5个元素的指针，该元素是int型变量";i:2;s:57:"pa[5]表示数组的第5个元素的值，是int型的值";i:3;s:78:"pa是一个具有5个元素的指针数组，每个元素是一个int型指针";i:4;N;i:5;N;}', NULL),
	(432, 4, 18, 2, 5, '下列关于构造函数的描述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"构造函数可以设置默认参数";i:1;s:45:"构造函数在定义类对象时自动执行";i:2;s:33:"构造函数可以是内联函数";i:3;s:27:"构造函数不可以重载";i:4;N;i:5;N;}', NULL),
	(433, 4, 18, 2, 5, '关于成员函数特征的描述中,错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"成员函数一定是内联函数";i:1;s:24:"成员函数可以重载";i:2;s:42:"成员函数可以设置参数的默认值";i:3;s:30:"成员函数可以是静态的";i:4;N;i:5;N;}', NULL),
	(434, 4, 18, 2, 5, '下列不是函数重载所要求的条件是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"函数名相同";i:1;s:18:"参数个数不同";i:2;s:18:"参数类型不同";i:3;s:27:"函数返回值类型不同";i:4;N;i:5;N;}', NULL),
	(435, 4, 18, 2, 5, '下列有关模板的描述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:75:"模板把数据类型作为一个设计参数，称为参数化程序设计";i:1;s:80:"使用时,模板参数与函数参数相同,是按位置而不是名称对应的";i:2;s:51:"模板实例化参数类型包括数据类型和值";i:3;s:39:"类模板与模板类是同一个概念";i:4;N;i:5;N;}', NULL),
	(436, 4, 18, 2, 5, '用new运算符创建一维数组的正确形式是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:16:"int*p=new a[10];";i:1;s:23:"float*p=new float [10];";i:2;s:20:"int*p=new float[10];";i:3;s:31:"int*p=new int[5]={1,2,3,4,5,6};";i:4;N;i:5;N;}', NULL),
	(437, 4, 18, 2, 5, '以下关于this指针的叙述中,正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:43:"任何与类相关的函数都有this指针";i:1;s:34:"类的成员函数都有this指针";i:2;s:34:"类的友元函数都有this指针";i:3;s:43:"类的非静态成员函数才有this指针";i:4;N;i:5;N;}', NULL),
	(438, 4, 18, 2, 5, '如果有int x,*P;float y,*q;则下面操作中,正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"p=x";i:1;s:3:"p=q";i:2;s:4:"p=&x";i:3;s:4:"p=&y";i:4;N;i:5;N;}', NULL),
	(439, 4, 18, 2, 5, '下列关于运算符重载的表述中,正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:41:"C+已有的任何运算符都可以重载";i:1;s:128:"运算符函数的返回类型不能声明为基本数据类型\nC在类型转换符函数的定义中不需要声明返回类型";i:2;s:66:"可以通过运算符重载来创建C++中原来没有的运算符";i:3;N;i:4;N;i:5;N;}', NULL),
	(440, 4, 18, 2, 5, '友元运算符@obj被C++编译器解释为（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:"operator(obj)";i:1;s:16:"operator@(obj,0)";i:2;s:15:"obj.operator@()";i:3;s:16:"obj.operator@(0)";i:4;N;i:5;N;}', NULL),
	(441, 4, 18, 2, 5, '考虑函数原型void test(int a,int b=7,char ch=’*’),下面的函数调用中,属于不合法调用的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"test(5)";i:1;s:9:"test(5,8)";i:2;s:15:"test(6,‘#’)";i:3;s:17:"test(0,0,’*’)";i:4;N;i:5;N;}', NULL),
	(442, 4, 18, 2, 5, '使用setw( )时需要包含头文件（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"iostream.h";i:1;s:9:"fstream.h";i:2;s:9:"iomanip.h";i:3;s:8:"stdlib.h";i:4;N;i:5;N;}', NULL),
	(443, 4, 18, 4, 5, '面向对象程序设计不仅能进行功能抽象,而且能进行【】抽象。', '', '', '', '【数据】', 0, '', NULL, 0, 0, NULL, NULL),
	(444, 4, 18, 4, 5, 'C++提供的预处理语句有3种,文件包含、条件编译和【】 。', '', '', '', '【宏定义】', 0, '', NULL, 0, 0, NULL, NULL),
	(445, 4, 18, 4, 5, '在类体外面定义成员函数时,必须用关键字【】 重写类模板声明。', '', '', '', '【template】', 0, '', NULL, 0, 0, NULL, NULL),
	(446, 4, 18, 4, 5, '输入流istream用来处理标准输入的一个对象的是【】  。', '', '', '', '【cin】', 0, '', NULL, 0, 0, NULL, NULL),
	(447, 4, 18, 4, 5, '编译时的多态性通过【】 函数实现。', '', '', '', '【重载】', 0, '', NULL, 0, 0, NULL, NULL),
	(448, 4, 18, 4, 5, '假定x=5,y=6,则表达式x++*++y的值为 【】  。', '', '', '', '【35】', 0, '', NULL, 0, 0, NULL, NULL),
	(449, 4, 18, 4, 5, '在C++程序中,对刚创建的对象进行初始化的工作由构造函数来完成;而对象被删除前的一些清理工作则是由【】 函数来完成的。', '', '', '', '【析构】', 0, '', NULL, 0, 0, NULL, NULL),
	(450, 4, 18, 4, 5, '在用class定义一个类时,数据成员和成员函数的默认访问权限是【】 。', '', '', '', '【[\'private\', \'私有的\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(451, 4, 18, 4, 5, '不同对象可以调用相同名称的函数,但执行完全不同行为的现象称为【】 。', '', '', '', '【多态性】', 0, '', NULL, 0, 0, NULL, NULL),
	(452, 4, 18, 4, 5, '用new申请某一个类的动态对象数组时,在该类中必须能够匹配到没有形参或\n 【】的构造函数,否则应用程序会产生一个编译错误。', '', '', '', '【缺省参数】', 0, '', NULL, 0, 0, NULL, NULL),
	(453, 4, 18, 4, 5, '在C++中,变量的三个基本要素是指:变量名、变量类型和【】  。', '', '', '', '【变量值】', 0, '', NULL, 0, 0, NULL, NULL),
	(454, 4, 18, 4, 5, '若有定义int a=3;则执行完语句a+=a-=a*a;之后,a的值为【】 。', '', '', '', '【-12】', 0, '', NULL, 0, 0, NULL, NULL),
	(455, 4, 18, 4, 5, '如果要把Student类的返回值为void的成员函数score(),声明为类Teacher的友元函数,则应在类Teacher的定义中加入语句【】。', '', '', '', '【fiend void Student::score()】', 0, '', NULL, 0, 0, NULL, NULL),
	(456, 4, 18, 4, 5, '假定x是一个逻辑量,则x&&0的值为【】 。', '', '', '', '【0】', 0, '', NULL, 0, 0, NULL, NULL),
	(457, 4, 18, 4, 5, '构造函数、析构函数和友元函数中,不是该类成员的是【】  。', '', '', '', '【友元函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(458, 4, 18, 4, 5, '使用对象的引用来初始化创建中的对象的函数是【】  。', '', '', '', '【拷贝构造函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(459, 4, 18, 4, 5, '定义类的动态对象数组时,系统只能够自动调用该类的【】构造函数对其进行初始化。', '', '', '', '【无参】', 0, '', NULL, 0, 0, NULL, NULL),
	(460, 4, 18, 4, 5, '复制构造函数使用【】 作为形式参数。', '', '', '', '【对象的引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(461, 4, 18, 4, 5, '当编译系统编译含有虚函数的类时,将为它建立一个虚函数表,表中的每一个元素都指向一个【】 。', '', '', '', '【虚函数的地址】', 0, '', NULL, 0, 0, NULL, NULL),
	(462, 4, 18, 4, 5, '在函数体之前加【】 关键字可以防止覆盖函数改变数据成员的值。', '', '', '', '【const】', 0, '', NULL, 0, 0, NULL, NULL),
	(463, 4, 19, 2, 5, '若有以下类型标识符定义: char c=\'c’; int a=4; float f=3.14; double d=1.212;则表达式    c+a/(int)d+f的结果类型是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"float";i:1;s:4:"char";i:2;s:3:"int";i:3;s:6:"double";i:4;N;i:5;N;}', NULL),
	(464, 4, 19, 2, 5, '设x和y均为bool量,则x&&y为真的条件是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:16:" 它们均为真";i:1;s:19:" 其中一个为真";i:2;s:16:" 它们均为假";i:3;s:19:" 其中一个为假";i:4;N;i:5;N;}', NULL),
	(465, 4, 19, 2, 5, '拷贝构造函数应该是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:28:" 不带参数的构造函数";i:1;s:34:" 带有一个参数的构造函数";i:2;s:34:" 带有两个参数的构造函数";i:3;s:19:" 缺省构造函数";i:4;N;i:5;N;}', NULL),
	(466, 4, 19, 2, 5, '以下说法中正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:55:" C++程序总是从第一个定义的函数开始执行";i:1;s:41:" C++程序总是从main函数开始执行";i:2;s:31:" C++中函数必须有返回值";i:3;s:28:" C++中函数名必须唯一";i:4;N;i:5;N;}', NULL),
	(467, 4, 19, 2, 5, '下列虚基类的声明中,正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:26:" class virtual B: public A";i:1;s:26:" class B: virtual public A";i:2;s:26:" class B: public A virtual";i:3;s:26:" virtual class B: public A";i:4;N;i:5;N;}', NULL),
	(468, 4, 19, 2, 5, '下列哪个类型函数不适合声明为内联函数（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:" 函数体语句较多";i:1;s:22:" 函数体语句较少";i:2;s:25:" 函数执行时间较短";i:3;s:22:" 函数被频繁调用";i:4;N;i:5;N;}', NULL),
	(469, 4, 19, 2, 5, '以下类模板定义正确的为（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:19:" template <class T>";i:1;s:32:" template <class T, class int i>";i:2;s:31:" template <class T, typename T>";i:3;s:24:" template <class T1, T2>";i:4;N;i:5;N;}', NULL),
	(470, 4, 19, 2, 5, 'C++中要实现动态联编,调用虚函数时必须使用（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:" 基类指针";i:1;s:6:"类名";i:2;s:15:"派生类指针";i:3;s:9:"对象名";i:4;N;i:5;N;}', NULL),
	(471, 4, 19, 2, 5, '下列对静态成员的描述中,不正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:50:" 静态成员不属于对象,是类的共享成员";i:1;s:49:" 静态数据成员要在类外定义和初始化";i:2;s:96:" 调用静态成员函数时要通过类或对象激活,所以静态成员函数拥有this指针";i:3;s:55:" 非静态成员函数也可以操作静态数据成员";i:4;N;i:5;N;}', NULL),
	(472, 4, 19, 2, 5, '下列对派生类的描述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"一个派生类可以作为另一个派生类的基类";i:1;s:30:"派生类至少有一个基类";i:2;s:79:"派生类的成员除了它自己的成员外,还包含了它的基类的成员";i:3;s:72:"派生类中继承的基类成员的访问权限到派生类保持不变";i:4;N;i:5;N;}', NULL),
	(473, 4, 19, 2, 5, '下列函数原型声明语句中,错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:14:" int f( void);";i:1;s:12:"void f(int);";i:2;s:9:"int f(a);";i:3;s:18:"void f( double a);";i:4;N;i:5;N;}', NULL),
	(474, 4, 19, 2, 5, '如果有int型变量a,则定义指向变量a的指针p正确的写法是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:" int p= &v";i:1;s:12:" int *p = &v";i:2;s:12:"int &p = * v";i:3;s:10:"int *p = v";i:4;N;i:5;N;}', NULL),
	(475, 4, 19, 2, 5, '假定指针变量p定义为”int *p= new int(100);”,要释放p所指向的动态内存,应使用语句（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:" delete p;";i:1;s:10:"delete * p";i:2;s:10:"delete &p;";i:3;s:10:"delete []p";i:4;N;i:5;N;}', NULL),
	(476, 4, 19, 2, 5, '假定A为一个类,则执行“A a[3], b(3);"语句时调用该类构造函数的次数为（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"3";i:1;s:1:"4";i:2;s:1:"5";i:3;s:1:"9";i:4;N;i:5;N;}', NULL),
	(477, 4, 19, 2, 5, 'C++中定义标准输入输出的库为（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:" stdio";i:1;s:20:" math			  C iostream";i:2;s:7:" stdlib";i:3;N;i:4;N;i:5;N;}', NULL),
	(478, 4, 19, 2, 5, '允许用户为类定义一种模式,使得类中的某些数据成员及某些成员函数的返回值能取任意类型,这是一个（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"类模板";i:1;s:9:"模板类";i:2;s:12:"函数模板";i:3;s:12:"模板函数";i:4;N;i:5;N;}', NULL),
	(479, 4, 19, 2, 5, '下列关于运算符重载的叙述中,正确的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:49:"通过运算符重载,可以定义新的运算符";i:1;s:45:"有的运算符只能作为成员函数重载";i:2;s:54:"若重载运算符+,则相应的运算符函数名是+";i:3;s:55:"重载一个二元运算符时,必须声明两个形参";i:4;N;i:5;N;}', NULL),
	(480, 4, 19, 2, 5, '当使用 ofstream流类定义一个流对象并打开一个磁盘文件时,文件的隐含打开方式为（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:25:" ios:: out I ios:: binary";i:1;s:24:" ios:: in I ios:: binary";i:2;s:10:" ios:: out";i:3;s:9:" ios:: in";i:4;N;i:5;N;}', NULL),
	(481, 4, 19, 2, 5, '有关函数模板和模板函数说法错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:122:"函数模板只是对函数的描述,编译器不为其产生任何执行代码,所以它不是一个实实在在的函数";i:1;s:110:"模板函数是实实在在的函数,它由编译系统在遇到具体函数调用时所生成,并调用执行";i:2;s:57:"函数模板需要实例化为模板函数后才能执行";i:3;s:101:"当函数模板和一般函数同名时,系统先去匹配函数模板,将其实例化后进行调用";i:4;N;i:5;N;}', NULL),
	(482, 4, 19, 2, 5, '对类的构造函数和析构函数描述正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:49:"构造函数可以重载,析构函数不能重载";i:1;s:49:"构造函数不能重载,析构函数可以重载";i:2;s:52:"构造函数可以重载,析构函数也可以重载";i:3;s:52:"构造函数不能重载,析构函数也不能重载";i:4;N;i:5;N;}', NULL),
	(483, 4, 19, 4, 5, '将int类型指针p转换为char类型指针,则强制转换语句为【】 。', '', '', '', '【[\'char *\', \'p\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(484, 4, 19, 4, 5, '当一个成员函数被调用时,该成员函数的【】 指向调用它的对象。', '', '', '', '【this指针】', 0, '', NULL, 0, 0, NULL, NULL),
	(485, 4, 19, 4, 5, '在【】 继承的情况下,基类数据成员在派生类中的访问权限保持不变。', '', '', '', '【公有】', 0, '', NULL, 0, 0, NULL, NULL),
	(486, 4, 19, 4, 5, 'Windows环境下,由C++源程序文件编译而成的目标文件的扩展名是【】 。', '', '', '', '【obj】', 0, '', NULL, 0, 0, NULL, NULL),
	(487, 4, 19, 4, 5, '具有至少一个纯虚函数的类是【】 。', '', '', '', '【抽象类】', 0, '', NULL, 0, 0, NULL, NULL),
	(488, 4, 19, 4, 5, 'C++中字符串是通过字符数组来表示的,每一个字符串都有一个结尾字符【】 。', '', '', '', '【\\0】', 0, '', NULL, 0, 0, NULL, NULL),
	(489, 4, 19, 4, 5, 'C++中定义重载函数时,应至少使重载函数的参数个数或【】 不同。', '', '', '', '【[\'参数\', \'类型\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(490, 4, 19, 4, 5, '假定x=15,则表达式x<=107  20:30的值为【】 。', '', '', '', '【30】', 0, '', NULL, 0, 0, NULL, NULL),
	(491, 4, 19, 4, 5, '假设类F的对象f是类A的成员对象,则“A a”语句执行时,先调用类【】 的构造函数。', '', '', '', '【F】', 0, '', NULL, 0, 0, NULL, NULL),
	(492, 4, 19, 4, 5, '设”int a=3,b=4,c=5;”,表达式“(a+b)>c&&b==c”的值是【】 。', '', '', '', '【0】', 0, '', NULL, 0, 0, NULL, NULL),
	(493, 4, 19, 4, 5, '描述命题”A小于B或小于C”的表达式为【】 。', '', '', '', '【[\'A<B\', \'A<C\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(494, 4, 19, 4, 5, 'C++中字符串"a+b=12\\n\\t"的长度为【】 。', '', '', '', '【8】', 0, '', NULL, 0, 0, NULL, NULL),
	(495, 4, 19, 4, 5, 'C++类中构造函数的个数最多是无限个,析构函数的个数最多是【】 个。', '', '', '', '【1】', 0, '', NULL, 0, 0, NULL, NULL),
	(496, 4, 19, 4, 5, 'C++的静态数据成员需要在【】 进行初始化,可以被该类的所有对象共享。', '', '', '', '【类外】', 0, '', NULL, 0, 0, NULL, NULL),
	(497, 4, 19, 4, 5, 'C++中一般的程序都要有两条语句,包含头文件“# include< iostream>”语句和使用命名空间”【】 ”语句。', '', '', '', '【using namespace std】', 0, '', NULL, 0, 0, NULL, NULL),
	(498, 4, 19, 4, 5, '用new申请某一个类的动态对象数组时,在该类中必须能够匹配到没有形参的或缺省参数的【】 ,否则应用程序会产生一个编译错误。', '', '', '', '【构造函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(499, 4, 19, 4, 5, 'C++中解决命名冲突的机制是【】 。', '', '', '', '【函数重载】', 0, '', NULL, 0, 0, NULL, NULL),
	(500, 4, 19, 4, 5, '拷贝构造函数使用【】 作为参数初始化创建中的对象。', '', '', '', '【引用】', 0, '', NULL, 0, 0, NULL, NULL),
	(501, 4, 19, 4, 5, '假如一个类的名称为F,使用这个类的一个对象初始化该类的另一个对象时,可以调用【】 构造函数来完成此功能。', '', '', '', '【[\'拷贝\', \'复制\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(502, 4, 20, 2, 5, 'C++语言与C语言相比，在求解问题方法上进行的最大改进是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"面向过程";i:1;s:12:"面向对象";i:2;s:9:"安全性";i:3;s:9:"复用性";i:4;N;i:5;N;}', NULL),
	(503, 4, 20, 2, 5, '已知类A中一个成员函数说明" void Set( A&a)；"，其中A&a的含义是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:23:"指向类A的指针为a";i:1;s:31:"将a的地址值赋给变量Set";i:2;s:55:" a是类A的对象引用,用来作函数Set( )的形参";i:3;s:50:"变量A与a按位相与作为函数Set( )的参数";i:4;N;i:5;N;}', NULL),
	(504, 4, 20, 2, 5, '下列关于对象数组的描述中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:37:"对象数组的下标是从0开始的";i:1;s:45:"对象数组的数组名是一个常量指针";i:2;s:51:"对象数组的每个元素是同一个类的对象";i:3;s:45:"对象数组只能赋初值，不能被赋值";i:4;N;i:5;N;}', NULL),
	(505, 4, 20, 2, 5, '定义了指向常量的指针p的选项是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:" const int * p;";i:1;s:7:"int *p;";i:2;s:18:" int* const p= &x;";i:3;s:24:" const int* const p= &x;";i:4;N;i:5;N;}', NULL),
	(506, 4, 20, 2, 5, '下列关于析构函数特征的描述中，正确的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"一个类中能定义一个析构函数";i:1;s:30:"析构函数名与类名不同";i:2;s:39:"析构函数的定义只能在类体内";i:3;s:42:"析构函数可以有一个或多个参数";i:4;N;i:5;N;}', NULL),
	(507, 4, 20, 2, 5, '通常的拷贝初始化构造的参数是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"某个对象名";i:1;s:24:"某个对象的成员名";i:2;s:24:"某个对象的引用名";i:3;s:24:"某个对象的指针名";i:4;N;i:5;N;}', NULL),
	(508, 4, 20, 2, 5, '关于成员函数特征的描述中，错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"成员函数一定是内联函数";i:1;s:24:"成员函数可以重载";i:2;s:42:"成员函数可以设置参数的缺省值";i:3;s:30:"成员函数可以是静态的";i:4;N;i:5;N;}', NULL),
	(509, 4, 20, 2, 5, '下列关于静态数据成员的特性叙述中.错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:62:"说明静态数据成员时，使用关键字satic进行修饰";i:1;s:45:"静态数据成员要在类外进行初始化";i:2;s:92:"引用静态数据成员时，要在静态数据成员名前加<类名>和作用域运算符";i:3;s:48:"静态数据成员是所有对象的共享成员";i:4;N;i:5;N;}', NULL),
	(510, 4, 20, 2, 5, '下列关于类和对象的叙述中,错误的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"一个类只能有一个对象";i:1;s:27:"对象是类的具体实例";i:2;s:30:"类是某一类对象的抽象";i:3;s:60:"类和对象的关系是一种数据类型与变量的关系";i:4;N;i:5;N;}', NULL),
	(511, 4, 20, 2, 5, '决定C++中函数的返回值类型的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"return语句中的表达式类型";i:1;s:45:"调用该函数时系统随机产生的类型";i:2;s:42:"调用该函数时的主调用函数类型";i:3;s:36:"在定义函数时所指定的类型";i:4;N;i:5;N;}', NULL),
	(512, 4, 20, 2, 5, '通过下列哪一选项调用虚函数，会采用动态联编（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"对象指针";i:1;s:9:"对象名";i:2;s:15:"成员名限定";i:3;s:12:"派生类名";i:4;N;i:5;N;}', NULL),
	(513, 4, 20, 2, 5, '假设ClassY :publicX,即类Y是类X的派生类,则说明一个Y类的对象时和删除Y类对象时，调用构造函数和析构函数的次序分别为 （  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"X,Y;Y,X";i:1;s:7:"X,Y;X,Y";i:2;s:7:"Y,X;X,Y";i:3;s:7:"Y,X;Y,X";i:4;N;i:5;N;}', NULL),
	(514, 4, 20, 2, 5, '若有"int m=5;"，则下列表示引用的方法中，正确的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:" int &Z;";i:1;s:9:"int &t=5;";i:2;s:8:"int&X=m;";i:3;s:14:"float &f = &m;";i:4;N;i:5;N;}', NULL),
	(515, 4, 20, 2, 5, '以下基类中的成员函数表示纯虚函数的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:" virtual void tt( )=0;";i:1;s:17:" void tt(int) =0;";i:2;s:23:" virtual void tt( int);";i:3;s:24:" virtual void t( int){ }";i:4;N;i:5;N;}', NULL),
	(516, 4, 20, 2, 5, '下列关于类的析构函数的描述中，正确的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"能带形式参数";i:1;s:34:" 函数体中必须有delete语句";i:2;s:15:"可以被重载";i:3;s:25:"无形参,也不可重载";i:4;N;i:5;N;}', NULL),
	(517, 4, 20, 2, 5, '作用域运算符"：：”的功能是:（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"标识作用域的级别";i:1;s:24:"指出作用域的范围";i:2;s:24:"给定作用域的大小";i:3;s:30:"标识成员是属于哪个类";i:4;N;i:5;N;}', NULL),
	(518, 4, 20, 2, 5, '要求打开文件”d: \\file. dat" ,可写入数据,正确的语句是:（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:44:" ifstream  infile("d: \\file. dat", ios::in);";i:1;s:45:" ifstream  infile("d: \\\\file,dat" , ios::in);";i:2;s:49:" ofstream  infile( "d: \\file. dat" , ios: :out) ;";i:3;s:55:" fstream 0 infile("d:\\\\file. dat"，ios::inlios: :out);";i:4;N;i:5;N;}', NULL),
	(519, 4, 20, 2, 5, '考虑函数原型int funl(floatx, chary=" $" ,int a=9, char b="@"),下面的函数调用中,属于不合法调用的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:" fun1(3. 14)";i:1;s:17:" fun1(3.14,“#")";i:2;s:20:" fun1(3.14,"S", "@")";i:3;s:27:" fun1(3.14,”#”,7,“@")";i:4;N;i:5;N;}', NULL),
	(520, 4, 20, 2, 5, '下面关于友元的描述中,错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"友元函数可以直接访问该类的私有成员";i:1;s:75:"一个类的友元类中的所有成员函数都是这个类的友元函数";i:2;s:70:"利用友元可以提高程序的运行效率,但却破坏了封装性";i:3;s:51:"友元关系不能被继承，是双向可交换的";i:4;N;i:5;N;}', NULL),
	(521, 4, 20, 4, 5, '在一个C++程序文件中，若要包含另外一个头文件或程序文件，则应使用以【】标识符开始的预处理命令。', '', '', '', '【#include】', 0, '', NULL, 0, 0, NULL, NULL),
	(522, 4, 20, 4, 5, 'C++语言中的每条基本语句以 【】作为结束符。', '', '', '', '【[\';\', \'或分号\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(523, 4, 20, 4, 5, '已知′A ′～′Z′的ASCII码为65～90,当执行”char ch=14*5+2;cout<< ch<<endl;"语句序列后，得到的输出结果为【】 。', '', '', '', '【H】', 0, '', NULL, 0, 0, NULL, NULL),
	(524, 4, 20, 4, 5, '表达式float(39)/4的值为 【】。', '', '', '', '【9.75】', 0, '', NULL, 0, 0, NULL, NULL),
	(525, 4, 20, 4, 5, '假定不允许使用逻辑非操作符,则关系表达式x+y>5的相反表达式为【】。', '', '', '', '【x+y<=5】', 0, '', NULL, 0, 0, NULL, NULL),
	(526, 4, 20, 4, 5, '一个双目运算符作为类的成员函数重载时有【】个参数。', '', '', '', '【1】', 0, '', NULL, 0, 0, NULL, NULL),
	(527, 4, 20, 4, 5, '如果一个派生类只有一个唯一的基类,则称这样的继承关系为【】。', '', '', '', '【单继承】', 0, '', NULL, 0, 0, NULL, NULL),
	(528, 4, 20, 4, 5, '假定要动态分配一个类型为Worker的具有n个元素的数组,并由r指向这个动态数组,则使用的语句表达式为Worker*r=【】。', '', '', '', '【new Woker[n]】', 0, '', NULL, 0, 0, NULL, NULL),
	(529, 4, 20, 4, 5, '所谓【】成员是指只有类中所提供的成员函数才能直接使用它们,任何类以外的函数对它们的访问都是非法的。', '', '', '', '【私有】', 0, '', NULL, 0, 0, NULL, NULL),
	(530, 4, 20, 4, 5, '类和对象之间的关系是抽象和具体的关系，类是对多个对象进行综合抽象的结果,对\n象是类的【】 。', '', '', '', '【实例】', 0, '', NULL, 0, 0, NULL, NULL),
	(531, 4, 20, 4, 5, '面向对象程序设计将表示属性特征的数据和对数据进行操作的【】封装在一起,构成一个完整的对象。', '', '', '', '【方法】', 0, '', NULL, 0, 0, NULL, NULL),
	(532, 4, 20, 4, 5, '对象成员是指该对象所属类中定义的成员,包括数据成员和【】。', '', '', '', '【成员函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(533, 4, 20, 4, 5, '构造函数是类中特殊的成员函数，其功能是在【】时使用给定的值来初始化对象。', '', '', '', '【创建对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(534, 4, 20, 4, 5, '函数模板中紧随template之后尖括号内的类型参数都要冠以保留字【】。', '', '', '', '【class】', 0, '', NULL, 0, 0, NULL, NULL),
	(535, 4, 20, 4, 5, '与结构成员访问表达式(*fp).score等价的表达式是【】。', '', '', '', '【fp->score】', 0, '', NULL, 0, 0, NULL, NULL),
	(536, 4, 20, 4, 5, '假定类AB中有一个公用属性的静态数据成员bb,在类外不通过对象名访问该成员bb的写法为【】 。', '', '', '', '【AB::bb】', 0, '', NULL, 0, 0, NULL, NULL),
	(537, 4, 20, 4, 5, 'OOA中使用【】映射问题域中的事物。', '', '', '', '【对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(538, 4, 20, 4, 5, '定义重载函数,应该在参数类型或【】上有所不同。', '', '', '', '【[\'参数的\', \'个数\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(539, 4, 20, 4, 5, '静态成员函数、友元函数、构造函数和析构函数中,不属于成员函数的是【】 。', '', '', '', '【友元函数】', 0, '', NULL, 0, 0, NULL, NULL),
	(540, 4, 20, 4, 5, '在面向对象的程序设计中,将组对象的共同特性抽象出来形成【】。', '', '', '', '【类】', 0, '', NULL, 0, 0, NULL, NULL),
	(541, 4, 21, 2, 5, '【2019年4月真题】有一种操作系统允许在一台主机上同时连接多台终端，多个用户可以通过各自的终端同时交互地使用计算机，满足这一特征的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"单道批处理操作系统";i:1;s:21:"分布式操作系统";i:2;s:12:"分时系统";i:3;s:12:"实时系统";i:4;N;i:5;N;}', NULL),
	(542, 4, 21, 2, 5, '【2019年4月真题】引入多道程序系统的主要目的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"为了充分利用主存储器";i:1;s:42:"充分利用CPU，减少CPU的等待时间";i:2;s:24:"提高实时响应速度";i:3;s:27:"增强系统的交互能力";i:4;N;i:5;N;}', NULL),
	(543, 4, 21, 2, 5, '【2019年4月真题】操作系统内核与应用程序之间的接口是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"联机用户接口";i:1;s:18:"脱机用户接口";i:2;s:12:"系统调用";i:3;s:18:"图形用户接口";i:4;N;i:5;N;}', NULL),
	(544, 4, 21, 2, 5, '【2018年10月真题】以下不属于操作系统主要功能的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"管理计算机硬件和软件资源";i:1;s:60:"提供计算机应用程序与计算机硬件之间的接口";i:2;s:36:"为应用程序的运行提供环境";i:3;s:33:"高级程序设计语言的编译";i:4;N;i:5;N;}', NULL),
	(545, 4, 21, 2, 5, '【2018年10月真题】以下不属于分时系统基本特征的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"多路性";i:1;s:9:"独立性";i:2;s:9:"原子性";i:3;s:9:"交互性";i:4;N;i:5;N;}', NULL),
	(546, 4, 21, 2, 5, '【2018年10月真题】现代操作系统具有并发的特征，主要是由于引入了（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"通道技术";i:1;s:12:"中断机制";i:2;s:15:" SPOOLing技术";i:3;s:18:"多道程序系统";i:4;N;i:5;N;}', NULL),
	(547, 4, 21, 2, 5, '【2018年4月真题】关于操作系统，以下叙述中正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"批处理系统主要缺点是缺乏交互能力";i:1;s:48:"分时系统不一定都具有人机交互功能";i:2;s:75:"从响应时的角度来看，实时系统与分时系统的要求差不多";i:3;s:54:"采用多道批处理系统也具有人机交互功能";i:4;N;i:5;N;}', NULL),
	(548, 4, 21, 2, 5, '【2018年4月真题】实时操作系统追求的目标是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"高吞吐率";i:1;s:15:"资源利用率";i:2;s:12:"快速响应";i:3;s:18:"减少系统开销";i:4;N;i:5;N;}', NULL),
	(549, 4, 21, 2, 5, '【2018年4月真题】操作系统的异步性是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"程序的运行结果不确定";i:1;s:30:"程序的运行次序不确定";i:2;s:36:"程序多次运行的时间不确定";i:3;s:75:"程序的运行结果、运行次序以及多次运行的时间都不确定";i:4;N;i:5;N;}', NULL),
	(550, 4, 21, 2, 5, '从资源管理的角度看，操作系统的功能是(..)。..', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"运算器管理.内存管理.文件管理.设备管理";i:1;s:54:"内存管理.文件管理.设备管理.处理器管理";i:2;s:57:"文件管理.设备管理.处理器管理.运算器管理";i:3;s:57:"设备管理.处理器管理.运算器管理.内存管理";i:4;N;i:5;N;}', NULL),
	(551, 4, 21, 2, 5, '下列关于操作系统基本类型的叙述中，正确的是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"批处理系统中用户不能直接干预作业的执行";i:1;s:48:"分时系统不一定都具有人机交互功能";i:2;s:75:"从响应时间的角度看，实时系统与分时系统的要求差不多";i:3;s:63:"由于采用了分时技术，用户可以独占计算机资源";i:4;N;i:5;N;}', NULL),
	(552, 4, 21, 2, 5, '计算机系统中用于存放当前参加运算的操作数的寄存器是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"指令寄存器";i:1;s:15:"通用寄存器";i:2;s:15:"控制寄存器";i:3;s:24:"程序状态字寄存器";i:4;N;i:5;N;}', NULL),
	(553, 4, 21, 2, 5, '计算机操作系统的功能是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"实现计算机用户之间的相互交互";i:1;s:69:"管理计算机系统的资源和提供用户和硬件之间的接口";i:2;s:39:"把源程序代码转换成目标代码";i:3;s:45:"完成计算机硬件与软件之间的通信";i:4;N;i:5;N;}', NULL),
	(554, 4, 21, 2, 5, '在批处理系统中引入多道程序设计技术的目的是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"提高CPU和其他设备的利用率";i:1;s:24:"提高系统的可靠性";i:2;s:24:"提高实时响应速度";i:3;s:24:"增强系统交互能力";i:4;N;i:5;N;}', NULL),
	(555, 4, 21, 2, 5, '现代操作系统的内核结构采用', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"P2P模型";i:1;s:18:"中心驱动模型";i:2;s:22:"客户/服务器模型";i:3;s:15:"无人机模型";i:4;N;i:5;N;}', NULL),
	(556, 4, 21, 2, 5, '操作系统的资管共享方式有（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"互斥共享";i:1;s:12:"同时共享";i:2;s:12:"同步共享";i:3;s:27:"互斥共享和同时共享";i:4;N;i:5;N;}', NULL),
	(557, 4, 21, 2, 5, '在CPU寄存器中，用于存放指令地址的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"指令寄存器";i:1;s:9:"累加器";i:2;s:15:"中断向量表";i:3;s:15:"程序计数器";i:4;N;i:5;N;}', NULL),
	(558, 4, 21, 4, 5, '【2019年4月真题】操作系统常见的体系结构有单体结构模型、【】、【】和动态可扩展结构模型。', '', '', '', '【层次结构模型】【微内核结构模型】', 0, '', NULL, 0, 0, NULL, NULL),
	(559, 4, 21, 4, 5, '【2018年10月真题】CPU中的【】存放当前程序下一条要执行的指令在内存中的地址，CPU从该地址取到指令，并将该指令放入CPU的_【】 中。', '', '', '', '【[\'程序计数器\', \'或PC\']】【[\'指令寄存器\', \'或IR\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(560, 4, 21, 4, 5, '【2018年4月真题】分时系统的四个特征是：多路性、【】、【】和交互性。', '', '', '', '【独立性】【及时性】', 0, '', NULL, 0, 0, NULL, NULL),
	(561, 4, 21, 4, 5, '操作系统提供的用户接口包括【】.【】.以及图形用户接口。', '', '', '', '【命令接口】【程序接口】', 0, '', NULL, 0, 0, NULL, NULL),
	(562, 4, 21, 4, 5, '操作系统的四项基本特征是：并发.共享.【】和【】。', '', '', '', '【虚拟】【异步】', 0, '', NULL, 0, 0, NULL, NULL),
	(563, 4, 21, 4, 5, '操作系统的主要功能包括：处理机管理.存储器管理.文件管理.【】和【】。', '', '', '', '【设备管理】【提供用户接口】', 0, '', NULL, 0, 0, NULL, NULL),
	(564, 4, 22, 2, 5, '【2019年4月真题】下列不是操作系统内核基本功能的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"文件管理";i:1;s:12:"时钟管理";i:2;s:12:"原语操作";i:3;s:12:"中断处理";i:4;N;i:5;N;}', NULL),
	(565, 4, 22, 2, 5, '【2019年4月真题】如果有N（N>2）个进程并发运行，则不可能出现的情形是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:79:"1个进程处于执行态，没有就绪态的进程，N-1个阻塞态的进程";i:1;s:79:"1个进程处于执行态，N-1个就绪态的进程，没有阻塞态的进程";i:2;s:77:"1个进程处于执行态，1个就绪态的进程，N-2个阻塞态的进程";i:3;s:79:"没有进程处于执行态，2个就绪态的进程，N-2个阻塞态的进程";i:4;N;i:5;N;}', NULL),
	(566, 4, 22, 2, 5, '【2018年10月真题】进程所请求的一次打印输出完成后，进程的状态会从（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"阻塞态变为就绪态";i:1;s:24:"执行态变为阻塞态";i:2;s:24:"就绪态变为执行态";i:3;s:24:"执行态变为就绪态";i:4;N;i:5;N;}', NULL),
	(567, 4, 22, 2, 5, '【2018年10月真题】临界区是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"一段共享数据区";i:1;s:15:"一个缓冲区";i:2;s:12:"一段程序";i:3;s:18:"一个同步机制";i:4;N;i:5;N;}', NULL),
	(568, 4, 22, 2, 5, '【2018年4月真题】进程从执行状态进入就绪状态的原因可能是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"被选中占有处理机";i:1;s:18:"等待某一事件";i:2;s:24:"等待的事件已发生";i:3;s:15:"时间片用完";i:4;N;i:5;N;}', NULL),
	(569, 4, 22, 2, 5, '【2018年4月真题】在操作系统中，要对甲、乙两个并发进程进行同步的原因是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"甲、乙两进程必须在有限的时间内完成";i:1;s:21:"进程具有动态性";i:2;s:45:"甲、乙两个进程需要访问临界资源";i:3;s:21:"进程具有结构性";i:4;N;i:5;N;}', NULL),
	(570, 4, 22, 2, 5, '当中央处理器在目态工作时，如果收到一条特权指令，此时中央处理器将（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"维持在目态";i:1;s:24:"从目态转换到管态";i:2;s:21:"拒绝执行该指令";i:3;s:21:"继续执行该指令";i:4;N;i:5;N;}', NULL),
	(571, 4, 22, 2, 5, '下列关于采用线程技术的操作系统的叙述中，正确的是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"每个进程都有自己的主存空间";i:1;s:39:"每个线程都有自己的主存空间";i:2;s:57:"同一进程的各线程不能共享进程的主存空间";i:3;s:66:"进程中的线程对进程的整个主存空间只有只读权限";i:4;N;i:5;N;}', NULL),
	(572, 4, 22, 2, 5, '进程控制块的四类信息中，进程的优先级属于（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"标识信息";i:1;s:12:"状态信息";i:2;s:12:"调度信息";i:3;s:12:"控制信息";i:4;N;i:5;N;}', NULL),
	(573, 4, 22, 2, 5, '一个被创建的进程的初始状态应该是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"就绪态";i:1;s:9:"运行态";i:2;s:9:"终止态";i:3;s:9:"阻塞态";i:4;N;i:5;N;}', NULL),
	(574, 4, 22, 2, 5, '进程的状态从阻塞态转为就绪态，可能的原因有（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"进程等待的资源得到满足";i:1;s:33:"进程的资源申请被拒绝了";i:2;s:27:"进程的时间片用完了";i:3;s:39:"有更高优先级的进程需要运行";i:4;N;i:5;N;}', NULL),
	(575, 4, 22, 2, 5, '用户要求分配一台外围设备，此时发出的中断属于（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"程序中断";i:1;s:12:"访管中断";i:2;s:9:"I/O中断";i:3;s:12:"硬件中断";i:4;N;i:5;N;}', NULL),
	(576, 4, 22, 2, 5, '下列步骤中，不是创建进程所必须的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"建立一个进程控制块";i:1;s:21:"为进程分配内存";i:2;s:27:"将进程置为就绪状态";i:3;s:18:"为进程分配CPU";i:4;N;i:5;N;}', NULL),
	(577, 4, 22, 2, 5, '任何两个并发进程之间（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"可能存在交互";i:1;s:18:"一定相互独立";i:2;s:18:"一定存在交互";i:3;s:18:"都有变量共享";i:4;N;i:5;N;}', NULL),
	(578, 4, 22, 2, 5, '在对记录型信号量S执行signal操作之后（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"当S<0时要唤醒一个阻塞进程";i:1;s:36:"当S<0时要唤醒一个就绪进程";i:2;s:38:"当S≤0时要唤醒一个阻塞进程";i:3;s:38:"当S≤0时要唤醒一个就绪进程";i:4;N;i:5;N;}', NULL),
	(579, 4, 22, 2, 5, '采用记录型信号量管理临界区，若信号量的值在［-2，1］之间，则竞争临界区的进程个数最多为（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"4个";i:1;s:4:"3个";i:2;s:4:"2个";i:3;s:4:"1个";i:4;N;i:5;N;}', NULL),
	(580, 4, 22, 2, 5, '操作系统中引入进程后可以（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"保证程序的正确性";i:1;s:24:"提高资源的利用率";i:2;s:18:"减少调度次数";i:3;s:30:"缩短处理器的工作时间";i:4;N;i:5;N;}', NULL),
	(581, 4, 22, 4, 5, '【2019年4月真题】程序并发执行时具有间断性、【】 和 【】 三个特征。', '', '', '', '【失去封闭性】【不可再现性】', 0, '', NULL, 0, 0, NULL, NULL),
	(582, 4, 22, 4, 5, '【2019年4月真题】对一个记录型信号量S，每执行一次wait （S）操作，S.value 减1。若S.value为0，则该进程【】 ；若S的数值小于0，则该进程【】 。', '', '', '', '【继续执行】【被阻塞】', 0, '', NULL, 0, 0, NULL, NULL),
	(583, 4, 22, 4, 5, '【2018年10月真题】进程是程序的一次执行，具有并发性、【】、独立性、【】_、和结构特征。', '', '', '', '【动态性】【异步性】', 0, '', NULL, 0, 0, NULL, NULL),
	(584, 4, 22, 4, 5, '【2018年10月真题】在支持线程的操作系统中，【】是被系统独立调度和分派的基本单位，而【】则是资源分配的基本单位。', '', '', '', '【线程】【进程】', 0, '', NULL, 0, 0, NULL, NULL),
	(585, 4, 22, 4, 5, '【2018年4月真题】进程是真实存在的实体，应用程序对应的进程由该程序、【】和管理进程所需要的【】构成。', '', '', '', '【数据】【[\'进程控制块\', \'或PCB\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(586, 4, 22, 4, 5, '【2018年4月真题】设某一临界区对应的记录型信号最mutex，其初值为1 （即mutex.value=l）,当mutex.value=-2时，表示有【】个进程在临界区内，有【】个进程等待进入临界区。', '', '', '', '【1】【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(587, 4, 22, 4, 5, '在一个单CPU的系统中，处于运行状态的进程最多有【】个。', '', '', '', '【1】', 0, '', NULL, 0, 0, NULL, NULL),
	(588, 4, 22, 4, 5, '在一个进程的工作没有全部完成之前，另一个进程就可以开始工作。这种同时执行进程的现象称为【】', '', '', '', '【并发】', 0, '', NULL, 0, 0, NULL, NULL),
	(589, 4, 22, 4, 5, '每执行一次wait操作，信号量S的数值减1，当满足【】时，说明已无资源可供分配，则执行wait操作的进程必须阻塞等待资源。', '', '', '', '【s<0】', 0, '', NULL, 0, 0, NULL, NULL),
	(590, 4, 22, 4, 5, '有3个进程共享同一段程序，每次最多允许2个进程同时进入该程序段，若用记录型信号量s作为同步机制，则信号量s的取值范围是【】。', '', '', '', '【2】【1】【0】【-1】', 0, '', NULL, 0, 0, NULL, NULL),
	(591, 4, 22, 4, 5, '同步机制应遵循的四个原则：【】.忙则等待.【】让权等待。', '', '', '', '【空闲让进】【有限等待】', 0, '', NULL, 0, 0, NULL, NULL),
	(592, 4, 22, 4, 5, '进程是有【】.【】及进程控制块共同组成的执行环境。', '', '', '', '【正文段】【用户数据段】', 0, '', NULL, 0, 0, NULL, NULL),
	(593, 4, 22, 4, 5, '【】是操作系统感知进程存在的唯一标志。', '', '', '', '【进程控制块】', 0, '', NULL, 0, 0, NULL, NULL),
	(594, 4, 22, 4, 5, '在进程控制块中，处理机状态信息（如条件码.执行方式等）是存放在【】。', '', '', '', '【程序状态字PSW】', 0, '', NULL, 0, 0, NULL, NULL),
	(595, 4, 22, 4, 5, '在信号量机制中，【】信号量要求资源要么全部分配，要么一个都不分配。', '', '', '', '【AND型】', 0, '', NULL, 0, 0, NULL, NULL),
	(596, 4, 22, 4, 5, '进程状态由【】态变为【】态的过程称为唤醒过程', '', '', '', '【阻塞】【就绪】', 0, '', NULL, 0, 0, NULL, NULL),
	(597, 4, 22, 4, 5, '在进程同步中，必须以互斥方式访问的共享资源称为【】。', '', '', '', '【临界资源】', 0, '', NULL, 0, 0, NULL, NULL),
	(598, 4, 23, 2, 5, '【2019年4月真题】在死锁的预防中，资源的按序分配策略可以破坏（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"互斥使用资源条件";i:1;s:27:"占有且等待资源条件";i:2;s:21:"非抢夺资源条件";i:3;s:24:"循环等待资源条件";i:4;N;i:5;N;}', NULL),
	(599, 4, 23, 2, 5, '【2019年4月真题】在下列进程调度算法中，为每个就绪队列赋予不同时间片的调度算法是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"短进程优先调度";i:1;s:21:"时间片轮转调度";i:2;s:15:"优先权调度";i:3;s:24:"多级反锁队列调度";i:4;N;i:5;N;}', NULL),
	(600, 4, 23, 2, 5, '【2019年4月真题】实时系统中，进程调度需婴考虑的关键因素是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"内存的分配";i:1;s:18:"时间片的确定";i:2;s:36:"对完成截止时间条件的满足";i:3;s:19:" I/O设备的分配";i:4;N;i:5;N;}', NULL),
	(601, 4, 23, 2, 5, '【2019年4月真题】若某系统中有3个并发进程，各需要4个同类资源，则该系统不会产生死锁的最少资源总数应该是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"9个";i:1;s:5:"10个";i:2;s:5:"11个";i:3;s:6:" 12个";i:4;N;i:5;N;}', NULL),
	(602, 4, 23, 2, 5, '【2019年4月真题】在操作系统进程调度中，时间片轮转调度算法的目的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"多个终端都能得到系统的及时响应";i:1;s:15:"先来先服务";i:2;s:33:"优先级高的进程先使用CPU";i:3;s:24:"紧急事件优先处理";i:4;N;i:5;N;}', NULL),
	(603, 4, 23, 2, 5, '【2018年10月真题】系统要求所有进程执行前一次性地申请在整个运行过程中所需要的全部资源，这样可以预防死锁发生的条件是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"互斥条件";i:1;s:21:"请求和保持条件";i:2;s:15:"不剥夺条件";i:3;s:12:"环路等待";i:4;N;i:5;N;}', NULL),
	(604, 4, 23, 2, 5, '【2018年10月真题】在优先权调度算法中， 能够解决低优先权进程无穷等待问题的技术是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"老化技术";i:1;s:12:"饥饿技术";i:2;s:12:"调度技术";i:3;s:12:"抢占技术";i:4;N;i:5;N;}', NULL),
	(605, 4, 23, 2, 5, '【2018年10月真题】以下可以用来避免死锁的算法是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"银行家算法";i:1;s:16:" SPF调度算法";i:2;s:11:" SSCF算法";i:3;s:18:"死锁检测算法";i:4;N;i:5;N;}', NULL),
	(606, 4, 23, 2, 5, '【2018年10月真题】在实时系统的调度中，为了保证对截止时间要求较高的实时进程能及时运行，以下说法中不正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"要求系统具有快速的硬件中断机制";i:1;s:45:"应使禁止中断的时间间隔尽可能短";i:2;s:36:"应减少进程切换的时间开销";i:3;s:30:"应使得时间片尽可能短";i:4;N;i:5;N;}', NULL),
	(607, 4, 23, 2, 5, '【2018年10月真题】以下对短进程优先调度算法的说法中，正确的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:37:"相比FCFS而言，对短进程不利";i:1;s:61:"相比FCFS而言，长进程可能会长时间得不到调度";i:2;s:55:"相比FCFS而言，紧迫进程更能得到及时处理";i:3;s:46:"相比FCFS而言，降低了系统的吞吐量";i:4;N;i:5;N;}', NULL),
	(608, 4, 23, 2, 5, '【2018年4月真题】关于系统安全状态的说法，不正确的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"系统处于不安全状态可能发生死锁";i:1;s:48:"系统处于不安全状态一定会发生死锁";i:2;s:45:"不安全状态是死锁状态的一个特例";i:3;s:48:"系统处于安全状态时也可能发生死锁";i:4;N;i:5;N;}', NULL),
	(609, 4, 23, 2, 5, '【2018年4月真题】设某作业在外存后备队列上等待调度的时间为Tl，进程在就绪队列上等待进程调度的时间为T2，进程在CPU上执行的时间为T3，进程等待I/O操作完成的时间为T4，那么作业的周转时间是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"Tl+T2+T3";i:1;s:8:"Tl+T2+T4";i:2;s:8:"T2+T3+T4";i:3;s:11:"TI+T2+T3+T4";i:4;N;i:5;N;}', NULL),
	(610, 4, 23, 2, 5, '【2018年4月真题】根据实时进程的紧迫程度来进行调度的算法是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"最早截止时间优先算法";i:1;s:24:"最短任务优先算法";i:2;s:27:"最低松弛度优先算法";i:3;s:30:"最早提交时间优先算法";i:4;N;i:5;N;}', NULL),
	(611, 4, 23, 2, 5, '【2018年4月真题】设系统有一类数量为M的独占性资源，系统中N个进程竞争该类资源，每个进程对资源的最大需求为W。当M、N、W分别取下列哪个值时，系统不会发生死锁（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"M=2;N=2;W=2";i:1;s:11:"M=3;N=2;W=3";i:2;s:12:"M=10;N=3;W=4";i:3;s:12:"M=10;N=3;W=5";i:4;N;i:5;N;}', NULL),
	(612, 4, 23, 2, 5, '【2018年4月真题】关于时间片轮转调度算法，在不考虑系统开销的情况下，以下说法正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:105:"系统允许的最大进程数一定时，系统要求的响应时间越短，时间片取值应该越小";i:1;s:93:"系统最长响应时间一定时，时间片大小与系统允许的最大进程数成正比";i:2;s:48:"时间片大小不会影响进程的响应时间";i:3;s:75:"时间片大小一定时，系统进程越多，则系统响应时间越短";i:4;N;i:5;N;}', NULL),
	(613, 4, 23, 2, 5, '根据作业对资源的要求进行分类，从不同类的作业中挑选作业的作业调度算法是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"优先级调度算法";i:1;s:27:"响应比高者优先算法";i:2;s:24:"多级队列调度算法";i:3;s:21:"先来先服务算法";i:4;N;i:5;N;}', NULL),
	(614, 4, 23, 2, 5, '假如某分时系统要保证每个终端用户在每秒钟时间内可以占用处理器运行的时间为50毫秒，那么在忽略系统开销时，该分时系统允许同时工作的终端数最多为（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"10个";i:1;s:5:"20个";i:2;s:5:"50个";i:3;s:6:"100个";i:4;N;i:5;N;}', NULL),
	(615, 4, 23, 2, 5, '有m个进程共享同一临界资源，若使用信号量机制实现对一临界资源的互斥访问，则信号量的变化范围是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"1至1-m";i:1;s:7:"1至m-1";i:2;s:6:"1至-m";i:3;s:5:"1至m";i:4;N;i:5;N;}', NULL),
	(616, 4, 23, 2, 5, '关于死锁的四个必要条件，下列说法不正确的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"发生死锁时，死锁必要条件一定同时成立";i:1;s:66:"死锁必要条件同时成立时，系统不一定会出现死锁";i:2;s:72:"死锁必要条件只要有一个不成立，系统就不会出现死锁";i:3;s:69:"“请求和保持”条件实际上包含了“环路等待”条件";i:4;N;i:5;N;}', NULL),
	(617, 4, 23, 2, 5, '采用银行家算法分配资源可避免死锁发生，这是因为银行家算法（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"把资源按序分配给进程";i:1;s:72:"在检测到系统剩余资源量可满足进程需求时才进行分配";i:2;s:48:"可抢夺其他进程所占资源进行再分配";i:3;s:48:"能对进程每一次的资源请求及时满足";i:4;N;i:5;N;}', NULL),
	(618, 4, 23, 2, 5, '某带有50个终端用户的计算机系统采用时间片轮转调度算法分配处理器。若规定时间片为10毫秒，对用户的每个命令需花费100毫秒完成处理，则终端最长响应时间为（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"2秒";i:1;s:4:"5秒";i:2;s:5:"10秒";i:3;s:5:"50秒";i:4;N;i:5;N;}', NULL),
	(619, 4, 23, 2, 5, '以下处理死锁的方法中，允许死锁发生的是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"摒弃请求和保持条件";i:1;s:15:"银行家算法";i:2;s:27:"检测死锁和解除死锁";i:3;s:33:"资源要按统一的顺序分配";i:4;N;i:5;N;}', NULL),
	(620, 4, 23, 2, 5, '优先权调度算法面临的问题和解决方法是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"老化问题和活力技术";i:1;s:27:"饥饿问题和平衡技术";i:2;s:27:"饥饿问题和老化技术";i:3;s:27:"老化问题和排序技术";i:4;N;i:5;N;}', NULL),
	(621, 4, 23, 4, 5, '【2019年4月真题】如果一个进程的完成规止时间为T1，当前时间为T2，处理完该任务还需要的时间T3，则松弛度L的计算式表示为【】。', '', '', '', '【L=T1-T2-T3】', 0, '', NULL, 0, 0, NULL, NULL),
	(622, 4, 23, 4, 5, '【2019年4月真题】银行家算法中，max[]表示进程需要各类资源的最大数量，allocation[]表示某时刻已分配给进程的某类资源数，need[]表示进程还需要的某类资源的数量，那么三个变量之间的关系为【】。', '', '', '', '【need=max-allocation】', 0, '', NULL, 0, 0, NULL, NULL),
	(623, 4, 23, 4, 5, '【2018年10月真题】资源分配状态S为死锁状态的充分条件是当且仅当S状态的【】_是不可完全简化的。', '', '', '', '【资源分配图】', 0, '', NULL, 0, 0, NULL, NULL),
	(624, 4, 23, 4, 5, '【2018年10月真题】设系统有一类数量为M的独占性资源，系统中5个进程竞争该类资源，每个进程对该类资源的最大需求为3。为确保系统不会发生死锁,M至少应该等于【】', '', '', '', '【11】', 0, '', NULL, 0, 0, NULL, NULL),
	(625, 4, 23, 4, 5, '【2018年4月真题】资源的有序分配策略可以破坏死锁的【】条件。', '', '', '', '【环路等待】', 0, '', NULL, 0, 0, NULL, NULL),
	(626, 4, 23, 4, 5, '【2018年4月真题】有3个进程p1、p2、p3，其进入系统的时间和服务时间分别为：P1:0,28；P2,2,6；P3,4,8。按FCFS调度算法，它们的平均带权周转时间是【】（注：四舍五入精确到小数点后两位）。', '', '', '', '【3.97】', 0, '', NULL, 0, 0, NULL, NULL),
	(627, 4, 23, 4, 5, '某单道程序设计系统中有3个作业A.B.C，它们到达输入井的时间分别为8:50.9:10.9:30，需计算的时间分别为1.5小时.0.4小时.1.0小时，若采用最短作业优先算法，9：30开始调度，则优先进入的作业是【】。', '', '', '', '【B】', 0, '', NULL, 0, 0, NULL, NULL),
	(628, 4, 23, 4, 5, '当某一个进程在处理器上运行时，一旦有更高优先级的进程就绪，进程调度就要剥夺正在处理器上运行的进程使用处理器的权利，而把处理器分配给具有更高优先级的进程，这种调度方式称为【】。', '', '', '', '【抢占式调度】', 0, '', NULL, 0, 0, NULL, NULL),
	(629, 4, 23, 4, 5, '当检测到系统发生死锁之后，可采用剥夺某些进程所占有的资源.【】或重新启动系统等方法来解除死锁。', '', '', '', '【终止处于死锁的进程】', 0, '', NULL, 0, 0, NULL, NULL),
	(630, 4, 23, 4, 5, '假定系统有某类资源6个，可供若干进程共享，每个进程都需要2个资源。为保证系统不发生死锁，应限制共享该类资源的进程数。当进程数最多为【】个时系统是安全的。', '', '', '', '【5】', 0, '', NULL, 0, 0, NULL, NULL),
	(631, 4, 23, 4, 5, '银行家算法在资源动态分配过程中防止系统进入【】', '', '', '', '【不安全状态】', 0, '', NULL, 0, 0, NULL, NULL),
	(632, 4, 23, 4, 5, '产生死锁的两个主要原因是：【】和_【】。', '', '', '', '【竞争资源】【进程推进顺序非法】', 0, '', NULL, 0, 0, NULL, NULL),
	(633, 4, 24, 2, 5, '【2019年4月真题】将一个进程的逻辑地址空间分成若干个大小相等的片，称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"页表";i:1;s:3:"页";i:2;s:6:"页框";i:3;s:6:"页帧";i:4;N;i:5;N;}', NULL),
	(634, 4, 24, 2, 5, '【2019年4月真题】实现虚拟存储器的目的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"实现存储保护";i:1;s:18:"实现程序浮动";i:2;s:18:"扩充外存容量";i:3;s:21:"提高内存利用率";i:4;N;i:5;N;}', NULL),
	(635, 4, 24, 2, 5, '【2019年4月真题】用户程序所对应的地址空间是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"绝对地址空间";i:1;s:18:"逻辑地址空间";i:2;s:16:" I/O地址空间";i:3;s:18:"物理地址空间";i:4;N;i:5;N;}', NULL),
	(636, 4, 24, 2, 5, '【2019年4月真题】在采用快表的存储管理方式中，假定快表的命中率为90%，快表的访问时间为40ns，访问内存的时间为200ns，则系统的有效访存时间是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:" 220ns";i:1;s:6:" 240ns";i:2;s:6:" 260ns";i:3;s:6:" 272ns";i:4;N;i:5;N;}', NULL),
	(637, 4, 24, 2, 5, '【2019年4月真题】为了能将逻辑地址变换为物理地址，在系统中必须设置（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"地址映射机构";i:1;s:18:"地址扩充机构";i:2;s:18:"内有保护机构";i:3;s:18:"地址共享机构";i:4;N;i:5;N;}', NULL),
	(638, 4, 24, 2, 5, '【2018年10月真题】内存管理的目的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"方便用户访间文件系统";i:1;s:24:"提高内存的利用率";i:2;s:24:"增加内存实际容量";i:3;s:18:"增加磁盘容量";i:4;N;i:5;N;}', NULL),
	(639, 4, 24, 2, 5, '【2018年10月真题】在请求分页系统中，记录描述页的各种数据的数据结构称为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"i结点";i:1;s:9:"目录表";i:2;s:6:"段表";i:3;s:6:"页表";i:4;N;i:5;N;}', NULL),
	(640, 4, 24, 2, 5, '【2018年10月真题】选择在最近的过去最久未访问的页面予以置换的算法是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"ORA";i:1;s:4:"FIFO";i:2;s:3:"LRU";i:3;s:5:"Clock";i:4;N;i:5;N;}', NULL),
	(641, 4, 24, 2, 5, '【2018年10月真题】在采用快表的存储管理方式中，假定快表的命中率为85%，快表的访问时间为30ns，访问内存的时间为210ns，则系统的有效访存时间是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"210.5ns";i:1;s:7:"250.5ns";i:2;s:7:"271.5ns";i:3;s:7:"282.5ns";i:4;N;i:5;N;}', NULL),
	(642, 4, 24, 2, 5, '【2018年10月真题】基本分页存储管理方式的逻辑地址结构包括两部分，即页内偏移量和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"页号";i:1;s:12:"页内地址";i:2;s:9:"页框号";i:3;s:6:"段号";i:4;N;i:5;N;}', NULL),
	(643, 4, 24, 2, 5, '【2018年4月真题】进程的最后一页一般装不满一个页框，形成了（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"外部碎片";i:1;s:12:"内部碎片";i:2;s:6:"颠簸";i:3;s:6:"抖动";i:4;N;i:5;N;}', NULL),
	(644, 4, 24, 2, 5, '【2018年4月真题】在程序装入时对目标程序中的指令和数据地址的修改过程称为（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"加载";i:1;s:6:"链接";i:2;s:9:"重定位";i:3;s:6:"编译";i:4;N;i:5;N;}', NULL),
	(645, 4, 24, 2, 5, '【2018年4月真题】相对于分页机制，引入分段机制的主要目的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"易于实现信息共享";i:1;s:18:"支持虚拟存储";i:2;s:24:"提高内存的使用率";i:3;s:18:"预防抖动产生";i:4;N;i:5;N;}', NULL),
	(646, 4, 24, 2, 5, '【2018年4月真题】假定快表的命中率为98%，快表的访问时间为20ns，内存的一次访问时间为100ns，则系统的有效访存时间是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"120ns";i:1;s:5:"102ns";i:2;s:5:"140ns";i:3;s:5:"122ns";i:4;N;i:5;N;}', NULL),
	(647, 4, 24, 2, 5, '【2018年4月真题】基本分页存储管理方式的逻辑地址结构包括两个部分，即页号和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"页框大小";i:1;s:12:"页内地址";i:2;s:9:"目录号";i:3;s:12:"页表索引";i:4;N;i:5;N;}', NULL),
	(648, 4, 24, 2, 5, '处理器中设置有基址寄存器和限长寄存器的存储管理是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"单用户连续";i:1;s:12:"固定分区";i:2;s:12:"可变分区";i:3;s:12:"页式虚拟";i:4;N;i:5;N;}', NULL),
	(649, 4, 24, 2, 5, '采用可变分区管理主存时，某作业的释放不仅不会在空闲区表中增加项，反而减少一项，则说明该作业（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"有上邻空闲区";i:1;s:18:"有下邻空闲区";i:2;s:45:"既有上邻空闲区，又有下邻空闲区";i:3;s:45:"既无上邻空闲区，又无下邻空闲区";i:4;N;i:5;N;}', NULL),
	(650, 4, 24, 2, 5, '根据碎片概念的理解，动态分区分配算法中最容易生成碎片的是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"首次适应";i:1;s:12:"最佳适应";i:2;s:18:"循环首次适应";i:3;s:12:"随机适应";i:4;N;i:5;N;}', NULL),
	(651, 4, 24, 2, 5, '要保证一个程序在主存中被改变了存放位置后仍能正确执行，则对主存空间应采用（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"静态重定位";i:1;s:15:"动态重定位";i:2;s:12:"动态分配";i:3;s:12:"静态分配";i:4;N;i:5;N;}', NULL),
	(652, 4, 24, 2, 5, '下列有关动态分区管理的说法中，正确的是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:96:"采用动态分区管理时，主存储器中空闲区的大小一直在变化，但数目不变";i:1;s:78:"首次适应算法实现简单，但碎片过多使内存空间利用率降低";i:2;s:93:"最佳适应算法总是选择与所需空间大小最接近的空间，不容易留下碎片";i:3;s:102:"循环首次适应算法总是挑选最大的空闲区用于分割，使得剩下的分区仍可使用";i:4;N;i:5;N;}', NULL),
	(653, 4, 24, 2, 5, '计算机系统中存取速度最快的存储器是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"寄存器";i:1;s:12:"主存储器";i:2;s:21:"高速缓冲存储器";i:3;s:15:"辅助存储器";i:4;N;i:5;N;}', NULL),
	(654, 4, 24, 2, 5, '虚拟存储器是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"可提高计算机运算速度的设备";i:1;s:24:"容量扩大了的主存";i:2;s:30:"实际上不存在的存储器";i:3;s:84:"可以容纳总和超过主存容量的多个作业同时运行的一个地址空间";i:4;N;i:5;N;}', NULL),
	(655, 4, 24, 2, 5, '如果用户的逻辑地址长度为32位，则它的虚拟地址空间大小为（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"8GB";i:1;s:3:"4GB";i:2;s:4:"16MB";i:3;s:5:"640KB";i:4;N;i:5;N;}', NULL),
	(656, 4, 24, 2, 5, '在可变式分区分配方案中，某一作业完成后，系统收回其主存空间，并与相邻空闲区合并，为此需修改空闲区表，空闲区数不变的情况是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"无上邻空闲区，也无下邻空闲区";i:1;s:42:"有上邻空闲区，但无下邻空闲区";i:2;s:21:"内存中无空闲区";i:3;s:42:"有上邻空闲区，也有下邻空闲区";i:4;N;i:5;N;}', NULL),
	(657, 4, 24, 2, 5, '可以在有限主存容量的机器中运行更大作业的存储管理方式是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"基本分页";i:1;s:12:"固定分区";i:2;s:12:"动态分区";i:3;s:12:"请求分页";i:4;N;i:5;N;}', NULL),
	(658, 4, 24, 2, 5, '下列关于存储管理的说法中，正确的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"基本分页管理方式能实现虚拟存储";i:1;s:63:"进程占用内存空间大小和该进程的页表长度无关";i:2;s:48:"请求分页存储管理中不存在“碎片”";i:3;s:72:"单用户连续分配存储管理可以不需要硬件地址转换机构";i:4;N;i:5;N;}', NULL),
	(659, 4, 24, 4, 5, '【2019年4月真题】基于分页的虚拟存储系统中，如果频繁进行页面置换，则有可能产生抖动现象。引起抖动的主要原因是【】和_【】_。', '', '', '', '【进程数量太多】【每个进程能分配到的页框太少】', 0, '', NULL, 0, 0, NULL, NULL),
	(660, 4, 24, 4, 5, '【2019年4月真题】在设有快表的分页存储管理方式中，当能在快表中找到所需的页表项时，有效访存时间等于一次访问【】的时间加上次访问【】的时间。', '', '', '', '【[\'快表\', \'或TLB\']】【内存】', 0, '', NULL, 0, 0, NULL, NULL),
	(661, 4, 24, 4, 5, '【2019年4月真题】在二级分页系统中，为了能在地址映射时得到页表在物理内存中的地址，需要为页表再建立一个_【】， 在其中的表项中存放了每一个页表在物理内存中所在的_【】。', '', '', '', '【[\'页目录表\', \'或外层页表\']】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(662, 4, 24, 4, 5, '【2018年10月真题】在分页存储管理方式中，页表的作用是实现从_【】到__【】 的映射。', '', '', '', '【页号】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(663, 4, 24, 4, 5, '【2018年10月真题】根据形成在内存中物理地址的时机不同，把程序的装入方式分为绝对装入方式、【】和【】_。', '', '', '', '【[\'可重定位装入方式\', \'或静态重定位\']】【[\'动态运行时装入方式\', \'或动态重定位\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(664, 4, 24, 4, 5, '【2018年10月真题】在二级分页系统中，为页表再建立一个页目录表的目的是为了能在地址映射时得到页表在物理内存中的地址，在页目录表的表项中存放了每一个_【】在物理内存中所在的【】。', '', '', '', '【页表】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(665, 4, 24, 4, 5, '【2018年4月真题】在基于分页的虚拟存储系统中，常采用两种置换策略， 即_【】和【】。', '', '', '', '【局部置换】【全局置换】', 0, '', NULL, 0, 0, NULL, NULL),
	(666, 4, 24, 4, 5, '【2018年4月真题】在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示【】，另一个数用来表示【】_。', '', '', '', '【段】【段内偏移】', 0, '', NULL, 0, 0, NULL, NULL),
	(667, 4, 24, 4, 5, '【2018年4月真题】考虑一个由8个页、每个页1K字节组成的逻辑地址空间，把它映射到由32个物理块组成的存储器，则逻辑地址有【】位，物理地址有【】位。', '', '', '', '【13】【15】', 0, '', NULL, 0, 0, NULL, NULL),
	(668, 4, 24, 4, 5, '主存储器中被操作系统使用的部分空间称作【】。', '', '', '', '【系统区】', 0, '', NULL, 0, 0, NULL, NULL),
	(669, 4, 24, 4, 5, '在存储管理中，引入快表的目的是【】', '', '', '', '【为了提高CPU访存速度】', 0, '', NULL, 0, 0, NULL, NULL),
	(670, 4, 24, 4, 5, '在程序装入内存时，程序的逻辑地址与内存物理地址完全相同的是【】方式；在装入时对程序的逻辑地址进行修改，转换为内存的物理地址是【】方式；在程序真正执行时才进行地址转换的装入是【】方式。', '', '', '', '【绝对装入】【可重定位装入】【动态运行时装入】', 0, '', NULL, 0, 0, NULL, NULL),
	(671, 4, 24, 4, 5, '请求分页系统的硬件包括页表.【】和_【】', '', '', '', '【缺页异常机构】【支持请求分页的地址变换机构】', 0, '', NULL, 0, 0, NULL, NULL),
	(672, 4, 24, 4, 5, '虚拟存储器具有【】功能和_【】功能，能够在【】上对内存容量加以扩充的存储系统。', '', '', '', '【请求调入】【置换】【逻辑】', 0, '', NULL, 0, 0, NULL, NULL),
	(673, 4, 25, 2, 5, '【2019年4月真题】用于管理文件的系统文件是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"正规文件";i:1;s:12:"目录文件";i:2;s:18:"字符设备文件";i:3;s:15:"块设备文件";i:4;N;i:5;N;}', NULL),
	(674, 4, 25, 2, 5, '【2019年4月真题】常用的文件存取方式有两种：随机存取和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"顺序存取";i:1;s:12:"按名存取";i:2;s:12:"直接存取";i:3;s:15:"按路径存取";i:4;N;i:5;N;}', NULL),
	(675, 4, 25, 2, 5, '【2019年4月真题】文件存储的几种常用方式中，使用磁盘链接表进行分配的优点是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"实现简单";i:1;s:18:"读操作性能好";i:2;s:24:"以充分利用每个簇";i:3;s:24:"随机存储方便快捷";i:4;N;i:5;N;}', NULL),
	(676, 4, 25, 2, 5, '【2018年10月真题】为方便管理，文件系统会保存一些与文件相关的信息，如文件的创建日期、文件大小和修改时间等细节，这些信息称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"文件名";i:1;s:12:"文件属性";i:2;s:12:"文件结构";i:3;s:12:"文件数据";i:4;N;i:5;N;}', NULL),
	(677, 4, 25, 2, 5, '【2018年10月真题】作为WRITE操作的限制形式， 只能在文件末尾添加数据的文件操作是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"APPEND操作";i:1;s:12:"CREATE操作";i:2;s:10:"SEEK操作";i:3;s:12:"RENAME操作";i:4;N;i:5;N;}', NULL),
	(678, 4, 25, 2, 5, '【2018年10月真题】MS-DOS 文件系统采用的磁盘空间分配方式是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"连续分配";i:1;s:30:"使用磁盘链接表的分配";i:2;s:36:"使用内存的链接表分配方式";i:3;s:7:"i结点";i:4;N;i:5;N;}', NULL),
	(679, 4, 25, 2, 5, '【2018年4月真题】能够为用户提供在计算机系统中对数据信息进行长期、大量存储和访问的操作系统重要功能是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"文件系统管理";i:1;s:12:"内存管理";i:2;s:15:"I/O设备管理";i:3;s:12:"进程管理";i:4;N;i:5;N;}', NULL),
	(680, 4, 25, 2, 5, '【2018年4月真题】正规文件的类型有二进制文件和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"ASCII文件";i:1;s:12:"目录文件";i:2;s:18:"字符设备文件";i:3;s:15:"块设备文件";i:4;N;i:5;N;}', NULL),
	(681, 4, 25, 2, 5, '【2018年4月真题】以磁盘文件系统为例，文件存储的几种常用方式中，连续分配的缺点是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"读操作性能不好";i:1;s:45:"随着时间推移会形成很多“空洞”";i:2;s:27:"可以充分利用每个簇";i:3;s:39:"打开文件时需要频繁读取硬盘";i:4;N;i:5;N;}', NULL),
	(682, 4, 25, 2, 5, '在文件管理中，采用位示图主要是实现（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"文件目录查找";i:1;s:18:"主存空间共享";i:2;s:18:"文件更新保护";i:3;s:21:"磁盘空间的管理";i:4;N;i:5;N;}', NULL),
	(683, 4, 25, 2, 5, '如果文件系统中有两个文件重名，不应采用（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"一级目录结构";i:1;s:18:"二级目录结构";i:2;s:18:"树型目录结构";i:3;s:18:"多级目录结构";i:4;N;i:5;N;}', NULL),
	(684, 4, 25, 2, 5, '关于文件操作的使用，下列表述不正确的是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"可调用“打开”和“建立”来申请对文件的使用权";i:1;s:54:"可调用“关闭”操作来归还文件的使用权";i:2;s:39:"可直接删除一个被打开的文件";i:3;s:66:"可通过删除操作使系统收回该文件所占的存储空间";i:4;N;i:5;N;}', NULL),
	(685, 4, 25, 2, 5, '设一个文件由100个物理块组成，若采用链接存储结构，现欲从文件的开头和末尾分别去掉一块，则相应启动I/O的次数是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"1.101";i:1;s:3:"1.1";i:2;s:5:"1.100";i:3;s:5:"100.1";i:4;N;i:5;N;}', NULL),
	(686, 4, 25, 2, 5, '逻辑文件存放到存储介质上时，采用的组织形式与下列哪项有关?（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"逻辑文件结构";i:1;s:18:"存储介质特性";i:2;s:24:"主存储器管理方式";i:3;s:18:"分配外设方式";i:4;N;i:5;N;}', NULL),
	(687, 4, 25, 2, 5, '用户在“读”完一个已经打开的文件后，如果要归还文件的使用权，需要调用（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"“建立”操作";i:1;s:18:"“打开”操作";i:2;s:18:"“删除”操作";i:3;s:18:"“关闭”操作";i:4;N;i:5;N;}', NULL),
	(688, 4, 25, 2, 5, '文件系统采用多级目录结构的目的有（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"实现简单，查找方便";i:1;s:18:"节省存储空间";i:2;s:27:"解决文件的命名冲突";i:3;s:24:"易于实现文件独占";i:4;N;i:5;N;}', NULL),
	(689, 4, 25, 2, 5, '当把一篇文章作为一个文件存放在文件系统中时，文件系统无需了解（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"文件的内容";i:1;s:42:"文件是存放在磁盘上还是磁带上";i:2;s:21:"文件的物理位置";i:3;s:48:"文件以连续方式，还是链接方式存储";i:4;N;i:5;N;}', NULL),
	(690, 4, 25, 2, 5, '某文件系统采用二级目录结构收藏电影，其中目录以收藏者的名字命名（假设收藏者名字不重复），目录下的每个文件对应一部电影。如果对于某一部电影的文件名，收藏者甲采用“计算机的历程”，而收藏者乙采用“电脑的历程”。那么，在该文件系统中（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:43:"必须把这部电影作为2个文件存放";i:1;s:84:"可以把这部电影作为同一个文件存放，但必须改用相同的文件名";i:2;s:84:"可以把这部电影作为同一个文件存放，并无需修改原来的文件名";i:3;s:51:"只允许一位收藏者收藏这部电影的文件";i:4;N;i:5;N;}', NULL),
	(691, 4, 25, 4, 5, '有三种文件结构，分别是：无结构字节序列、【】和【】。', '', '', '', '【固定长度记录序列】【树形结构】', 0, '', NULL, 0, 0, NULL, NULL),
	(692, 4, 25, 4, 5, '【2018年10月真题】文件的类型有:正规文件、目录文件、【】_ 和【】。', '', '', '', '【字符设备文件】【块设备文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(693, 4, 25, 4, 5, '【2018年4月真题】文件系统的用户接口包括：文件的全名、对文件的操作、【】_和_【】。', '', '', '', '【类型】【属性】', 0, '', NULL, 0, 0, NULL, NULL),
	(694, 4, 25, 4, 5, '访问文件时，从当前目录到该文件的通路上所有各级目录名及该文件名组成的路径称为【】，而从根目录开始到该文件的通路上所有各级目录名及该文件名组成的路径称为【】。', '', '', '', '【相对路径】【绝对路径】', 0, '', NULL, 0, 0, NULL, NULL),
	(695, 4, 25, 4, 5, '用户使用文件时，若按文件的逻辑顺序依次进行读/写，这种文件存取方式称为【】存取，若按任意次序读写文件中的信息，则称为【】存取。', '', '', '', '【顺序】【随机】', 0, '', NULL, 0, 0, NULL, NULL),
	(696, 4, 25, 4, 5, '某文件系统采用索引分配方式来分配空间，簇大小为4KB，每个簇号占用4个字节，则一级索引支持的最大文件大小为【】，二级索引支持的最大文件大小为_【】。', '', '', '', '【4MB】【4GB】', 0, '', NULL, 0, 0, NULL, NULL),
	(697, 4, 26, 2, 5, '【2019年4月真题】在I/O设备管理中，必须作为临界资源以互斥方式访问的设备是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"独占设备";i:1;s:12:"共享设备";i:2;s:12:"虚拟设备";i:3;s:12:"低速设备";i:4;N;i:5;N;}', NULL),
	(698, 4, 26, 2, 5, '【2019年4月真题】为了实现主机与设备控制器之间的成块数据传送，在DMA控制器中设计了四类寄存器，其中，记录本次向CPU发送中断信号前要读或写数据次数的寄存器是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"命令/状态寄存器";i:1;s:21:"内存地址寄存器";i:2;s:15:"数据寄存器";i:3;s:15:"数据计数器";i:4;N;i:5;N;}', NULL),
	(699, 4, 26, 2, 5, '【2018年10月真题】设备控制器的功能不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据交换";i:1;s:12:"中断恢复";i:2;s:12:"数据缓冲";i:3;s:12:"地址识别";i:4;N;i:5;N;}', NULL),
	(700, 4, 26, 2, 5, '【2018年10月真题】对I/O设备的缓冲管理方法中，对单缓冲方案说法正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"比双缓冲方案性能高";i:1;s:33:"比循环缓冲方案实现复杂";i:2;s:39:"需要读写两个处理器并行支持";i:3;s:30:"一般用于面向流的设备";i:4;N;i:5;N;}', NULL),
	(701, 4, 26, 2, 5, '【2018年4月真题】按设备的共享属性分类，可把设备分为独享设备、共享设备和（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"逻辑设备";i:1;s:9:"块设备";i:2;s:12:"用户设备";i:3;s:12:"虚拟设备";i:4;N;i:5;N;}', NULL),
	(702, 4, 26, 2, 5, '【2018年4月真题】DMA控制器的逻辑组成包括三部分：主机与DMA的接口、DMA与设备的接口，以及（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"内存地址寄存器";i:1;s:15:"I/O控制逻辑";i:2;s:15:"数据寄存器";i:3;s:24:"主机与设备的接口";i:4;N;i:5;N;}', NULL),
	(703, 4, 26, 2, 5, '关于设备管理的各个功能，下列表述不正确的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:41:"实现外围设备的分配.启动.回收";i:1;s:33:"解决磁盘的驱动调度问题";i:2;s:39:"用可共享设备来模拟独占设备";i:3;s:42:"解决不同用户间的文件命名冲突";i:4;N;i:5;N;}', NULL),
	(704, 4, 26, 2, 5, '用户在使用I/O设备时，通常采用（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"设备绝对号";i:1;s:15:"设备相对号";i:2;s:15:"逻辑设备号";i:3;s:15:"设备地址号";i:4;N;i:5;N;}', NULL),
	(705, 4, 26, 2, 5, '采用SPOOLing技术的目的是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"提高主机效率";i:1;s:30:"提高独占设备的利用率";i:2;s:27:"减轻用户的编程负担";i:3;s:27:"提高程序的运行速度";i:4;N;i:5;N;}', NULL),
	(706, 4, 26, 2, 5, '用户编制程序时使用的设备通常与实际能占用的设备无关，设备的这种特性称为（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"设备的独立性";i:1;s:18:"设备的虚拟性";i:2;s:18:"设备的相对性";i:3;s:18:"设备的绝对性";i:4;N;i:5;N;}', NULL),
	(707, 4, 26, 2, 5, '从使用角度对外围设备进行划分，打印机属于（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"虚拟设备";i:1;s:12:"共享设备";i:2;s:12:"独占设备";i:3;s:12:"顺序设备";i:4;N;i:5;N;}', NULL),
	(708, 4, 26, 2, 5, '当打印机作为I/O通道连接的外围设备，如果打印机在打印的过程中纸用完，这时（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"打印机请求故障事件中断";i:1;s:33:"打印机请求特殊事件中断";i:2;s:33:"I/O通道请求故障事件中断";i:3;s:33:"I/O通道请求特殊事件中断";i:4;N;i:5;N;}', NULL),
	(709, 4, 26, 2, 5, '以下不属于磁盘存储空间的位置参数是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"扇区";i:1;s:6:"块号";i:2;s:6:"盘片";i:3;s:6:"磁道";i:4;N;i:5;N;}', NULL),
	(710, 4, 26, 2, 5, '在单道程序环境中，磁盘调度算法和数据存储位置优化技术都不能减少的磁盘访问时间是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"寻道时间";i:1;s:18:"旋转延迟时间";i:2;s:12:"传输时间";i:3;s:33:"寻道时间和旋转延迟时间";i:4;N;i:5;N;}', NULL),
	(711, 4, 26, 4, 5, '当进程提出I/O请求后，如果系统没有I/O通道，则需要按以下步骤进行设备分配：首先分配【】 ，之后分配【】 ，这时设备分配才算成功。', '', '', '', '【设备】【控制器】', 0, '', NULL, 0, 0, NULL, NULL),
	(712, 4, 26, 4, 5, '【2018年10月真题】 I/O管理软件将设备管理软件从上至下分成四个层次:用户层软件，【】，【】，中断处理程序。', '', '', '', '【与设备无关的软件层】【设备驱动程序】', 0, '', NULL, 0, 0, NULL, NULL),
	(713, 4, 26, 4, 5, '【2018年4月真题】在设备管理中为了提高可适应性和可扩展性，现代操作系统实现了【】，即应用程序独立于具体使用的物理设备。在应用程序中，使用_【】来请求使用设备，而在实际执行时，必须使用物理设备名称。', '', '', '', '【[\'设备独立性\', \'或设备无关性\']】【逻辑设备名称】', 0, '', NULL, 0, 0, NULL, NULL),
	(714, 4, 26, 4, 5, '在磁盘调度算法中，若只考虑请求访问者的先后次序，而不考虑它们要访问的物理位置，这种调度算法是【】；若考虑磁臂移动方向，访问离当前移动臂最近的位置，这种调度算法是【】_。', '', '', '', '【先来先报名】【最短寻道时间优先】', 0, '', NULL, 0, 0, NULL, NULL),
	(715, 4, 26, 4, 5, 'SPOOLing系统由四部分组成：输入井和输出井.输入缓冲区和输出缓冲区.【】_.以及请求I/O队列。', '', '', '', '【输入进程和输出进程】', 0, '', NULL, 0, 0, NULL, NULL),
	(716, 4, 26, 4, 5, '在设备管理的I/0控制方式【】_方式要求CPU不断测试I/O设备的状态，【】_方式能够控制和管理一组数据块的读写过程，但是需要相应的控制器硬件。', '', '', '', '【轮询】【DMA】', 0, '', NULL, 0, 0, NULL, NULL),
	(717, 4, 27, 2, 5, '关于操作系统，以下叙述中正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"批处理系统主要缺点是缺乏交互能力";i:1;s:48:"分时系统不一定都具有人机交互功能";i:2;s:78:"从响应时间的角度来看，实时系统与分时系统的要求差不多";i:3;s:54:"采用多道批处理系统也具有人机交互功能";i:4;N;i:5;N;}', NULL),
	(718, 4, 27, 2, 5, '实时操作系统追求的目标是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"高吞吐率";i:1;s:15:"资源利用率";i:2;s:12:"快速响应";i:3;s:18:"减少系统开销";i:4;N;i:5;N;}', NULL),
	(719, 4, 27, 2, 5, '操作系统的异步性是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"程序的运行结果不确定";i:1;s:30:"程序的运行次序不确定";i:2;s:36:"程序多次运行的时间不确定";i:3;s:75:"程序的运行结果、运行次序以及多次运行的时间都不确定";i:4;N;i:5;N;}', NULL),
	(720, 4, 27, 2, 5, '进程从执行状态进入就绪状态的原因可能是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"被选中占有处理机";i:1;s:18:"等待某一事件";i:2;s:24:"等待的事件已发生";i:3;s:15:"时间片用完";i:4;N;i:5;N;}', NULL),
	(721, 4, 27, 2, 5, '在操作系统中，要对甲、乙两个并发进程进行同步的原因是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"甲、乙两进程必须在有限的时间内完成";i:1;s:21:"进程具有动态性";i:2;s:45:"甲、乙两个进程需要访问临界资源";i:3;s:21:"进程具有结构性";i:4;N;i:5;N;}', NULL),
	(722, 4, 27, 2, 5, '关于系统安全状态的说法，不正确的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"系统处于不安全状态可能发生死锁";i:1;s:48:"系统处于不安全状态一定会发生死锁";i:2;s:45:"不安全状态是死锁状态的一个特例";i:3;s:48:"系统处于安全状态时也可能发生死锁";i:4;N;i:5;N;}', NULL),
	(723, 4, 27, 2, 5, '设某作业在外存后备队列上等待调度的时间为T1,进程在就绪队列上等待进程调度的时间为T2，进程在CPU上执行的时间为T3，进程等待I/O操作完成的时间为T4，那么作业的周转时间是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"T1+T2+T3";i:1;s:8:"T1+T2+T4";i:2;s:8:"T2+T3+T4";i:3;s:11:"T1+T2+T3+T4";i:4;N;i:5;N;}', NULL),
	(724, 4, 27, 2, 5, '根据实时进程的紧迫程度来进行调度的算法是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"最早截止时间优先算法";i:1;s:24:"最短任务优先算法";i:2;s:27:"最低松弛度优先算法";i:3;s:30:"最早提交时间优先算法";i:4;N;i:5;N;}', NULL),
	(725, 4, 27, 2, 5, '设系统有一类数量为M的独占性资源，系统中N个进程竞争该类资源，每个进程对资源的最大需求为W。当M、N、W分别取下列哪个值时，系统不会发生死锁?（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"M=2;N=2;W=2";i:1;s:11:"M=3;N=2;W=3";i:2;s:12:"M=10;N=3;W=4";i:3;s:12:"M=10;N=3;W=5";i:4;N;i:5;N;}', NULL),
	(726, 4, 27, 2, 5, '关于时间片轮转调度算法，在不考虑系统开销的情况下，以下说法正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:103:"系统允许的最大进程数一定时,系统要求的响应时间越短，时间片取值应该越小";i:1;s:93:"系统最长响应时间一定时，时间片大小与系统允许的最大进程数成正比";i:2;s:48:"时间片大小不会影响进程的响应时间";i:3;s:73:"时间片大小一定时，系统进程越多,则系统响应时间越短";i:4;N;i:5;N;}', NULL),
	(727, 4, 27, 2, 5, '进程的最后一页一般装不满一个页框，形成了（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"外部碎片";i:1;s:12:"内部碎片";i:2;s:6:"颠簸";i:3;s:6:"抖动";i:4;N;i:5;N;}', NULL),
	(728, 4, 27, 2, 5, '在程序装入时对目标程序中的指令和数据地址的修改过程称为（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"加载";i:1;s:6:"链接";i:2;s:9:"重定位";i:3;s:6:"编译";i:4;N;i:5;N;}', NULL),
	(729, 4, 27, 2, 5, '相对于分页机制，引入分段机制的主要目的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"易于实现信息共享";i:1;s:18:"支持虚拟存储";i:2;s:24:"提高内存的利用率";i:3;s:18:"预防抖动产生";i:4;N;i:5;N;}', NULL),
	(730, 4, 27, 2, 5, '假定快表的命中率为98%,快表的访问时间为20ns,内存的一次访问时间为100ns，则系统的有效访存时间是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"120ns";i:1;s:5:"102ns";i:2;s:5:"140ns";i:3;s:5:"122ns";i:4;N;i:5;N;}', NULL),
	(731, 4, 27, 2, 5, '基本分页存储管理方式的逻辑地址结构包括两个部分，即页号和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"页框大小";i:1;s:12:"页内地址";i:2;s:12:"页目录号";i:3;s:12:"页表索引";i:4;N;i:5;N;}', NULL),
	(732, 4, 27, 2, 5, '能够为用户提供在计算机系统中对数据信息进行长期、大量存储和访问的操作系统重要功能是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"文件系统管理";i:1;s:12:"内存管理";i:2;s:15:"I/O设备管理";i:3;s:12:"进程管理";i:4;N;i:5;N;}', NULL),
	(733, 4, 27, 2, 5, '正规文件的类型有二进制文件和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"ASCII文件";i:1;s:12:"目录文件";i:2;s:18:"字符设备文件";i:3;s:15:"块设备文件";i:4;N;i:5;N;}', NULL),
	(734, 4, 27, 2, 5, '以磁盘文件系统为例，文件存储的几种常用方式中，连续分配的缺点是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"读操作性能不好";i:1;s:45:"随着时间推移会形成很多“空洞”";i:2;s:27:"可以充分利用每个簇";i:3;s:39:"打开文件时需要频繁读取硬盘";i:4;N;i:5;N;}', NULL),
	(735, 4, 27, 2, 5, '按设备的共享属性分类，可把设备分为独享设备、共享设备和（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"逻辑设备";i:1;s:9:"块设备";i:2;s:12:"用户设备";i:3;s:12:"虚拟设备";i:4;N;i:5;N;}', NULL),
	(736, 4, 27, 2, 5, 'DMA控制器的逻辑组成包括三部分:主机与DMA的接口、DMA与设备的按口,以及（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"内存地址寄存器";i:1;s:14:"IO控制逻辑";i:2;s:15:"数据寄存器";i:3;s:24:"主机与设备的接口";i:4;N;i:5;N;}', NULL),
	(737, 4, 27, 4, 5, '分时系统的四个特征是：多路性、【】 、【】和交互性。', '', '', '', '【独立性】【及时性】', 0, '', NULL, 0, 0, NULL, NULL),
	(738, 4, 27, 4, 5, '进程是真实存在的实体，应用程序对应的进程由该程序、【】和管理进程所需要构成。', '', '', '', '【数据】【[\'进程控制块\', \'或PCB\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(739, 4, 27, 4, 5, '设某一临界区对应的记录型信号量mutex，其初值为1（即mutex value=1）,当mutex value=-2时，表示有【】个进程在临界区内，有【】个进程等待进入临界区。', '', '', '', '【1】【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(740, 4, 27, 4, 5, '资源的有序分配策略可以破坏死锁的【】条件。', '', '', '', '【环路等待】', 0, '', NULL, 0, 0, NULL, NULL),
	(741, 4, 27, 4, 5, '有3个进程p1、p2、p3,其进入系统的时间和服务时间分别为：P1：0,28；P2,：2,6；P3,：4,8。，按FCFS调度算法，它们的平均带权周转时间是【】 （注：四舍五入精确到小数点后两位）。', '', '', '', '【3.97】', 0, '', NULL, 0, 0, NULL, NULL),
	(742, 4, 27, 4, 5, '在基于分页的虚拟存储系统中，常采用两种置换策略，即【】和【】 。', '', '', '', '【局部置换】【全局置换】', 0, '', NULL, 0, 0, NULL, NULL),
	(743, 4, 27, 4, 5, '在使用分段存储管理的系统中，程序员使用二维的逻辑地址，一个数用来表示         ，另一个数用来表示【】。', '', '', '', '【段】【段内偏移】', 0, '', NULL, 0, 0, NULL, NULL),
	(744, 4, 27, 4, 5, '考虑一个由8个页、每个页1K字节组成的逻辑地址空间，把它映射到由32个物理块组成的存储器，则逻辑地址有【】位，物理地址有【】位。', '', '', '', '【13】【15】', 0, '', NULL, 0, 0, NULL, NULL),
	(745, 4, 27, 4, 5, '文件系统的用户接口包括：文件的全名、对文件的操作、 【】和【】。', '', '', '', '【类型】【属性】', 0, '', NULL, 0, 0, NULL, NULL),
	(746, 4, 27, 4, 5, '在设备管理中，为了提高可适应性和可扩展性，现代操作系统实现了【】 ，即应用程序独立于具体使用的物理设备。在应用程序中，使用【】来请求使用设备，而在实际执行时，必须使用物理设备名称。', '', '', '', '【[\'设备独立性\', \'或设备无关性\']】【逻辑设备名称】', 0, '', NULL, 0, 0, NULL, NULL),
	(747, 4, 28, 2, 5, '以下不属于操作系统主要功能的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"管理计算机硬件和软件资源";i:1;s:60:"提供计算机应用程序与计算机硬件之间的接口";i:2;s:36:"为应用程序的运行提供环境";i:3;s:33:"高级程序设计语言的编译";i:4;N;i:5;N;}', NULL),
	(748, 4, 28, 2, 5, '以下不属于分时系统基本特征的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"多路性";i:1;s:9:"独立性";i:2;s:9:"原子性";i:3;s:9:"交互性";i:4;N;i:5;N;}', NULL),
	(749, 4, 28, 2, 5, '现代操作系统具有并发的特征，主要是由于引入了（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"通道技术";i:1;s:12:"中断机制";i:2;s:15:" SPOOLing技术";i:3;s:18:"多道程序系统";i:4;N;i:5;N;}', NULL),
	(750, 4, 28, 2, 5, '进程所请求的一次打印输出完成后，进程的状态会从（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"阻塞态变为就绪态";i:1;s:24:"执行态变为阻塞态";i:2;s:24:"就绪态变为执行态";i:3;s:24:"执行态变为就绪态";i:4;N;i:5;N;}', NULL),
	(751, 4, 28, 2, 5, '临界区是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"一段共享数据区";i:1;s:15:"一个缓冲区";i:2;s:12:"一段程序";i:3;s:18:"一个同步机制";i:4;N;i:5;N;}', NULL),
	(752, 4, 28, 2, 5, '系统要求所有进程执行前一次性地申请在整个运行过程中所需要的全部资源，这样\n可以预防死锁发生的条件是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"互斥条件";i:1;s:21:"请求和保持条件";i:2;s:15:"不剥夺条件";i:3;s:12:"环路等待";i:4;N;i:5;N;}', NULL),
	(753, 4, 28, 2, 5, '在优先权调度算法中，能够解决低优先权进程无穷等待问题的技术是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"老化技术";i:1;s:12:"饥饿技术";i:2;s:12:"调度技术";i:3;s:12:"抢占技术";i:4;N;i:5;N;}', NULL),
	(754, 4, 28, 2, 5, '以下可以用来避免死锁的算法是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"银行家算法";i:1;s:15:"SPF调度算法";i:2;s:11:" SSCF算法";i:3;s:18:"死锁检测算法";i:4;N;i:5;N;}', NULL),
	(755, 4, 28, 2, 5, '在实时系统的调度中，为了保证对截止时间要求较高的实时进程能及时运行，以下\n说法中不正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"要求系统具有快速的硬件中断机制";i:1;s:45:"应使禁止中断的时间间隔尽可能短";i:2;s:36:"应减少进程切换的时间开销";i:3;s:30:"应使得时间片尽可能短";i:4;N;i:5;N;}', NULL),
	(756, 4, 28, 2, 5, '以下对短进程优先调度算法的说法中，正确的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:37:"相比FCFS而言，对短进程不利";i:1;s:61:"相比FCFS而言，长进程可能会长时间得不到调度";i:2;s:55:"相比FCFS而言，紧迫进程更能得到及时处理";i:3;s:46:"相比FCFS而言，降低了系统的吞吐量";i:4;N;i:5;N;}', NULL),
	(757, 4, 28, 2, 5, '内存管理的目的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"方便用户访间文件系统";i:1;s:24:"提高内存的利用率";i:2;s:24:"增加内存实际容量";i:3;s:18:"增加磁盘容量";i:4;N;i:5;N;}', NULL),
	(758, 4, 28, 2, 5, '在请求分页系统中，记录描述页的各种数据的数据结构称为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:" i结点";i:1;s:9:"目录表";i:2;s:6:"段表";i:3;s:6:"页表";i:4;N;i:5;N;}', NULL),
	(759, 4, 28, 2, 5, '选择在最近的过去最久未访问的页面予以置换的算法是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:" ORA";i:1;s:5:" FIFO";i:2;s:4:" LRU";i:3;s:6:" Clock";i:4;N;i:5;N;}', NULL),
	(760, 4, 28, 2, 5, '在采用快表的存储管理方式中，假定快表的命中率为85%，快表的访问时间为30ns,\n访问内存的时间为210ns,则系统的有效访存时间是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:" 210.5ns";i:1;s:8:" 250.5ns";i:2;s:8:" 271.5ns";i:3;s:7:"282.5ns";i:4;N;i:5;N;}', NULL),
	(761, 4, 28, 2, 5, '基本分页存储管理方式的逻辑地址结构包括两部分，即页内偏移量和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"页号";i:1;s:12:"页内地址";i:2;s:9:"页框号";i:3;s:6:"段号";i:4;N;i:5;N;}', NULL),
	(762, 4, 28, 2, 5, '为方便管理，文件系统会保存一些与文件相关的信息，如文件的创建日期、文件大小和修改时间等细节，这些信息称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"文件名";i:1;s:12:"文件属性";i:2;s:12:"文件结构";i:3;s:12:"文件数据";i:4;N;i:5;N;}', NULL),
	(763, 4, 28, 2, 5, '作为WRITE操作的限制形式， 只能在文件末尾添加数据的文件操作是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:" APPEND操作";i:1;s:13:" CREATE操作";i:2;s:11:" SEEK操作";i:3;s:13:" RENAME操作";i:4;N;i:5;N;}', NULL),
	(764, 4, 28, 2, 5, 'MS-DOS 文件系统采用的磁盘空间分配方式是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"连续分配";i:1;s:30:"使用磁盘链接表的分配";i:2;s:36:"使用内存的链接表分配方式";i:3;s:8:" i结点";i:4;N;i:5;N;}', NULL),
	(765, 4, 28, 2, 5, '设备控制器的功能不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据交换";i:1;s:12:"中断恢复";i:2;s:12:"数据缓冲";i:3;s:12:"地址识别";i:4;N;i:5;N;}', NULL),
	(766, 4, 28, 2, 5, '对I/O设备的缓冲管理方法中，对单缓冲方案说法正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"比双缓冲方案性能高";i:1;s:33:"比循环缓冲方案实现复杂";i:2;s:39:"需要读写两个处理器并行支持";i:3;s:30:"一般用于面向流的设备";i:4;N;i:5;N;}', NULL),
	(767, 4, 28, 4, 5, 'CPU中的【】存放当前程序下一条要执行的指令在内存中的地址， CPU从该地址取到指令，并将该指令放入CPU的【】中。', '', '', '', '【[\'程序计数器\', \'或PC\']】【[\'指令寄存器\', \'或IR\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(768, 4, 28, 4, 5, '进程是程序的一次执行，具有并发性、【】、独立性、【】、和结构特征。', '', '', '', '【.动态性】【异步性】', 0, '', NULL, 0, 0, NULL, NULL),
	(769, 4, 28, 4, 5, '在支持线程的操作系统中，【】是被系统独立调度和分派的基本单位，而【】则是资源分配的基本单位。', '', '', '', '【线程】【进程】', 0, '', NULL, 0, 0, NULL, NULL),
	(770, 4, 28, 4, 5, '资源分配状态S为死锁状态的充分条件是当且仅当S状态的【】是不可完全简化的。', '', '', '', '【资源分配图】', 0, '', NULL, 0, 0, NULL, NULL),
	(771, 4, 28, 4, 5, '设系统有一类数量为M的独占性资源，系统中5个进程竞争该类资源，每个进程对该类资源的最大需求为3。为确保系统不会发生死锁,M至少应该等于【】。', '', '', '', '【11】', 0, '', NULL, 0, 0, NULL, NULL),
	(772, 4, 28, 4, 5, '在分页存储管理方式中，页表的作用是实现从【】到【】 的映射。', '', '', '', '【页号】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(773, 4, 28, 4, 5, '根据形成在内存中物理地址的时机不同，把程序的装入方式分为绝对装入方式、【】和【】。', '', '', '', '【[\'可重定位装入方式\', \'或静态重定位\']】【[\'动态运行时装入方式\', \'或动态重定位\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(774, 4, 28, 4, 5, '在二级分页系统中，为页表再建立一个页目录表的目的是为了能在地址映射时得到页表在物理内存中的地址，在页目录表的表项中存放了每一个【】 在物理内存中所在的【】', '', '', '', '【页表】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(775, 4, 28, 4, 5, '文件的类型有：正规文件、目录文件、【】 和【】。', '', '', '', '【字符设备文件】【块设备文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(776, 4, 28, 4, 5, 'I/O管理软件将设备管理软件从上至下分成四个层次:用户层软件，【】，【】，中断处理程序。', '', '', '', '【与设备无关的软件层】【设备驱动程序】', 0, '', NULL, 0, 0, NULL, NULL),
	(777, 4, 29, 2, 5, '有一种操作系统允许在一台主机上同时连接多台终端，多个用户可以通过各自的终端同时交互地使用计算机，满足这一特征的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"单道批处理操作系统";i:1;s:21:"分布式操作系统";i:2;s:12:"分时系统";i:3;s:12:"实时系统";i:4;N;i:5;N;}', NULL),
	(778, 4, 29, 2, 5, '引入多道程序系统的主要目的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"为了充分利用主存储器";i:1;s:42:"充分利用CPU，减少CPU的等待时间";i:2;s:24:"提高实时响应速度";i:3;s:27:"增强系统的交互能力";i:4;N;i:5;N;}', NULL),
	(779, 4, 29, 2, 5, '操作系统内核与应用程序之间的接口是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"联机用户接口";i:1;s:18:"脱机用户接口";i:2;s:12:"系统调用";i:3;s:18:"图形用户接口";i:4;N;i:5;N;}', NULL),
	(780, 4, 29, 2, 5, '下列不是操作系统内核基本功能的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"文件管理";i:1;s:12:"时钟管理";i:2;s:12:"原语操作";i:3;s:12:"中断处理";i:4;N;i:5;N;}', NULL),
	(781, 4, 29, 2, 5, '如果有N（N>2）个进程并发运行，则不可能出现的情形是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:79:"1个进程处于执行态，没有就绪态的进程，N-1个阻塞态的进程";i:1;s:79:"1个进程处于执行态，N-1个就绪态的进程，没有阻塞态的进程";i:2;s:77:"1个进程处于执行态，1个就绪态的进程，N-2个阻塞态的进程";i:3;s:79:"没有进程处于执行态，2个就绪态的进程，N-2个阻塞态的进程";i:4;N;i:5;N;}', NULL),
	(782, 4, 29, 2, 5, '在死锁的预防中，资源的按序分配策略可以破坏（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"互斥使用资源条件";i:1;s:27:"占有且等待资源条件";i:2;s:21:"非抢夺资源条件";i:3;s:24:"循环等待资源条件";i:4;N;i:5;N;}', NULL),
	(783, 4, 29, 2, 5, '在下列进程调度算法中，为每个就绪队列赋予不同时间片的调度算法是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"短进程优先调度";i:1;s:21:"时间片轮转调度";i:2;s:15:"优先权调度";i:3;s:24:"多级反锁队列调度";i:4;N;i:5;N;}', NULL),
	(784, 4, 29, 2, 5, '实时系统中，进程调度需婴考虑的关键因素是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"内存的分配";i:1;s:18:"时间片的确定";i:2;s:36:"对完成截止时间条件的满足";i:3;s:19:" I/O设备的分配";i:4;N;i:5;N;}', NULL),
	(785, 4, 29, 2, 5, '若某系统中有3个并发进程，各需要4个同类资源，则该系统不会产生死锁的最少资源总数应该是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"9个";i:1;s:5:"10个";i:2;s:5:"11个";i:3;s:5:"12个";i:4;N;i:5;N;}', NULL),
	(786, 4, 29, 2, 5, '在操作系统进程调度中，时间片轮转调度算法的目的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"多个终端都能得到系统的及时响应";i:1;s:15:"先来先服务";i:2;s:33:"优先级高的进程先使用CPU";i:3;s:24:"紧急事件优先处理";i:4;N;i:5;N;}', NULL),
	(787, 4, 29, 2, 5, '将一个进程的逻辑地址空间分成若干个大小相等的片，称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"页表";i:1;s:3:"页";i:2;s:6:"页框";i:3;s:6:"页帧";i:4;N;i:5;N;}', NULL),
	(788, 4, 29, 2, 5, '实现虚拟存储器的目的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"实现存储保护";i:1;s:18:"实现程序浮动";i:2;s:18:"扩充外存容量";i:3;s:21:"提高内存利用率";i:4;N;i:5;N;}', NULL),
	(789, 4, 29, 2, 5, '用户程序所对应的地址空间是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"绝对地址空间";i:1;s:18:"逻辑地址空间";i:2;s:16:" I/O地址空间";i:3;s:18:"物理地址空间";i:4;N;i:5;N;}', NULL),
	(790, 4, 29, 2, 5, '在采用快表的存储管理方式中，假定快表的命中率为90%，快表的访问时间为40ns，访问内存的时间为200ns，则系统的有效访存时间是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:" 220ns";i:1;s:6:" 240ns";i:2;s:6:" 260ns";i:3;s:6:" 272ns";i:4;N;i:5;N;}', NULL),
	(791, 4, 29, 2, 5, '为了能将逻辑地址变换为物理地址，在系统中必须设置（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"地址映射机构";i:1;s:18:"地址扩充机构";i:2;s:18:"内有保护机构";i:3;s:18:"地址共享机构";i:4;N;i:5;N;}', NULL),
	(792, 4, 29, 2, 5, '用于管理文件的系统文件是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"正规文件";i:1;s:12:"目录文件";i:2;s:18:"字符设备文件";i:3;s:15:"块设备文件";i:4;N;i:5;N;}', NULL),
	(793, 4, 29, 2, 5, '常用的文件存取方式有两种：随机存取和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"顺序存取";i:1;s:12:"按名存取";i:2;s:12:"直接存取";i:3;s:15:"按路径存取";i:4;N;i:5;N;}', NULL),
	(794, 4, 29, 2, 5, '文件存储的几种常用方式中，使用磁盘链接表进行分配的优点是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"实现简单";i:1;s:18:"读操作性能好";i:2;s:24:"以充分利用每个簇";i:3;s:24:"随机存储方便快捷";i:4;N;i:5;N;}', NULL),
	(795, 4, 29, 2, 5, '在I/O设备管理中，必须作为临界资源以互斥方式访问的设备是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"独占设备";i:1;s:12:"共享设备";i:2;s:12:"虚拟设备";i:3;s:12:"低速设备";i:4;N;i:5;N;}', NULL),
	(796, 4, 29, 2, 5, '为了实现主机与设备控制器之间的成块数据传送，在DMA控制器中设计了四类寄存器，其中，记录本次向CPU发送中断信号前要读或写数据次数的寄存器是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"命令/状态寄存器";i:1;s:21:"内存地址寄存器";i:2;s:15:"数据寄存器";i:3;s:15:"数据计数器";i:4;N;i:5;N;}', NULL),
	(797, 4, 29, 4, 5, '操作系统常见的体系结构有单体结构模型、【】、【】和动态可扩展结构模型。', '', '', '', '【层次结构模型】【微内核结构模型】', 0, '', NULL, 0, 0, NULL, NULL),
	(798, 4, 29, 4, 5, '程序并发执行时具有间断性、【】和【】三个特征。', '', '', '', '【失去封闭性】【不可再现性】', 0, '', NULL, 0, 0, NULL, NULL),
	(799, 4, 29, 4, 5, '对一个记录型信号量S，每执行一次wait （S）操作，S.value 减1。若S.value为0，则该进程【】；若S的数值小于0，则该进程【】。', '', '', '', '【继续执行】【被阻塞】', 0, '', NULL, 0, 0, NULL, NULL),
	(800, 4, 29, 4, 5, '如果一个进程的完成规止时间为T1，当前时间为T2，处理完该任务还需要的时间T3，则松弛度L的计算式表示为【】。', '', '', '', '【L=T1-T2-T3】', 0, '', NULL, 0, 0, NULL, NULL),
	(801, 4, 29, 4, 5, '银行家算法中，max[]表示进程需要各类资源的最大数量，allocation[]表示某时刻已分配给进程的某类资源数，need[]表示进程还需要的某类资源的数量，那么三个变量之间的关系为【】。', '', '', '', '【need=max-allocation】', 0, '', NULL, 0, 0, NULL, NULL),
	(802, 4, 29, 4, 5, '基于分页的虚拟存储系统中，如果频繁进行页面置换，则有可能产生抖动现象。引起抖动的主要原因是_【】和_【】。', '', '', '', '【进程数量太多】【每个进程能分配到的页框太少】', 0, '', NULL, 0, 0, NULL, NULL),
	(803, 4, 29, 4, 5, '在设有快表的分页存储管理方式中，当能在快表中找到所需的页表项时，有效访存时间等于一次访问【】的时间加上次访问【】的时间。', '', '', '', '【[\'快表\', \'或TLB\']】【内存】', 0, '', NULL, 0, 0, NULL, NULL),
	(804, 4, 29, 4, 5, '在二级分页系统中，为了能在地址映射时得到页表在物理内存中的地址，需要为页表再建立一个【】，在其中的表项中存放了每一个页表在物理内存中所在的【】。', '', '', '', '【[\'页目录表\', \'或外层页表\']】【页框号】', 0, '', NULL, 0, 0, NULL, NULL),
	(805, 4, 29, 4, 5, '有三种文件结构，分别是：无结构字节序列、【】和_【】。', '', '', '', '【固定长度记录序列】【树形结构】', 0, '', NULL, 0, 0, NULL, NULL),
	(806, 4, 29, 4, 5, '当进程提出I/O请求后，如果系统没有I/O通道，则需要按以下步骤进行设备分配:首先分配【】，之后分配【】，这时设备分配才算成功。', '', '', '', '【设备】【控制器】', 0, '', NULL, 0, 0, NULL, NULL),
	(807, 4, 30, 2, 5, '以下不是多道程序系统（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"单用户单任务";i:1;s:21:"多道批处理系统";i:2;s:36:"为应用程序的运行提供环境";i:3;s:33:"高级程序设计语言的编译";i:4;N;i:5;N;}', NULL),
	(808, 4, 30, 2, 5, '操作系统主要功能是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:63:"进程管理、存储器管理、设备管理、处理机管理";i:1;s:66:"虚拟存储管理、处理机管理、进程调度、文件系统";i:2;s:63:"处理机管理、存储器管理、设备管理、文件系统";i:3;s:57:"进程管理、中断管理、设备管理、文件系统";i:4;N;i:5;N;}', NULL),
	(809, 4, 30, 2, 5, '现代操作系统的体系结构多采用以下设计（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:55:"微内核技术、客户/服务器模式、星型模型";i:1;s:42:"超线程技术、P2P模式、分层模型";i:2;s:42:"超线程技术、P2P模式、星型模型";i:3;s:55:"微内核技术、客户/服务器模式、分层模型";i:4;N;i:5;N;}', NULL),
	(810, 4, 30, 2, 5, '要求在规定的时间内对请求必须及时响应的操作系统是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"分时系统";i:1;s:12:"实时系统";i:2;s:15:"批处理系统";i:3;s:18:"网络操作系统";i:4;N;i:5;N;}', NULL),
	(811, 4, 30, 2, 5, '因为执行程序而要创建进程，这反映了进程的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"并发性";i:1;s:9:"动态性";i:2;s:9:"独立性";i:3;s:9:"异步性";i:4;N;i:5;N;}', NULL),
	(812, 4, 30, 2, 5, '操作系统感知进程是通过进程的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"进程控制块";i:1;s:15:"进程代码段";i:2;s:15:"进程数据段";i:3;s:21:"进程上下文环境";i:4;N;i:5;N;}', NULL),
	(813, 4, 30, 2, 5, '以下情况，进程从执行态转变为就绪态的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"进程被调度程序选中";i:1;s:12:"时间片到";i:2;s:18:"等待某一事件";i:3;s:27:"进程被系统强行关闭";i:4;N;i:5;N;}', NULL),
	(814, 4, 30, 2, 5, '以下关于线程描述正确的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"线程是比进程更小的能独立运行的基本单位";i:1;s:81:"引入线程可提高程序并发执行的程度，可进一步提高系统效率";i:2;s:51:"线程的引入增加了程序执行时时空开销";i:3;s:36:"一个进程一定包含多个线程";i:4;N;i:5;N;}', NULL),
	(815, 4, 30, 2, 5, '以下关于临界资源描述正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"临界资源是非共享资源";i:1;s:33:"临界资源是单一共享资源";i:2;s:33:"临界资源是互斥共享资源";i:3;s:33:"临界资源是同时共享资源";i:4;N;i:5;N;}', NULL),
	(816, 4, 30, 2, 5, '为了照顾紧迫型作业，应采用（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"先来先服务调度算法";i:1;s:27:"短作业优先调度算法";i:2;s:27:"时间片轮转调度算法";i:3;s:21:"优先权调度算法";i:4;N;i:5;N;}', NULL),
	(817, 4, 30, 2, 5, '资源一次性分配可以预防死锁，因为它使以下条件不成立（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"互斥条件";i:1;s:21:"请求和保持条件";i:2;s:18:"不可剥夺条件";i:3;s:18:"环路等待条件";i:4;N;i:5;N;}', NULL),
	(818, 4, 30, 2, 5, '以下属于检测死锁的方法是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"资源一次性分配";i:1;s:33:"已分配资源可以强行收回";i:2;s:15:"银行家算法";i:3;s:21:"资源分配图简化";i:4;N;i:5;N;}', NULL),
	(819, 4, 30, 2, 5, '只有在程序运行时，逻辑地址才会转换为内存物理地址的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"绝对装入";i:1;s:12:"相对装入";i:2;s:15:"重定位装入";i:3;s:12:"动态装入";i:4;N;i:5;N;}', NULL),
	(820, 4, 30, 2, 5, '基本分页系统的逻辑地址结构包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"页号和段号";i:1;s:18:"页号和页框号";i:2;s:24:"页框号和页内地址";i:3;s:21:"页号和页内地址";i:4;N;i:5;N;}', NULL),
	(821, 4, 30, 2, 5, '分区管理和分页管理的主要区别是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"分区中的块比分页中的页要小";i:1;s:36:"分页有地址映射而分区没有";i:2;s:36:"分页有存储保护而分区没有";i:3;s:78:"分区要求一道程序存放在连续的空间内而分页没有这种要求";i:4;N;i:5;N;}', NULL),
	(822, 4, 30, 2, 5, '以下关于虚拟存储器的叙述正确是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:87:"要求程序运行前必须全部装入内存且在运行过程中一直驻留在内存";i:1;s:93:"要求程序运行前不必全部装入内存且在运行过程中不必一直驻留在内存";i:2;s:96:"要求程序运行前不必全部装入内存但是在运行过程中必须一直驻留在内存";i:3;s:93:"要求程序运行前必须全部装入内存但在运行过程中不必一直驻留在内存";i:4;N;i:5;N;}', NULL),
	(823, 4, 30, 2, 5, '使用SPOOLing系统的目的是为了（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"提高操作系统的访问效率";i:1;s:24:"提高CPU的访问效率";i:2;s:27:"提高内存的访问效率";i:3;s:30:"提高I/O设备的访问效率";i:4;N;i:5;N;}', NULL),
	(824, 4, 30, 2, 5, '在文件末尾添加数据的文件操作是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:" APPEND操作";i:1;s:13:" CREATE操作";i:2;s:10:"SEEK操作";i:3;s:13:" RENAME操作";i:4;N;i:5;N;}', NULL),
	(825, 4, 30, 2, 5, '由连续分配发展为分页管理的主要原因是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"提高内存利用率";i:1;s:21:"提高系统吞吐量";i:2;s:18:"满足CPU的需要";i:3;s:36:"满足更多道程序运行的需要";i:4;N;i:5;N;}', NULL),
	(826, 4, 30, 2, 5, '以下I/O控制方式，要求CPU不断测试I/O设备的状态的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"程序轮询";i:1;s:6:"中断";i:2;s:3:"DMA";i:3;s:9:"通道机";i:4;N;i:5;N;}', NULL),
	(827, 4, 30, 4, 5, '操作系统的作用包括：作为用户与硬件之间的【】；作为计算系统资源的_【】。', '', '', '', '【接口】【管理者】', 0, '', NULL, 0, 0, NULL, NULL),
	(828, 4, 30, 4, 5, '设某临界区对应的记录型信号mutex，其初值为1，当mutex值为-2时，表示有【】个进程在临界区内，有【】个进程等待进入临界区。', '', '', '', '【1】【2】', 0, '', NULL, 0, 0, NULL, NULL),
	(829, 4, 30, 4, 5, '一个有8个页、每个页1K字节组成的逻辑地址空间，把它映射到由32个物理块组成的存储器，则逻辑地址有【】_位，物理地址有【】位。', '', '', '', '【13】【15】', 0, '', NULL, 0, 0, NULL, NULL),
	(830, 4, 30, 4, 5, '同步机制应遵循的四个原则：空闲让进，【】，有限等待和【】', '', '', '', '【忙则等待】【让权等待】', 0, '', NULL, 0, 0, NULL, NULL),
	(831, 4, 30, 4, 5, '在处理死锁的方法类型中，银行家算法属于【】；资源分配图简化属于【】。', '', '', '', '【避免思索】【检测死锁】', 0, '', NULL, 0, 0, NULL, NULL),
	(832, 4, 30, 4, 5, '请求分页的硬件支持包括页表、【】和【】。', '', '', '', '【缺页异常结构】【支持请求分页的地址变换机构】', 0, '', NULL, 0, 0, NULL, NULL),
	(833, 4, 30, 4, 5, '根据I/O设备信息交换单位分类，【】传输速率较高，其典型设备是磁盘；【】传输速率低，打印机、鼠标都属于该类设备。', '', '', '', '【块设备】【字符设备】', 0, '', NULL, 0, 0, NULL, NULL),
	(834, 4, 30, 4, 5, 'I/O设备管理软件组织分成四个层次：【】，与设备无关的软件层，【】_，中断处理程序。', '', '', '', '【用户层程序】【设备驱动层程序】', 0, '', NULL, 0, 0, NULL, NULL),
	(835, 4, 30, 4, 5, '对文件进行磁盘空间分配的方式包括_【】，磁盘链接表的分配，【】和i-结点。', '', '', '', '【连续分配】【使用内存的链接表分配】', 0, '', NULL, 0, 0, NULL, NULL),
	(836, 4, 30, 4, 5, '常用的文件存取方式有【】和【】。', '', '', '', '【顺序存取】【随机存取】', 0, '', NULL, 0, 0, NULL, NULL),
	(837, 4, 31, 2, 5, '以下是多道操作系统系统不可缺少的支持（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"打印机";i:1;s:12:"中断机构";i:2;s:6:"光驱";i:3;s:6:"鼠标";i:4;N;i:5;N;}', NULL),
	(838, 4, 31, 2, 5, 'Windos Server200X属于哪种操作系统（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"主机操作系统";i:1;s:21:"服务器操作系统";i:2;s:18:"微机操作系统";i:3;s:21:"嵌入式操作系统";i:4;N;i:5;N;}', NULL),
	(839, 4, 31, 2, 5, '在CPU中用于存放指令寄存器的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:" PC";i:1;s:3:" IR";i:2;s:3:" AC";i:3;s:3:" CS";i:4;N;i:5;N;}', NULL),
	(840, 4, 31, 2, 5, '允许多个用户通过终端同时使用计算机的的操作系统是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"分时系统";i:1;s:12:"实时系统";i:2;s:21:"单道批处理系统";i:3;s:21:"多道批处理系统";i:4;N;i:5;N;}', NULL),
	(841, 4, 31, 2, 5, '多个进程实体能在一段时间间隔内同时进行，这反映了进程的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"并发性";i:1;s:9:"动态性";i:2;s:9:"独立性";i:3;s:9:"异步性";i:4;N;i:5;N;}', NULL),
	(842, 4, 31, 2, 5, '在以下情况下，可能需要创建新进程（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"父进程终止子进程";i:1;s:36:"进程发出启动打印机的命令";i:2;s:12:"用户登录";i:3;s:27:"进程将进入就绪队列";i:4;N;i:5;N;}', NULL),
	(843, 4, 31, 2, 5, '在进程状态切换中，以下情况是不可能发生（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"就绪态→执行态";i:1;s:21:"执行态→就绪态";i:2;s:21:"执行态→阻塞态";i:3;s:21:"阻塞态→执行态";i:4;N;i:5;N;}', NULL),
	(844, 4, 31, 2, 5, '设两个进程共用一个临界资源的互斥信号量mutex，当mutex＝1时表示（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"一个进程进入了临界区，另一个进程等待";i:1;s:33:"没有一个进程进入临界区";i:2;s:30:"两个进程都进入临界区";i:3;s:24:"两个进程都在等待";i:4;N;i:5;N;}', NULL),
	(845, 4, 31, 2, 5, '在限定时间内尽可能完成更多的作业，应采用（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"先来先服务调度算法";i:1;s:27:"短作业优先调度算法";i:2;s:27:"时间片轮转调度算法";i:3;s:21:"优先权调度算法";i:4;N;i:5;N;}', NULL),
	(846, 4, 31, 2, 5, '将资源分配按照先后顺序进行可以预防死锁，因为它使以下条件不成立（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"互斥条件";i:1;s:21:"请求和保持条件";i:2;s:18:"不可剥夺条件";i:3;s:18:"环路等待条件";i:4;N;i:5;N;}', NULL),
	(847, 4, 31, 2, 5, '把程序装入内存时：程序逻辑地址在与内存物理地址完全相同的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"绝对装入";i:1;s:12:"相对装入";i:2;s:15:"重定位装入";i:3;s:12:"动态装入";i:4;N;i:5;N;}', NULL),
	(848, 4, 31, 2, 5, '在内存分配的首适应算法中，空闲块是按（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"块的始地址从小到大排序";i:1;s:33:"块的始地址从大到小排序";i:2;s:30:"块的大小从小到大排序";i:3;s:30:"块的大小从大到小排序";i:4;N;i:5;N;}', NULL),
	(849, 4, 31, 2, 5, '以下有关请求分页管理的叙述正确是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"程序和数据是在开始执行前一次性装入的";i:1;s:42:"产生缺页中断时要淘汰一个页面";i:2;s:39:"被淘汰的页面一定要写回外存";i:3;s:33:"页表一定要有“访问位”";i:4;N;i:5;N;}', NULL),
	(850, 4, 31, 2, 5, '关于通道、设备、设备控制器三者间关系的叙述正确是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"设备控制器和通道可以分别控制设备";i:1;s:48:"设备控制器控制通道和设备一起工作";i:2;s:57:"通道控制设备控制器，设备控制器控制设备";i:3;s:48:"设备控制器控制通道，通道控制设备";i:4;N;i:5;N;}', NULL),
	(851, 4, 31, 2, 5, '修改文件名称的文件操作是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:" APPEND操作";i:1;s:13:" CREATE操作";i:2;s:10:"SEEK操作";i:3;s:13:" RENAME操作";i:4;N;i:5;N;}', NULL),
	(852, 4, 31, 2, 5, '以下控制方式中，能够控制和管理一个数据块的读写过程的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"程序轮询";i:1;s:6:"中断";i:2;s:3:"DMA";i:3;s:14:"SPOOLING技术";i:4;N;i:5;N;}', NULL),
	(853, 4, 31, 4, 5, '操作系统的四项基本特征是并发性、【】、共享性和【】。', '', '', '', '【虚拟性】【异步性】', 0, '', NULL, 0, 0, NULL, NULL),
	(854, 4, 31, 4, 5, '系统中5个进程竞争某类独占资源，每个进程对资源的最大需求都为3，为确保系统不会死锁，资源数量至少为【】_。', '', '', '', '【11】', 0, '', NULL, 0, 0, NULL, NULL),
	(855, 4, 31, 4, 5, '在采用快表的存储管理中，快表命中率为85%，快表访问时间为30ns，访问内存的时间为210ns，则系统的有效访存时间是【】_ns。', '', '', '', '【271.5】', 0, '', NULL, 0, 0, NULL, NULL),
	(856, 4, 31, 4, 5, '进程控制块包含四方面信息：进程标识符、【】、进程调度信息和【】。', '', '', '', '【处理机状态信息】【进程控制信息】', 0, '', NULL, 0, 0, NULL, NULL),
	(857, 4, 31, 4, 5, '造成死锁的两个主要原因是：【】和【】。', '', '', '', '【竞争共享资源】【分配资源顺序不当】', 0, '', NULL, 0, 0, NULL, NULL),
	(858, 4, 31, 4, 5, '分段存储管理中，逻辑地址结构包含【】和【】。', '', '', '', '【段号】【段内偏移地址】', 0, '', NULL, 0, 0, NULL, NULL),
	(859, 4, 31, 4, 5, '根据I/O设备的共享属性分类，【】是指必须作为临界资源以互斥方式访问的设备；【】是指通过软硬件技术将一台物理设备变为若干台逻辑设备供多个用户访问。', '', '', '', '【独占设备】【虚拟设备】', 0, '', NULL, 0, 0, NULL, NULL),
	(860, 4, 31, 4, 5, 'I/O系统结构分为【】和【】。', '', '', '', '【微机I/O系统】【主机I/O系统】', 0, '', NULL, 0, 0, NULL, NULL),
	(861, 4, 31, 4, 5, '文件结构常见有三种：【】也称为流式文件；【】是指操作系统以记录的方式执行文件的读写；第三种是树形结构。', '', '', '', '【无结构字节序列】【固定长度记录序列】', 0, '', NULL, 0, 0, NULL, NULL),
	(862, 4, 31, 4, 5, '常用表示文件名的两种路径方法：【】_是由从根目录到文件的路径组成；【】是由当前工作目录下到文件的路径。', '', '', '', '【绝对路径】【相对路径】', 0, '', NULL, 0, 0, NULL, NULL),
	(863, 4, 32, 2, 5, '下列不属于数据管理技术进入数据库阶段的标志的选项是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"关系模型的提出";i:1;s:21:"网状模型的提出";i:2;s:63:"具有数百兆字节容量和快速存取的磁盘进入市场";i:3;s:33:"层次模型的IMS系统的推出";i:4;N;i:5;N;}', NULL),
	(864, 4, 32, 2, 5, '在数据库中，数据的物理独立性是指（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:84:"用户的应用程序与存储在磁盘上的数据库中的数据是相互独立的";i:1;s:60:"应用程序与数据库中数据的逻辑结构相互独立";i:2;s:48:"数据库与数据库管理系统的相互独立";i:3;s:34:"用户程序的DBMS的相互独立";i:4;N;i:5;N;}', NULL),
	(865, 4, 32, 2, 5, '在数据库三级模式间引入二级映像的主要作用是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"提高数据与程序的独立性";i:1;s:33:"提高数据与程序的安全性";i:2;s:33:"保持数据与程序的一致性";i:3;s:36:"提高数据与程序的可移植性";i:4;N;i:5;N;}', NULL),
	(866, 4, 32, 2, 5, '概念模型最常用的表示方法是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"E-R方法";i:1;s:15:"数据的方法";i:2;s:15:"分布式方法";i:3;s:21:"面向对象的方法";i:4;N;i:5;N;}', NULL),
	(867, 4, 32, 2, 5, '下列哪个选项不属于数据管理技术进入数据库阶段的标志（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"层次模型的IMS系统的推出";i:1;s:63:"具有数百兆字节容量和快速存取的磁盘进入市场";i:2;s:21:"网状模型的提出";i:3;s:21:"关系模型的提出";i:4;N;i:5;N;}', NULL),
	(868, 4, 32, 2, 5, '在数据库系统中，提供数据与应用程序间物理独立性的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:28:"外模式/逻辑模式映像";i:1;s:28:"逻辑模式/内模式映像";i:2;s:25:"外模式/内模式映像";i:3;s:28:"子模式/逻辑模式映像";i:4;N;i:5;N;}', NULL),
	(869, 4, 32, 2, 5, '下列描述中正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"概念模型独立于硬件，但依赖于软件";i:1;s:36:"逻辑模型独立于硬件和软件";i:2;s:48:"外部模型独立于硬件，但依赖于软件";i:3;s:48:"内部模型依赖于硬件，但独立于软件";i:4;N;i:5;N;}', NULL),
	(870, 4, 32, 2, 5, '在数据库的三层模式中，描述数据库中全部数据的整体逻辑结构的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"外模式";i:1;s:9:"内模式";i:2;s:12:"逻辑模式";i:3;s:12:"存储模式";i:4;N;i:5;N;}', NULL),
	(871, 4, 32, 2, 5, '在下列的数据模型中，独立于计算机系统的模型是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"概念模型";i:1;s:12:"逻辑模型";i:2;s:12:"内部模型";i:3;s:12:"外部模型";i:4;N;i:5;N;}', NULL),
	(872, 4, 32, 2, 5, '从数据库管理员的角度来看，数据库系统的内部系统结构通常采用（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"三级模式结构";i:1;s:15:"集中式结构";i:2;s:15:"分布式结构";i:3;s:15:"并行式结构";i:4;N;i:5;N;}', NULL),
	(873, 4, 32, 2, 5, '一个数据库的内模式可以有（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"一个";i:1;s:6:"两个";i:2;s:6:"三个";i:3;s:6:"多个";i:4;N;i:5;N;}', NULL),
	(874, 4, 32, 2, 5, '在数据库系统中，定义了数据库全局逻辑结构与物理存储间对应关系的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"模式/内模式映像";i:1;s:22:"外模式/模式映像";i:2;s:25:"外模式/内模式映像";i:3;s:22:"子模式/模式映像";i:4;N;i:5;N;}', NULL),
	(875, 4, 32, 2, 5, '概念层数据模型中，客观存在并可相互区别的事物称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"属性";i:1;s:6:"实体";i:2;s:3:"域";i:3;s:6:"联系";i:4;N;i:5;N;}', NULL),
	(876, 4, 32, 2, 5, '下列数据模型中，采用二维表格结构来表示实体与实体之间联系的模型是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"关系模型";i:1;s:18:"面向对象模型";i:2;s:12:"网状模型";i:3;s:12:"层次模型";i:4;N;i:5;N;}', NULL),
	(877, 4, 32, 2, 5, '下列描述中，不属于数据库系统特点的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"数据独立性高";i:1;s:18:"数据冗余度高";i:2;s:18:"数据共享性好";i:3;s:18:"数据一致性好";i:4;N;i:5;N;}', NULL),
	(878, 4, 32, 2, 5, '描述事物的符号记录是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"Data";i:1;s:2:"DB";i:2;s:4:"DBMS";i:3;s:3:"DBS";i:4;N;i:5;N;}', NULL),
	(879, 4, 32, 2, 5, '不属于人工管理阶段特点的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据共享";i:1;s:15:"数据不保存";i:2;s:24:"应用程序管理数据";i:3;s:18:"数据面向应用";i:4;N;i:5;N;}', NULL),
	(880, 4, 32, 4, 5, '从事物的特性到计算机中的具体表示，数据描述经历了三个阶段，分别为概念设计、逻辑设计和【】。', '', '', '', '【物理设计】', 0, '', NULL, 0, 0, NULL, NULL),
	(881, 4, 32, 4, 5, '进入高级数据库阶段的主要标志是20世纪80年代的分布式数据库系统、90年代的对象数据库系统以及21世纪的【】的出现。', '', '', '', '【Web数据库系统】', 0, '', NULL, 0, 0, NULL, NULL),
	(882, 4, 32, 4, 5, '根据数据抽象的级别定义了四种模型：概念数据模型、逻辑数据模型、外部数据模型和内部数据模型，其中抽象级别最高的是【】。', '', '', '', '【概念数据模型】', 0, '', NULL, 0, 0, NULL, NULL),
	(883, 4, 32, 4, 5, 'E-R模型的基本组成元素有：实体、属性和【】。', '', '', '', '【联系】', 0, '', NULL, 0, 0, NULL, NULL),
	(884, 4, 32, 4, 5, '从事物的特性到计算机中的具体表示,数据描述经历了概念设计、逻辑设计和【】三个阶段。', '', '', '', '【物理设计】', 0, '', NULL, 0, 0, NULL, NULL),
	(885, 4, 32, 4, 5, '与一个联系有关的实体集个数，称为联系的【】。', '', '', '', '【元数】', 0, '', NULL, 0, 0, NULL, NULL),
	(886, 4, 32, 4, 5, '在数据抽象的四种级别中，抽象级别最高的数据模型是【】。', '', '', '', '【概念模型】', 0, '', NULL, 0, 0, NULL, NULL),
	(887, 4, 33, 2, 5, '在关系规范化过程中，消除了       后，1NF变成了3NF。（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"完全函数依赖和传递函数依赖";i:1;s:39:"局部函数依赖和传递函数依赖";i:2;s:18:"局部函数依赖";i:3;s:18:"完全函数依赖";i:4;N;i:5;N;}', NULL),
	(888, 4, 33, 2, 5, '在关系模式R（U，F）中,如果X→Y,存在X的真子集X1,使X1→Y，称函数依赖X→Y为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"平凡函数依赖";i:1;s:18:"部分函数依赖";i:2;s:18:"完全函数依赖";i:3;s:18:"传递函数依赖";i:4;N;i:5;N;}', NULL),
	(889, 4, 33, 2, 5, '有关系模式学生（学号，课程号，名次），若每一名学生的每门课程都有对应的名次，每门课程的每一个名次只有一名学生，则以下叙述中错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:22:"关系模式属于BCNF";i:1;s:30:"关系模式属于第三范式";i:2;s:48:"只有（学号，课程号）能作为候选健";i:3;s:75:"（学号，课程号）和（课程号，名次）都可以作为候选键";i:4;N;i:5;N;}', NULL),
	(890, 4, 33, 2, 5, '关系模式的任何属性（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"不可再分";i:1;s:9:"可再分";i:2;s:39:"命名在该关系模式中可以不唯";i:3;s:18:"以上都不正确";i:4;N;i:5;N;}', NULL),
	(891, 4, 33, 2, 5, '在数据库中，产生数据不一致的根本原因是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"数据存储量太大";i:1;s:27:"没有严格的数据保护";i:2;s:33:"未对数据进行严格的控制";i:3;s:12:"数据冗余";i:4;N;i:5;N;}', NULL),
	(892, 4, 33, 2, 5, '在关系模式R（U，F）中，R中任何非主属性对候选键完全函数依赖是R∈3NF的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"充分必要条件";i:1;s:12:"必要条件";i:2;s:12:"充分条件";i:3;s:30:"既不充分也不必要条件";i:4;N;i:5;N;}', NULL),
	(893, 4, 33, 2, 5, '下列式子中，不正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:17:"R-S=R-（R∩S）";i:1;s:25:"R=（R-S）∪（R∩S）";i:2;s:17:"R∩S=S-（S-R）";i:3;s:17:"R∩S=S-（R-S）";i:4;N;i:5;N;}', NULL),
	(894, 4, 33, 2, 5, '设关系R和S的结构相同，且各有10个元组，那么这两个关系的并操作结果的元组个数为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:"10";i:1;s:2:"30";i:2;s:4:"1000";i:3;s:9:"不确定";i:4;N;i:5;N;}', NULL),
	(895, 4, 33, 2, 5, '已知关系R（A，B）和S（A，B），则以下关系代数表达式中错误的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:17:"R∩S=S-（S-R）";i:1;s:17:"R-S=R-（R∩S）";i:2;s:19:"R∪S=R∪（S-R）";i:3;s:17:"R∩S=R-（S-R）";i:4;N;i:5;N;}', NULL),
	(896, 4, 33, 2, 5, '关系运算中花费时间可能最长的运算是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"投影";i:1;s:6:"选择";i:2;s:12:"笛卡尔积";i:3;s:3:"除";i:4;N;i:5;N;}', NULL),
	(897, 4, 33, 2, 5, '下列关于关系的描述中，不正确的说法是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"在关系中，每一行数据是可以任意交换的";i:1;s:54:"在关系中，每一列数据是可以任意交换的";i:2;s:51:"在关系中，任意两行数据是允许重复的";i:3;s:57:"在关系中，任意两个属性名是不允许重名的";i:4;N;i:5;N;}', NULL),
	(898, 4, 33, 2, 5, '当关系R和S自然连接时（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:40:"在新表中，包含R×S中所有的行";i:1;s:90:"在新表中，只包含两个关系之间公共属性值相等的行，消除重复属性";i:2;s:93:"在新表中，只包含两个关系之间公共属性值相等的行，不消除重复属性";i:3;s:78:"自然连接要求两个关系中相同的分量，不必是相同的属性组";i:4;N;i:5;N;}', NULL),
	(899, 4, 33, 2, 5, '有两个关系R和S，分别包含15个和10个元组，则在RUS、R-S、R∩S中不可能出现的元组数目情况是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"15，5，10";i:1;s:10:"18，7，7";i:2;s:11:"21，11，4";i:3;s:11:"25，15，0";i:4;N;i:5;N;}', NULL),
	(900, 4, 33, 2, 5, '关系表中的列，也称作（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"元组";i:1;s:6:"记录";i:2;s:6:"字段";i:3;s:6:"数组";i:4;N;i:5;N;}', NULL),
	(901, 4, 33, 2, 5, '关系中包含在任何一个候选码中的属性称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"非主属性";i:1;s:9:"主属性";i:2;s:12:"非码属性";i:3;s:9:"超属性";i:4;N;i:5;N;}', NULL),
	(902, 4, 33, 2, 5, '关于参照关系和被参照关系叙述正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:84:"以外码相关联的两个关系，以外码作为主码的关系称为参照关系";i:1;s:78:"以外码相关联的两个关系，外码所在的关系称为被参照关系";i:2;s:66:"参照关系也称为主关系，被参照关系也称为从关系";i:3;s:66:"参照关系也称为从关系，被参照关系也称为主关系";i:4;N;i:5;N;}', NULL),
	(903, 4, 33, 4, 5, '为了维护数据库中数据与现实的一致性，关系数据库的数据与更新操作必须遵循下列三类完整性规则：【】、参照完整性规则、用户定义的完整性规则。', '', '', '', '【实体完整性原则】', 0, '', NULL, 0, 0, NULL, NULL),
	(904, 4, 33, 4, 5, '设有关系模式R（A，B，C），F={A→B,B→C}，则R的候选键是【】。', '', '', '', '【A】', 0, '', NULL, 0, 0, NULL, NULL),
	(905, 4, 33, 4, 5, '设有关系模式R（X，Y，Z），F={X→Y，Y→Z}，则R的候选键是【】。', '', '', '', '【X】', 0, '', NULL, 0, 0, NULL, NULL),
	(906, 4, 33, 4, 5, '设有关系模式R（A，B，C），F={A→C，AB→>C}，则R中存在【】 函数依赖。', '', '', '', '【局部】', 0, '', NULL, 0, 0, NULL, NULL),
	(907, 4, 33, 4, 5, '在数据管理中，【】一直是影响系统性能的大问题。', '', '', '', '【数据冗余】', 0, '', NULL, 0, 0, NULL, NULL),
	(908, 4, 33, 4, 5, '在一个关系R中，若每个数据项都是不可再分的原子项，那么R属于【】。', '', '', '', '【1NF】', 0, '', NULL, 0, 0, NULL, NULL),
	(909, 4, 33, 4, 5, '自然连接要求被连接的两个关系具有【】。', '', '', '', '【一个或多个相同的属性名】', 0, '', NULL, 0, 0, NULL, NULL),
	(910, 4, 33, 4, 5, '在关系R和S自然连接时，把原本应该舍弃的元组放在结果关系中，这种操作称为【】。', '', '', '', '【外连接】', 0, '', NULL, 0, 0, NULL, NULL),
	(911, 4, 33, 4, 5, '若D1={a1,a2,a3}，D2={1,2,3}，则D1×D2集合共有元组 【】个。', '', '', '', '【9】', 0, '', NULL, 0, 0, NULL, NULL),
	(912, 4, 33, 4, 5, '关系代数中基本操作是并、差、笛卡尔积、投影和选择，没有集合的【】操作，因而关系代数运算总是安全的。', '', '', '', '【补】', 0, '', NULL, 0, 0, NULL, NULL),
	(913, 4, 33, 4, 5, '数据库的数据完整性指数据库中的正确性、【】 、一致性。', '', '', '', '【相容性】', 0, '', NULL, 0, 0, NULL, NULL),
	(914, 4, 33, 4, 5, '引起数据不一致的根源是【】。', '', '', '', '【数据冗余】', 0, '', NULL, 0, 0, NULL, NULL),
	(915, 4, 33, 4, 5, '元组中的一个属性值，称为【】。', '', '', '', '【分量】', 0, '', NULL, 0, 0, NULL, NULL),
	(916, 4, 34, 2, 5, '在E-R模型中，如果有5个不同实体集，有6个不同的二元联系，其中2个1:N联系，2个1:1联系，2个M:N联系，根据E-R模型转换成关系模型的规则，转换成关系的数目（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"9";i:1;s:2:"11";i:2;s:1:"5";i:3;s:1:"7";i:4;N;i:5;N;}', NULL),
	(917, 4, 34, 2, 5, '数据流图是在数据库           阶段完成的。（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"物理设计";i:1;s:12:"逻辑设计";i:2;s:12:"概念设计";i:3;s:12:"需求分析";i:4;N;i:5;N;}', NULL),
	(918, 4, 34, 2, 5, '在数据库设计中，弱实体是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"属性只有一个的实体";i:1;s:27:"不存在关键码的实体";i:2;s:30:"只能短时期存在的实体";i:3;s:45:"以其他实体存在为先决条件的实体";i:4;N;i:5;N;}', NULL),
	(919, 4, 34, 2, 5, '从E一R模型向关系数据模型转换要遵循一定的规则，下面四项中不是这种转换所要求的规则是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"一个实体类型转换成一个关系模型";i:1;s:45:"一个联系类型转换成一个关系模式";i:2;s:79:"对于M:N联系来说,转换成的关系的键为诸相关实体的键的组合";i:3;s:64:"对于1:N联系来说,转换成的关系的键为N+1实体的键";i:4;N;i:5;N;}', NULL),
	(920, 4, 34, 2, 5, '设计应用程序与数据库的接口，是在数据库设计的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"需求分析阶段";i:1;s:18:"概念设计阶段";i:2;s:18:"逻辑设计阶段";i:3;s:18:"物理设计阶段";i:4;N;i:5;N;}', NULL),
	(921, 4, 34, 2, 5, '在ER模型中，如果有6个不同实体集，有7个不同的二元联系，其中2个1:N联系，2个1:1联系，3个M:N联系，根据ER模型转换成关系模型的规则，转换成关系的数目是（    ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"6";i:1;s:1:"9";i:2;s:2:"11";i:3;s:2:"13";i:4;N;i:5;N;}', NULL),
	(922, 4, 34, 2, 5, '不属于数据库分析与设计阶段的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"修改";i:1;s:12:"需求分析";i:2;s:12:"概念设计";i:3;s:12:"物理设计";i:4;N;i:5;N;}', NULL),
	(923, 4, 34, 2, 5, '分析阶段规范设计方法遵循（   ）的原则。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"自上而下";i:1;s:12:"反复修改";i:2;s:27:"自顶向下、逐步求精";i:3;s:12:"反复设计";i:4;N;i:5;N;}', NULL),
	(924, 4, 34, 2, 5, '概念设计、逻辑设计、物理设计、数据库建立与维护的依据是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"确定数据范围";i:1;s:18:"应用过程分析";i:2;s:21:"收集与分析数据";i:3;s:18:"需求分析报告";i:4;N;i:5;N;}', NULL),
	(925, 4, 34, 2, 5, '（   ）是指了解并分析数据与数据处理间的关系。', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"收集与分析数据";i:1;s:18:"应用过程分析";i:2;s:21:"确定数据库范围";i:3;s:24:"编写需求分析报告";i:4;N;i:5;N;}', NULL),
	(926, 4, 34, 2, 5, '（   ）是指针对各种不同类数据，谁拥有操作（存、取、删、改）的不同授权。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"数据的安全保密性";i:1;s:18:"数据的完整性";i:2;s:12:"响应时间";i:3;s:12:"数据恢复";i:4;N;i:5;N;}', NULL),
	(927, 4, 34, 2, 5, '（   ）提供了对各类数据描述的集中管理，是一种数据分析、系统设计和管理的有力工具。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据字典";i:1;s:9:"数据量";i:2;s:12:"数据约束";i:3;s:15:"任务分类表";i:4;N;i:5;N;}', NULL),
	(928, 4, 34, 2, 5, '（   ）的目标是将概念模型转换为等价的、并为特定DBMS所支持数据模型的结构。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"概念结构设计";i:1;s:12:"需求分析";i:2;s:18:"逻辑结构设计";i:3;s:12:"物理设计";i:4;N;i:5;N;}', NULL),
	(929, 4, 34, 2, 5, '（   ）是指将概念模型等价地转换为特定DBMS支持的关系模型、网状模型或层次模型表示。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"模型转换";i:1;s:12:"设计评价";i:2;s:15:"子模式设计";i:3;s:18:"编制应用程序";i:4;N;i:5;N;}', NULL),
	(930, 4, 34, 2, 5, '（  ）的目标是抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构。', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"设计评价";i:1;s:12:"物理设计";i:2;s:15:"数据库实施";i:3;s:15:"子模式设计";i:4;N;i:5;N;}', NULL),
	(931, 4, 34, 2, 5, '（  ）标志着数据库设计和应用开发的基本完成。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"数据库系统投入实际运行";i:1;s:15:"数据库维护";i:2;s:18:"逻辑结构设计";i:3;s:18:"概念结构设计";i:4;N;i:5;N;}', NULL),
	(932, 4, 34, 2, 5, '关系数据库的概念结构设计中，概念模型的描述工具使用（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"SQL Server";i:1;s:5:"MySQL";i:2;s:6:"E-R图";i:3;s:12:"数据流图";i:4;N;i:5;N;}', NULL),
	(933, 4, 35, 2, 5, '现要查找缺少成绩(G)的学生学号(Sno)和课程号(Cno)，下面SQL语句中WHERE子句的条件表达式应（   ）SELECT   Sno，CNOFROM  SCWHERE', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"G<=0";i:1;s:3:"G=0";i:2;s:9:"G IS NULL";i:3;s:4:"NULL";i:4;N;i:5;N;}', NULL),
	(934, 4, 35, 2, 5, '在 SELECT语句中使用MIN(列名)时，该“列名”应该（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"必须是数值型或字符型";i:1;s:21:"不限制数据类型";i:2;s:18:"必须是数值型";i:3;s:18:"必须是字符型";i:4;N;i:5;N;}', NULL),
	(935, 4, 35, 2, 5, 'SQL中，聚合函数 COUNT（列名）用于（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"计算元组个数";i:1;s:21:"计算属性的个数";i:2;s:36:"计算一列中的非空值的个数";i:3;s:45:"计算一列中的非空值和空值的个数";i:4;N;i:5;N;}', NULL),
	(936, 4, 35, 2, 5, 'SQL中，与“ NOT IN”等价的操作符是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"<>SOME";i:1;s:5:"#REF!";i:2;s:6:"< >ALL";i:3;s:5:"#REF!";i:4;N;i:5;N;}', NULL),
	(937, 4, 35, 2, 5, '现要查找缺少成绩（G）的学生学号（S#）和课程号（C#），下面SQL语句中 WHERE子句的条件表达式应是（   ）SELECT   Sno，CNOFROM  SCWHERE', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"G=0";i:1;s:4:"G<=0";i:2;s:9:"G IS NULL";i:3;s:4:"NULL";i:4;N;i:5;N;}', NULL),
	(938, 4, 35, 2, 5, '在 SELECT语句中，使用MAX（列名）时，该“列名”应该（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"必须是数值型";i:1;s:18:"必须是字符型";i:2;s:30:"必须是数值型或字符型";i:3;s:21:"不限制数据类型";i:4;N;i:5;N;}', NULL),
	(939, 4, 35, 2, 5, '检索选修课程号为“D3”的学生中成绩最高的学生的学号，正确的 SELECT语句是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:" SELECT S#\nFROM SC\nWHERE C#=’D3’ AND GRADE>=";i:1;s:94:"SELECT S#\nFROM SC\nWHERE C#=’D3’ AND GRADE IN\n（SELECT GRADE FROM SC\nWHERE C#=’D3’）;";i:2;s:92:"SELECT S#\nFROM SC\nWHERE C#=D3 AND GRADE NOT IN\n（SELECT GRADE FROM SC\nWHERE C#=’D3’）;";i:3;s:96:"SELECT S#\nFROM SC\nWHERE C#=’D3’ AND GRADE>=ALL\n（SELECT GRADE FROM SC\nWHERE C#=’D3’）;";i:4;N;i:5;N;}', NULL),
	(940, 4, 35, 2, 5, 'SQL是在（   ）由Boyce和Chamberlin提出的。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"1945年";i:1;s:7:"1946年";i:2;s:7:"1974年";i:3;s:7:"1975年";i:4;N;i:5;N;}', NULL),
	(941, 4, 35, 2, 5, '数据控制语言包括的主要SQL语句有（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:14:"CREATE和GRANT";i:1;s:14:"UPDATE和GRANT";i:2;s:15:"INSERT和REVOKE";i:3;s:14:"REVOKE和GRANT";i:4;N;i:5;N;}', NULL),
	(942, 4, 35, 2, 5, '下列关于MySQL的说法中，错误的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:44:"MySQL是一个层次型数据库管理系统";i:1;s:39:"MySQL具有客户/服务器体系结构";i:2;s:34:"MySQL由瑞典MySQL AB公司开发";i:3;s:95:"许多中、小型网站为了降低网站总体拥有成本而选择MySQL作为网站数据库";i:4;N;i:5;N;}', NULL),
	(943, 4, 35, 2, 5, '使用MySQL数据库管理系统构建各种信息管理系统或互联网网站的应用环境，采用LAMP构架方式时，作为服务器端脚本解释器的语言不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"Python";i:1;s:6:"Pascal";i:2;s:4:"Perl";i:3;s:3:"PHP";i:4;N;i:5;N;}', NULL),
	(944, 4, 35, 2, 5, '下列关于MySQL中的常量的说法中，错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"字符串常量分为ASCII字符串常量和Unicode字符串常量";i:1;s:54:"数值常量可以分为整数常量和浮点数常量";i:2;s:87:"日期时间常量是用双引号将表示日期时间的字符串括起来而构成的";i:3;s:60:"布尔值只包含两个可能的值，分别是TRUE和FALSE";i:4;N;i:5;N;}', NULL),
	(945, 4, 35, 2, 5, '下列关于MySQL中的变量的说法中，错误的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"变量中的数据可以随着程序的运行而变化";i:1;s:57:"变量有名字、数据类型和取值范围三个属性";i:2;s:84:"变量的数据类型用于确定变量中存储数值的格式和可执行的运算";i:3;s:33:"变量的名字用于标识变量";i:4;N;i:5;N;}', NULL),
	(946, 4, 35, 2, 5, '在MySQL中使用用户变量时，应在该变量前添加一个（   ）符号。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"@";i:1;s:1:"#";i:2;s:1:"*";i:3;s:1:"%";i:4;N;i:5;N;}', NULL),
	(947, 4, 35, 2, 5, '下列关于索引的说法中，错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"索引是提高数据文件访问效率的有效方法";i:1;s:36:"索引是以文件的形式存储的";i:2;s:39:"创建索引会提高更新表的速度";i:3;s:75:"目前，索引技术已经在各种数据库系统中得到了广泛应用";i:4;N;i:5;N;}', NULL),
	(948, 4, 35, 2, 5, '索引在逻辑上通常包含三类，不包括（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"普通索引";i:1;s:15:"唯一性索引";i:2;s:12:"双重索引";i:3;s:6:"主键";i:4;N;i:5;N;}', NULL),
	(949, 4, 35, 2, 5, '在多表连接查询中，各个表之间的连接方式不包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"交叉连接";i:1;s:9:"内连接";i:2;s:9:"外连接";i:3;s:12:"树状连接";i:4;N;i:5;N;}', NULL),
	(950, 4, 35, 2, 5, '（   ）返回的结果集是一个表。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"表子查询";i:1;s:12:"行子查询";i:2;s:12:"列子查询";i:3;s:15:"标量子查询";i:4;N;i:5;N;}', NULL),
	(951, 4, 35, 2, 5, '下列关于视图的说法中，错误的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"视图是数据库中真实的表";i:1;s:84:"视图的内容是由存储在数据库中进行查询操作的SQL语句来定义的";i:2;s:81:"视图是从一个或多个表或者其他视图中通过查询语句导出的表";i:3;s:87:"视图包含一系列带有名称的数据列和若干数据，并有自己的视图名";i:4;N;i:5;N;}', NULL),
	(952, 4, 35, 2, 5, '使用视图的优点不包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"集中分散数据";i:1;s:18:"简化查询语句";i:2;s:15:"重用SQL语句";i:3;s:18:"独占所需数据";i:4;N;i:5;N;}', NULL),
	(953, 4, 35, 2, 5, '将相关数据集中存放的物理存储技术是 （   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"非聚集";i:1;s:6:"聚集";i:2;s:6:"授权";i:3;s:6:"回收";i:4;N;i:5;N;}', NULL),
	(954, 4, 35, 2, 5, '颁布SQL3的年份是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"1986年";i:1;s:7:"1987年";i:2;s:7:"1989年";i:3;s:7:"1999年";i:4;N;i:5;N;}', NULL),
	(955, 4, 35, 2, 5, '在MySQL中，用于实现交叉连接的关键字是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"CROSS JOIN";i:1;s:10:"INNER JOIN";i:2;s:4:"JOIN";i:3;s:10:"LEFT  JOIN";i:4;N;i:5;N;}', NULL),
	(956, 4, 35, 2, 5, '可以独立地删除完整性约束，而不会删除表的语句是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"ALTERTABLE";i:1;s:9:"DROPTABLE";i:2;s:11:"CHECK TABLE";i:3;s:9:"DELEALTER";i:4;N;i:5;N;}', NULL),
	(957, 4, 35, 4, 5, 'MySQL数据库所支持的SQL主要包含【】、【】、【】和 MySQL扩展增加的语言要素几个部分。', '', '', '', '【DDL】【DML】【DCL】', 0, '', NULL, 0, 0, NULL, NULL),
	(958, 4, 35, 4, 5, '在 MySQL中,通常使用值【】来表示一个列值没有值或缺值的情形。', '', '', '', '【NULL】', 0, '', NULL, 0, 0, NULL, NULL),
	(959, 4, 35, 4, 5, '在CREATE TABLE语句中,通常使用关键字【】来指定主键。', '', '', '', '【PRIMARY KEY】', 0, '', NULL, 0, 0, NULL, NULL),
	(960, 4, 35, 4, 5, '视图是一种虚表，它是从【】导出的表。', '', '', '', '【基本表】', 0, '', NULL, 0, 0, NULL, NULL),
	(961, 4, 35, 4, 5, 'SELECT语句进行查询时，如果要列出所查表中的所有列，则简便方法是将列名表用表示【】。', '', '', '', '【*】', 0, '', NULL, 0, 0, NULL, NULL),
	(962, 4, 35, 4, 5, 'SQL中表结构的修改命令是【】。', '', '', '', '【ALTER TABLE】', 0, '', NULL, 0, 0, NULL, NULL),
	(963, 4, 35, 4, 5, '在 SELECT语句中，HAVING子句必须跟在【】子句后面。', '', '', '', '【Group by】', 0, '', NULL, 0, 0, NULL, NULL),
	(964, 4, 35, 4, 5, 'SQL语言的条件表达式中字符串匹配操作符是【】。', '', '', '', '【LIKE】', 0, '', NULL, 0, 0, NULL, NULL),
	(965, 4, 35, 4, 5, '在创建视图时,把视图的定义存放在【】中，而不存储视图对应的数据。', '', '', '', '【数据字典】', 0, '', NULL, 0, 0, NULL, NULL),
	(966, 4, 35, 4, 5, '在SQL语言中修改数据的命令是 【】。', '', '', '', '【UPDATE】', 0, '', NULL, 0, 0, NULL, NULL),
	(967, 4, 35, 4, 5, 'SQL数据库中表的三种类型有【】、视图和导出表。', '', '', '', '【基本表】', 0, '', NULL, 0, 0, NULL, NULL),
	(968, 4, 35, 4, 5, '在MySQL中，给局部变量赋值的语句是【】。', '', '', '', '【SET】', 0, '', NULL, 0, 0, NULL, NULL),
	(969, 4, 36, 2, 5, '使用存储过程的好处不包括（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"可增强SQL语言的功能和灵活性";i:1;s:18:"良好的继承性";i:2;s:9:"高性能";i:3;s:21:"可减少网络流量";i:4;N;i:5;N;}', NULL),
	(970, 4, 36, 2, 5, '在创建存储过程时，存储过程体中可能包含有多SQL语句，这些SQL语句默认以(  )作为语句结束符。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"分号";i:1;s:6:"逗号";i:2;s:6:"句号";i:3;s:6:"冒号";i:4;N;i:5;N;}', NULL),
	(971, 4, 36, 2, 5, '在创建存储过程时常用的条件判断语句有（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:19:"I...THEN-ELSE语句";i:1;s:12:"REPEAT语句";i:2;s:10:"LOOP语句";i:3;s:11:"WHILE语句";i:4;N;i:5;N;}', NULL),
	(972, 4, 36, 2, 5, '在创建存储过程时,常用的循环语句不包括  (  )', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"WHILE语句";i:1;s:12:"REPEAT语句";i:2;s:10:"LOOP语句";i:3;s:10:"WHEN语句";i:4;N;i:5;N;}', NULL),
	(973, 4, 36, 2, 5, '下列关于游标的说法中,错误的是  (  )', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"在能够使用游标之前,必须先声明(定义)它";i:1;s:60:"在定义游标之后，必须打开该游标，才能使用";i:2;s:54:"在实际应用中，一个游标只能被打开一次";i:3;s:85:"用DECLARE语句定义的局部变量必须在定义任意游标或句柄之前定义";i:4;N;i:5;N;}', NULL),
	(974, 4, 36, 2, 5, '在使用游标的过程中,需要注意的事项不包括（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"游标只能用于存储过程或存储函数";i:1;s:71:"在一个BEGINEND语句块中每一个游标的名字必须是唯一的";i:2;s:42:"游标必须单独在查询操作中使用";i:3;s:30:"游标不是一条SELECT语句";i:4;N;i:5;N;}', NULL),
	(975, 4, 36, 2, 5, '下列关于存储函数与存储过程的说法，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:96:"存储函数与存储过程一样，都是由SQL语句和过程式语句所组成的代码片断";i:1;s:66:"存储函数与存储过程一样，都可以被应用程序使用";i:2;s:69:"存储函数与存储过程一样，都可以被其他SQL语句调用";i:3;s:63:"存储函数与存储过程一样，都可以拥有输出参数";i:4;N;i:5;N;}', NULL),
	(976, 4, 36, 2, 5, '【2018年10月】对于使用存储过程的好处说法错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"可增强SQL语言的功能";i:1;s:30:"可增强SQL语言的灵活性";i:2;s:24:"具有良好的封装性";i:3;s:18:"系统运行稳定";i:4;N;i:5;N;}', NULL),
	(977, 4, 36, 4, 5, '在MySQL中，可以使用【】语句创建游标。', '', '', '', '【DECLARE CURSOR】', 0, '', NULL, 0, 0, NULL, NULL),
	(978, 4, 36, 4, 5, '在MySQL中，可以使用【】 语句打开游标。', '', '', '', '【OPEN】', 0, '', NULL, 0, 0, NULL, NULL),
	(979, 4, 36, 4, 5, '在MySQL中，可以使用【】语句关闭游标。', '', '', '', '【CLOSE】', 0, '', NULL, 0, 0, NULL, NULL),
	(980, 4, 36, 4, 5, '创建好存储过程后，可以使用【】语句在程序或者其他存储过程中调用它。', '', '', '', '【CALL】', 0, '', NULL, 0, 0, NULL, NULL),
	(981, 4, 36, 4, 5, '存储函数中必须包含一条【】 语句。', '', '', '', '【RETURN】', 0, '', NULL, 0, 0, NULL, NULL),
	(982, 4, 36, 4, 5, '在MySQL中，可以使用【】 语句创建存储函数。', '', '', '', '【CREATE FUNCTION】', 0, '', NULL, 0, 0, NULL, NULL),
	(983, 4, 36, 4, 5, '在MySQL中，变量名称前常添加一令“@”符号的是【】变量。', '', '', '', '【用户】', 0, '', NULL, 0, 0, NULL, NULL),
	(984, 4, 37, 2, 5, '事务( transaction)是一个（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"程序";i:1;s:6:"进程";i:2;s:12:"操作序列";i:3;s:15:"完整性规则";i:4;N;i:5;N;}', NULL),
	(985, 4, 37, 2, 5, '在第一个事务以S封锁方式读数据M时，第二个事务对数据M的读方式会遭到失败的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"实现共享型封锁的读";i:1;s:18:"不加封锁的读";i:2;s:19:"实现S封锁的读";i:3;s:19:"实现X封锁的读";i:4;N;i:5;N;}', NULL),
	(986, 4, 37, 2, 5, '事务的并发执行不会破坏数据库的完整性，这个性质称为事务的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"持久化";i:1;s:9:"隔离性";i:2;s:9:"一致性";i:3;s:9:"原子性";i:4;N;i:5;N;}', NULL),
	(987, 4, 37, 2, 5, '恢复数据库的主要依据是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"文档";i:1;s:12:"事务目志";i:2;s:3:"DBA";i:3;s:2:"DD";i:4;N;i:5;N;}', NULL),
	(988, 4, 37, 2, 5, '如果n个事务并发调度，那么可能的并发调度数目（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"为n";i:1;s:5:"为4n";i:2;s:5:"为n!";i:3;s:8:"大于n!";i:4;N;i:5;N;}', NULL),
	(989, 4, 37, 2, 5, '允许用户 Zhang对 Score表的内容进行修改，正确的授权语句是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"GRANT UPDATE TO TABLE Score ON Zhang";i:1;s:30:"GRANT UPDATE TO Score ON Zhang";i:2;s:36:"GRANT UPDATE ON TABLE Score TO Zhang";i:3;s:30:"GRANT UPDATE ON Score TO Zhang";i:4;N;i:5;N;}', NULL),
	(990, 4, 37, 2, 5, '数据库管理系统通常提供授权功能来控制不同用户访问数据的权限，这主要是为了实现数据库的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"可靠性";i:1;s:9:"一致性";i:2;s:9:"完整性";i:3;s:9:"安全性";i:4;N;i:5;N;}', NULL),
	(991, 4, 37, 2, 5, '设关系R和S的结构相同，并且各有80个元组，假如这两个关系做交运算，其运算结果的元组个数为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:"80";i:1;s:14:"小于等于80";i:2;s:15:"大于等于160";i:3;s:32:"大于等于80，小于等于160";i:4;N;i:5;N;}', NULL),
	(992, 4, 37, 2, 5, '在下列几种故障中，不破坏数据库内容的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"计算机病毒发作";i:1;s:18:"供电系统故障";i:2;s:24:"瞬时的强磁场干扰";i:3;s:18:"磁盘介质损坏";i:4;N;i:5;N;}', NULL),
	(993, 4, 37, 2, 5, '要使数据库具有可恢复性，典型策略是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"加强机房安全管理";i:1;s:21:"安装防病毒设施";i:2;s:27:"经常检修计算机系统";i:3;s:27:"数据转储和建立日志";i:4;N;i:5;N;}', NULL),
	(994, 4, 37, 2, 5, '如果事务T获得了数据项Q上的排他锁，则T对Q（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"只能读不能写";i:1;s:18:"只能写不能读";i:2;s:18:"既可读又可写";i:3;s:18:"不能读不能写";i:4;N;i:5;N;}', NULL),
	(995, 4, 37, 2, 5, '“断言”是DBS采用的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"完整性措施";i:1;s:15:"安全性措施";i:2;s:12:"恢复措施";i:3;s:18:"并发控制措施";i:4;N;i:5;N;}', NULL),
	(996, 4, 37, 2, 5, '事务日志用于保存（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"对数据的更新操作";i:1;s:12:"数据操作";i:2;s:21:"程序的执行结果";i:3;s:18:"程序运行过程";i:4;N;i:5;N;}', NULL),
	(997, 4, 37, 2, 5, '数据库恢复的主要依据是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"DBA";i:1;s:2:"DD";i:2;s:6:"文档";i:3;s:12:"事务日志";i:4;N;i:5;N;}', NULL),
	(998, 4, 37, 2, 5, 'MySQL支持的用户自定义完整性约束不包括（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"非空约束";i:1;s:11:"CHECK约束";i:2;s:9:"触发器";i:3;s:6:"视图";i:4;N;i:5;N;}', NULL),
	(999, 4, 37, 2, 5, '可用于收回权限的SQL语句是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"GRANT";i:1;s:4:"ROLL";i:2;s:6:"REVOKE";i:3;s:6:"RETURN";i:4;N;i:5;N;}', NULL),
	(1000, 4, 37, 2, 5, '在触发器的创建中，每个表每个事件每次只允许一个触发器，因此每个表最多支持的触发器是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"1个";i:1;s:4:"3个";i:2;s:4:"6个";i:3;s:4:"8个";i:4;N;i:5;N;}', NULL),
	(1001, 4, 37, 2, 5, '用于删除一个或多个MySQL账户，并消除其权限的语句是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"DROP USERS";i:1;s:9:"DROP USER";i:2;s:11:"ALTER USERS";i:3;s:10:"ALTER USER";i:4;N;i:5;N;}', NULL),
	(1002, 4, 37, 4, 5, 'MSQL支持关系模型中 【】 , 【】 和 【】三种不同的完整性约束。', '', '', '', '【实体】【参考】【用户定义】', 0, '', NULL, 0, 0, NULL, NULL),
	(1003, 4, 37, 4, 5, '在 MySQL中,可以使用【】语句来为指定数据库添加用户。', '', '', '', '【CREATE USER】', 0, '', NULL, 0, 0, NULL, NULL),
	(1004, 4, 37, 4, 5, '在 MySQL中,可以使用【】语句来实现权限的撤销。', '', '', '', '【REVOKE】', 0, '', NULL, 0, 0, NULL, NULL),
	(1005, 4, 37, 4, 5, '数据库并发操作带来的三个问题是：丢失更新问题、读脏数据问题和【】。', '', '', '', '【不可重复读问题】', 0, '', NULL, 0, 0, NULL, NULL),
	(1006, 4, 37, 4, 5, '触发器的动作事件条件用【】子句定义，它可以是任意的条件表达式。', '', '', '', '【WHEN】', 0, '', NULL, 0, 0, NULL, NULL),
	(1007, 4, 37, 4, 5, '在多个事务并发执行时，系统应保证与这些事务先后单独执行时的结果一样，这是指事务的【】性。', '', '', '', '【隔离】', 0, '', NULL, 0, 0, NULL, NULL),
	(1008, 4, 37, 4, 5, '封锁对象的大小称为【】。', '', '', '', '【封锁的粒度】', 0, '', NULL, 0, 0, NULL, NULL),
	(1009, 4, 37, 4, 5, 'DBS中用于安全性目的的数据库日志称为【】。', '', '', '', '【审计追踪】', 0, '', NULL, 0, 0, NULL, NULL),
	(1010, 4, 37, 4, 5, '封锁可以避免并发操作引起的错误，但可能产生 【】、饿死、死锁等问题。', '', '', '', '【活锁】', 0, '', NULL, 0, 0, NULL, NULL),
	(1011, 4, 37, 4, 5, '当多个事务交错执行时，可能出现不一致问题，这也称为【】问题。', '', '', '', '【并发操作】', 0, '', NULL, 0, 0, NULL, NULL),
	(1012, 4, 37, 4, 5, '通常以【】来描述封锁的数据单元的大小。', '', '', '', '【粒度】', 0, '', NULL, 0, 0, NULL, NULL),
	(1013, 4, 37, 4, 5, '在并发事务处理过程中，由于锁会使一事务处于等待状态而调度其他事务处理，因而该事务可能会优先低而永远等待下去，这种现象称为【】。', '', '', '', '【活锁】', 0, '', NULL, 0, 0, NULL, NULL),
	(1014, 4, 37, 4, 5, '【】是指通过导出数据或者复制表文件的方式来制作数据库的复本。', '', '', '', '【数据库备份】', 0, '', NULL, 0, 0, NULL, NULL),
	(1015, 4, 37, 4, 5, '封锁带来的一个重要问题是可能引起“活锁”与“【】”。', '', '', '', '【死锁】', 0, '', NULL, 0, 0, NULL, NULL),
	(1016, 4, 37, 4, 5, '数据库恢复是以备份为基础的，它是与备份相对应的【】和管理操作。', '', '', '', '【系统维护】', 0, '', NULL, 0, 0, NULL, NULL),
	(1017, 4, 37, 4, 5, '通过使用MySQL数据库的【】命令，创建数据库。', '', '', '', '【CREATE  DATABASE】', 0, '', NULL, 0, 0, NULL, NULL),
	(1018, 4, 38, 2, 5, '下列属于第二代数据库系统的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"层次数据库系统";i:1;s:21:"网状数据库系统";i:2;s:21:"关系数据库系统";i:3;s:27:"面向对象数据库系统";i:4;N;i:5;N;}', NULL),
	(1019, 4, 38, 2, 5, '关系模型的组成不包括（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据结构";i:1;s:12:"关系操作";i:2;s:15:"数据完整性";i:3;s:15:"数据一致性";i:4;N;i:5;N;}', NULL),
	(1020, 4, 38, 2, 5, '数据库技术与人工智能技术相结合出现的数据库系统不包括（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"演绎数据库";i:1;s:9:"知识库";i:2;s:21:"主动数据库系统";i:3;s:24:"多媒体数据库系统";i:4;N;i:5;N;}', NULL),
	(1021, 4, 38, 2, 5, '（  ）是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中发现并提取隐藏在其中的、人们事先不知道的、但又是潜在有用的信息和知识的一种技术。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据挖掘";i:1;s:12:"数据仓库";i:2;s:12:"数据分析";i:3;s:12:"数据整理";i:4;N;i:5;N;}', NULL),
	(1022, 4, 38, 2, 5, '在数据库技术中，数据处理基于（  ）, 可以发现有用的信息。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"更新";i:1;s:6:"视图";i:2;s:6:"查询";i:3;s:3:"表";i:4;N;i:5;N;}', NULL),
	(1023, 4, 38, 2, 5, '若两个或多个变量的取值之间存在某种规律性，就称为（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"关联";i:1;s:6:"联系";i:2;s:6:"连接";i:3;s:18:"以上均不正确";i:4;N;i:5;N;}', NULL),
	(1024, 4, 38, 2, 5, '下列属于聚类算法的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"Apriori";i:1;s:3:"GMM";i:2;s:5:"Redis";i:3;s:5:"HBase";i:4;N;i:5;N;}', NULL),
	(1025, 4, 38, 2, 5, '目前大数据尚无统一的定义，通常被认为是数据量很大、数据形式多样化的数据。例如，EMC公司认为“大”是指大型数据集，一般在（  ）规模左右。', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"1TB";i:1;s:4:"10TB";i:2;s:5:"100TB";i:3;s:6:"1000TB";i:4;N;i:5;N;}', NULL),
	(1026, 4, 38, 2, 5, '下列属于键值存储数据库的是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"Redis";i:1;s:7:"CouchDB";i:2;s:5:"HBase";i:3;s:9:"Cassandra";i:4;N;i:5;N;}', NULL),
	(1027, 4, 38, 2, 5, 'MapReduce是一种（  ）编程模型。', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"串行";i:1;s:6:"并行";i:2;s:15:"串行或并行";i:3;s:6:"混合";i:4;N;i:5;N;}', NULL),
	(1028, 4, 38, 2, 5, '在图存储数据库中,（  ）用来连接结点。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"结点";i:1;s:6:"属性";i:2;s:3:"边";i:3;s:6:"联系";i:4;N;i:5;N;}', NULL),
	(1029, 4, 38, 2, 5, '【2018年10月】把数据按照相似性归纳成若干类别的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"概念描述";i:1;s:12:"关联分析";i:2;s:6:"分类";i:3;s:6:"聚类";i:4;N;i:5;N;}', NULL),
	(1030, 4, 38, 2, 5, '【2018年10月】数据库技术与人工智能技术相结合出现的数据库系统是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"分布式数据库系统";i:1;s:21:"并行数据库系统";i:2;s:21:"主动数据库系统";i:3;s:21:"移动数据库系统";i:4;N;i:5;N;}', NULL),
	(1031, 4, 38, 4, 5, '【】是计算机信息系统和智能应用系统的核心技术和重要基础。', '', '', '', '【数据库技术】', 0, '', NULL, 0, 0, NULL, NULL),
	(1032, 4, 38, 4, 5, '第三代数据库系统应支持数据管理、【】和知识管理。', '', '', '', '【对象管理】', 0, '', NULL, 0, 0, NULL, NULL),
	(1033, 4, 38, 4, 5, '数据库技术与多媒体技术相结合出现了【】。', '', '', '', '【多媒体数据库系统】', 0, '', NULL, 0, 0, NULL, NULL),
	(1034, 4, 38, 4, 5, '计算机系统中存在着两类不同的数据处理工作：一类是联机事务处理（OLTP），另一类是【】 。', '', '', '', '【[\'联机分析处理\', \'或OLAP\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1035, 4, 38, 4, 5, '数据仓库中的数据是按照各种【】来组织的。', '', '', '', '【主题】', 0, '', NULL, 0, 0, NULL, NULL),
	(1036, 4, 38, 4, 5, '【】 是人们观察数据的特定角度，是考虑问题时的一类属性。', '', '', '', '【维】', 0, '', NULL, 0, 0, NULL, NULL),
	(1037, 4, 38, 4, 5, '在数据挖掘技术中，基于【】的挖掘是应用较广的一种方法。', '', '', '', '【关联规则】', 0, '', NULL, 0, 0, NULL, NULL),
	(1038, 4, 38, 4, 5, 'IBM把大数据概括为4个V，即大量化（Volume）、【】、快速化（Velocity）和真实性（Verity）。', '', '', '', '【[\'多样化\', \'Variety\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1039, 4, 38, 4, 5, 'HDFS以大【】 数据块的方式存储文件。', '', '', '', '【粒度】', 0, '', NULL, 0, 0, NULL, NULL),
	(1040, 4, 38, 4, 5, 'MapReduce把计算过程分解为两个阶段：【】阶段和Reduce阶段。', '', '', '', '【Map】', 0, '', NULL, 0, 0, NULL, NULL),
	(1041, 4, 38, 4, 5, '【2018年10月】数据仓库具有三个常用的重要概念，即粒度、分割和 【】。', '', '', '', '【维】', 0, '', NULL, 0, 0, NULL, NULL),
	(1042, 4, 39, 2, 5, '数据库系统中，执行逻辑数据与物理数据之间转换功能的是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:2:"DB";i:1;s:4:"DBMS";i:2;s:3:"DBS";i:3;s:2:"OS";i:4;N;i:5;N;}', NULL),
	(1043, 4, 39, 2, 5, 'DBMS的数据字典中存放的是（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"数据库三级模式结构的定义";i:1;s:24:"数据库的工作日志";i:2;s:30:"数据库的所有索引信息";i:3;s:24:"数据库的存储路径";i:4;N;i:5;N;}', NULL),
	(1044, 4, 39, 2, 5, '数据库逻辑设计阶段应考虑的主要因素是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"概念模型";i:1;s:12:"处理要求";i:2;s:12:"存取方法";i:3;s:10:"DBMS特征";i:4;N;i:5;N;}', NULL),
	(1045, 4, 39, 2, 5, '关系数据库系统中对外键没有任何限制的操作是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"插入";i:1;s:6:"删除";i:2;s:6:"修改";i:3;s:9:"置空值";i:4;N;i:5;N;}', NULL),
	(1046, 4, 39, 2, 5, '由于关系模式设计不当所引起的删除异常的是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"应该删除的数据不能删除";i:1;s:51:"未经授权的用户对数据进行了删除操作";i:2;s:36:"数据删除过程中发生了故障";i:3;s:30:"不该删除的数据被删除";i:4;N;i:5;N;}', NULL),
	(1047, 4, 39, 2, 5, '设有关系模式R（ABCDE）,F是R上成立的FD集，F=｛A→B，B→C,D→E｝,那么F在模式ABC上的投影（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:25:"｛A→B，B→C,A→C｝";i:1;s:26:" ｛A→B，B→C,D→E｝";i:2;s:19:"｛A→B，B→C｝";i:3;s:34:"Φ（即不存在非平凡的FD）";i:4;N;i:5;N;}', NULL),
	(1048, 4, 39, 2, 5, '设有学生表STUDENT（学号，姓名，性别，年龄），则向STUDENT表插入一条新记录的正确的SQL语句是（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:65:"APPEND INTO STUDENT VALUES (′d001′,′王明′,′女′,18)";i:1;s:60:"APPEND STUDENT VALUES (′d001′,′王明′,′女′,18)";i:2;s:59:"INSERT STUDENT VALUES(′d001′,′王明′,′女′,18)";i:3;s:64:"INSERT INTO STUDENT VALUES(′d001′,′王明′,′女′,18)";i:4;N;i:5;N;}', NULL),
	(1049, 4, 39, 2, 5, '存储过程的优点不包括（）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"提高运行速度";i:1;s:21:"降低网络通信量";i:2;s:24:"间接实现安全控制";i:3;s:29:"存储在DB之外方便修改";i:4;N;i:5;N;}', NULL),
	(1050, 4, 39, 2, 5, '如果事务T获得了数据项Q上的排他锁，则T对Q（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"只能读不能写";i:1;s:18:"只能写不能读";i:2;s:18:"既可读又可写";i:3;s:21:"不能读也不能写";i:4;N;i:5;N;}', NULL),
	(1051, 4, 39, 2, 5, 'DBMS中实现事务原子性的子系统是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"完整性子系统";i:1;s:21:"并发控制子系统";i:2;s:21:"事务管理子系统";i:3;s:21:"恢复管理子系统";i:4;N;i:5;N;}', NULL),
	(1052, 4, 39, 2, 5, 'SQL Server的身份验证模式包括WINDOWS身份验证模式和（）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"混合验证模式";i:1;s:18:"账号验证模式";i:2;s:18:"用户验证模式";i:3;s:15:"DNA验证模式";i:4;N;i:5;N;}', NULL),
	(1053, 4, 39, 2, 5, 'PowerBuilder 9.0中连接数据库的正确步骤是（）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:61:"建立数据库描述文件；用CONNECT命令连续数据库";i:1;s:83:"建立ODBC数据源；建立数据库描述文件；用CONNECT命令连续数据库";i:2;s:53:"建立ODBC数据源；用CONNECT命令连接数据库";i:3;s:77:"建立ODBC数据源；建立数据库对象；用CONNECT命令连接数据库";i:4;N;i:5;N;}', NULL),
	(1054, 4, 39, 2, 5, '在对象联系图中，表示属性具有多值的是（）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"→";i:1;s:3:"⇒";i:2;s:6:"→→";i:3;s:6:"←→";i:4;N;i:5;N;}', NULL),
	(1055, 4, 39, 4, 5, '数据库在磁盘上的基本组织形式是【】', '', '', '', '【文件】', 0, '', NULL, 0, 0, NULL, NULL),
	(1056, 4, 39, 4, 5, '层次模型中上一层记录类型和下一层记录类型之间的联系是【】联系', '', '', '', '【1：N】', 0, '', NULL, 0, 0, NULL, NULL),
	(1057, 4, 39, 4, 5, 'Arimstrong公理系统的三条推理规则是自反律、增广律和【】', '', '', '', '【传递律】', 0, '', NULL, 0, 0, NULL, NULL),
	(1058, 4, 39, 4, 5, '关系代数表达式的启发式规则有：尽可能早地执行选择操作，尽可能早地执行投影操作和避免直接做【】', '', '', '', '【笛卡尔积】', 0, '', NULL, 0, 0, NULL, NULL),
	(1059, 4, 39, 4, 5, 'SQL语言是介于关系代数和 【】之间的一种语言', '', '', '', '【元组演算】', 0, '', NULL, 0, 0, NULL, NULL),
	(1060, 4, 39, 4, 5, '常见的数据库故障分为：事务故障、系统故障、【】', '', '', '', '【介质故障】', 0, '', NULL, 0, 0, NULL, NULL),
	(1061, 4, 39, 4, 5, '触发器是一个能由系统自动执行对【】修改的语句', '', '', '', '【数据库】', 0, '', NULL, 0, 0, NULL, NULL),
	(1062, 4, 39, 4, 5, 'T-SQL语言中，局部变量由用户定义和维护，名称以【】开头', '', '', '', '【单个@】', 0, '', NULL, 0, 0, NULL, NULL),
	(1063, 4, 39, 4, 5, 'PowerBuilder9.0中，开发空间有三个层次：Workspace(工作空间)、Target（目标）和 【】', '', '', '', '【[\'Library\', \'库文件\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1064, 4, 39, 4, 5, 'UML类图中，聚合表达了成分对象和聚合对象之间的【】的联系', '', '', '', '【[\'“is part of”\', \'一部分\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1065, 4, 40, 2, 5, '造成数据库中的数据不一致的原因是', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据冗余";i:1;s:24:"数据存储数量太大";i:2;s:24:"数据相互关系复杂";i:3;s:21:"数据库安全性差";i:4;N;i:5;N;}', NULL),
	(1066, 4, 40, 2, 5, '逻辑模式/内模式映像，保证了数据库的', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"完整性";i:1;s:9:"安全性";i:2;s:15:"逻辑独立性";i:3;s:15:"物理独立性";i:4;N;i:5;N;}', NULL),
	(1067, 4, 40, 2, 5, '数据库系统生存期中，下面不是需求分析阶段工作的是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"分析用户活动，产生业务流程图";i:1;s:42:"确定系统范例，产生系统关联图";i:2;s:15:"可行性分析";i:3;s:39:"分析系统数据，产生数据字典";i:4;N;i:5;N;}', NULL),
	(1068, 4, 40, 2, 5, '关系数据库的数据与更新必须遵循三类完整性规则，下列不是其中一项的是', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"实体完整性规则";i:1;s:21:"逻辑完整性规则";i:2;s:21:"参照完整性规则";i:3;s:30:"用户定义的完整性规则";i:4;N;i:5;N;}', NULL),
	(1069, 4, 40, 2, 5, '设关系模式R（ABCDE），F是R上成立的FD集，F==｛AB→C，CD→E，DE→B｝，则关系R的候选键是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"A";i:1;s:2:"AB";i:2;s:3:"ABD";i:3;s:3:"ABE";i:4;N;i:5;N;}', NULL),
	(1070, 4, 40, 2, 5, '关于模式分解，下面叙述不正确的是', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"模式分解能消除数据冗余和操作异常现象";i:1;s:57:"在分解以后，所有的检索操作可以节省时间";i:2;s:93:"再分解了的数据库中可以存储悬挂元组，存储泛关系中无法存储的信息";i:3;s:117:"在有泛关系假设时，对数据库中关系进行自然连接时，可能产生寄生元组，即损失了信息";i:4;N;i:5;N;}', NULL),
	(1071, 4, 40, 2, 5, '假设有学生表（学号，姓名，性别，班级，专业），查找英语专业的学生学号、姓名和班级，正确的关系代数表达式是\ni.π学号，姓名，班级（σ专业′英语′（学生表））\nii.σ专业′英语′(π学号，姓名，班级（学生表））\niii.π学号，姓名，班级（σ专业′英语′(π学号，姓名，班级,专业（学生表））', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"i和iii";i:1;s:13:"只要i正确";i:2;s:14:"只有ii正确";i:3;s:6:"i和ii";i:4;N;i:5;N;}', NULL),
	(1072, 4, 40, 2, 5, '若关系R和S的i至接运算结果中能够保留不满足连接条件的元组，该连接为', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"自然连接";i:1;s:12:"条件连接";i:2;s:9:"外连接";i:3;s:12:"交叉连接";i:4;N;i:5;N;}', NULL),
	(1073, 4, 40, 2, 5, '下列聚合函数中，不忽略空值的是', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"AVG";i:1;s:5:"COUNT";i:2;s:3:"SUM";i:3;s:3:"MAX";i:4;N;i:5;N;}', NULL),
	(1074, 4, 40, 2, 5, '关于使用存储过程的说法错误的是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:78:"存储过程会预先编译，执行速度会快于交互执行的SQL的语句";i:1;s:60:"存储过程能完成复杂的逻辑判断和复杂的运算";i:2;s:48:"存储过程中的声明和参数都是可选的";i:3;s:57:"存储过程中可以便用创建数据库对象的语句";i:4;N;i:5;N;}', NULL),
	(1075, 4, 40, 2, 5, '在DB恢复时，对已提交的事务但更新还留在缓冲区的事务应执行', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"REDO处理";i:1;s:10:"UNDO处理";i:2;s:14:"ROLLBACK处理";i:3;s:11:"ABORT处理";i:4;N;i:5;N;}', NULL),
	(1076, 4, 40, 2, 5, '数据的正确性、有效性和相容性，防.tE错误的数据进入数据库是', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"数据库可恢复性";i:1;s:21:"数据库的并发性";i:2;s:21:"数据库的完整性";i:3;s:21:"数据库的安全性";i:4;N;i:5;N;}', NULL),
	(1077, 4, 40, 2, 5, '在SQL Server2000安装时，安装程序会把系统文件存放在启动盘的目录下，存放客户端和服务器可执行文件与DLL文件的是', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"\\BackUp";i:1;s:5:"\\Binn";i:2;s:7:"\\]Books";i:3;s:4:"\\Log";i:4;N;i:5;N;}', NULL),
	(1078, 4, 40, 2, 5, 'PowerBuider9.0中，用于显示对开发人员作出的操作响应的是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"系统树窗口";i:1;s:15:"剪贴板窗口";i:2;s:12:"输出窗口";i:3;s:12:"编辑窗口";i:4;N;i:5;N;}', NULL),
	(1079, 4, 40, 2, 5, '在对象联系图中，表示两个属性之间值的联系为逆联系的是', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"单箭头（→）";i:1;s:21:"双箭头（→→）";i:2;s:21:"双线箭头（⇒）";i:3;s:24:"双向箭头（←→）";i:4;N;i:5;N;}', NULL),
	(1080, 4, 40, 4, 5, 'DBMS总是基于某种数据模型，可以分为层次型、网状型、【】和面向对象型等。', '', '', '', '【关系型】', 0, '', NULL, 0, 0, NULL, NULL),
	(1081, 4, 40, 4, 5, '在数据库运行阶段，对数据库经常性的维护工作主要是由【】完成的', '', '', '', '【数据库管理员】', 0, '', NULL, 0, 0, NULL, NULL),
	(1082, 4, 40, 4, 5, '如果A是关系模式R的候选键的属性，那么A是R是【】属性', '', '', '', '【主】', 0, '', NULL, 0, 0, NULL, NULL),
	(1083, 4, 40, 4, 5, '在元组表达式中，原子公式R（s）,其中R是关系名，S是元组变量，它所表示的命题是【】', '', '', '', '【s是关系R的一个元组】', 0, '', NULL, 0, 0, NULL, NULL),
	(1084, 4, 40, 4, 5, '组成核心SQL的四个部分包括数据定义语言、数据操纵语言、嵌入式SQL语畜的使用规定和【】四个部分', '', '', '', '【数据控制语言】', 0, '', NULL, 0, 0, NULL, NULL),
	(1085, 4, 40, 4, 5, '在多个事务并发执行时，系统应保证与这些事务先后单独执行时的结果一样，此时称事务达到了【】的要求', '', '', '', '【隔离性】', 0, '', NULL, 0, 0, NULL, NULL),
	(1086, 4, 40, 4, 5, '锁是一个与数据项相关的变量，对可能应用于该数据项上的操作而言，锁描述了该数据项的 【】', '', '', '', '【状态】', 0, '', NULL, 0, 0, NULL, NULL),
	(1087, 4, 40, 4, 5, '触发器是SQL Server提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的【】', '', '', '', '【存储过程】', 0, '', NULL, 0, 0, NULL, NULL),
	(1088, 4, 40, 4, 5, 'PB9.0Z中，：1：作空间是开发应用系统的“容器”，用户必须首先建立或【】个工作空间才能进行开发', '', '', '', '【打开】', 0, '', NULL, 0, 0, NULL, NULL),
	(1089, 4, 40, 4, 5, '在UML类图中，关联的端部，也就是与关联相连的类，称为【】', '', '', '', '【关联角色】', 0, '', NULL, 0, 0, NULL, NULL),
	(1090, 4, 41, 2, 5, '下面不属于人工管理阶段数据管理特点的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:30:"数据不保存在计算机内";i:1;s:42:"没有专用的软件对数据进行管理";i:2;s:45:"只有程序的概念，没有文件的概念";i:3;s:18:"数据面向应用";i:4;N;i:5;N;}', NULL),
	(1091, 4, 41, 2, 5, '关于外部模型的描述，叙述不正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"逻辑模型是外部模型的一个逻辑子集";i:1;s:45:"外部模型独立于硬件，依赖于软件";i:2;s:51:"外部模型反映了用户使用数据库的观点";i:3;s:39:"外部模型是对概念模型的支持";i:4;N;i:5;N;}', NULL),
	(1092, 4, 41, 2, 5, '下面不属于数据库逻辑设计阶段任务的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"把概念模型转换成逻辑模型";i:1;s:24:"确定数据存放位置";i:2;s:39:"设计应用程序与数据库的接口";i:3;s:18:"评价逻辑模型";i:4;N;i:5;N;}', NULL),
	(1093, 4, 41, 2, 5, '在关系模型中，对于完整性规则叙述错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:48:"元组在组成主键的属性上不能有空值";i:1;s:78:"外键和相应的主键可以不同名，只要定义在相同值域上即可";i:2;s:48:"外键和主键不可以是同一个关系模式";i:3;s:51:"外键值是否允许空，应视具体问题而定";i:4;N;i:5;N;}', NULL),
	(1094, 4, 41, 2, 5, '下面不属于关系模式设计问题的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"插入异常";i:1;s:12:"删除异常";i:2;s:15:"不可重复读";i:3;s:12:"数据冗余";i:4;N;i:5;N;}', NULL),
	(1095, 4, 41, 2, 5, '如果X   Y，Y   A，且Y不能函数确定X，A Y，那么称X    A是（   ）。', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"平凡函数依赖";i:1;s:12:"传递依赖";i:2;s:12:"局部依赖";i:3;s:12:"完全依赖";i:4;N;i:5;N;}', NULL),
	(1096, 4, 41, 2, 5, '集合R与S的交可以用关系代数的基本运算表示为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"R十(R-S)";i:1;s:7:"R-(R-S)";i:2;s:11:"R一(S—R)";i:3;s:9:"S一(R-S)";i:4;N;i:5;N;}', NULL),
	(1097, 4, 41, 2, 5, '在SQL查询语言中，用于两个子查询执行差操作的运算符是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"EXITS";i:1;s:9:"INTERSECT";i:2;s:6:"EXCEPT";i:3;s:5:"UNION";i:4;N;i:5;N;}', NULL),
	(1098, 4, 41, 2, 5, 'SQL语言中条件“年龄BETWEEN 20 AND 30”表示年龄在20至30之间，且（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:28:"包括30岁但不包括20岁";i:1;s:22:"不包括20岁和30岁";i:2;s:28:"包括20岁但不包括30岁";i:3;s:19:"包括20岁和30岁";i:4;N;i:5;N;}', NULL),
	(1099, 4, 41, 2, 5, 'DBMS中实现事务持久性的子系统是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"事务管理子系统";i:1;s:18:"完整性子系统";i:2;s:21:"并发控制子系统";i:3;s:21:"恢复管理子系统";i:4;N;i:5;N;}', NULL),
	(1100, 4, 41, 2, 5, '下列不属于并发操作带来的问题的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"不可重复读";i:1;s:12:"丢失更新";i:2;s:12:"读脏数据";i:3;s:12:"修改异常";i:4;N;i:5;N;}', NULL),
	(1101, 4, 41, 2, 5, '在SQL Server 2000中，记录了所有SQL Server 2000的系统信息、登录账号、系统配置设置等信息的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"Master数据库";i:1;s:14:"Model数据库";i:2;s:13:"Pubs数据库";i:3;s:15:"Tempdb数据库";i:4;N;i:5;N;}', NULL),
	(1102, 4, 41, 2, 5, 'PowerBuilder 9.0中，用来实现数据库内、数据库之间，甚至不同数据库管理系统之间快速的数据转换的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"数据窗口画板";i:1;s:15:"数据库画板";i:2;s:18:"数据管道画板";i:3;s:12:"查询画板";i:4;N;i:5;N;}', NULL),
	(1103, 4, 41, 2, 5, '在对象联系图中，表示对象类型之间的超类与子类联系（从子类指向超类）的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"→";i:1;s:6:"→→";i:2;s:3:"←";i:3;s:3:"⇒";i:4;N;i:5;N;}', NULL),
	(1104, 4, 41, 4, 5, '数据库系统的英文缩写是【】。', '', '', '', '【DBS】', 0, '', NULL, 0, 0, NULL, NULL),
	(1105, 4, 41, 4, 5, '数据字典中通常包括数据项、【】、数据流、数据存储和处理过程5个部分。', '', '', '', '【数据结构】', 0, '', NULL, 0, 0, NULL, NULL),
	(1106, 4, 41, 4, 5, '如果X→Y和Y→X同时成立，则可记为【】。', '', '', '', '【X——Y】', 0, '', NULL, 0, 0, NULL, NULL),
	(1107, 4, 41, 4, 5, '关系代数中选择操作是根据某些条件对关系做【】。', '', '', '', '【水平分割】', 0, '', NULL, 0, 0, NULL, NULL),
	(1108, 4, 41, 4, 5, 'SQL标准提供嵌套查询的改进方法是导出表和【】。', '', '', '', '【临时视图】', 0, '', NULL, 0, 0, NULL, NULL),
	(1109, 4, 41, 4, 5, 'SQL中把完整性约束分成三大类：域约束、基本表约束和【】。', '', '', '', '【断言】', 0, '', NULL, 0, 0, NULL, NULL),
	(1110, 4, 41, 4, 5, '封锁技术中主要有两种锁：排他型封锁和【】。', '', '', '', '【[\'共享型封锁\', \'或S锁或读锁\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1111, 4, 41, 4, 5, '触发器是SQL Server提供给程序员和数据分析员来保证数据完整性的一种方法，它是与表事件相关的特殊的【】。', '', '', '', '【存储过程】', 0, '', NULL, 0, 0, NULL, NULL),
	(1112, 4, 41, 4, 5, 'Power Builder9.0中，PainterBar是PB提供的操作【】的工具栏。', '', '', '', '【画板组件】', 0, '', NULL, 0, 0, NULL, NULL),
	(1113, 4, 41, 4, 5, '在面向对象的类图中，关联是对类的实例之间联系的命名，相当于ER模型中的【】。', '', '', '', '【联系类型】', 0, '', NULL, 0, 0, NULL, NULL),
	(1114, 4, 42, 2, 5, '数据库系统提供数据控制功能，其中不包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"数据的稳定性";i:1;s:18:"数据的完整性";i:2;s:18:"数据的安全性";i:3;s:24:"数据库的并发控制";i:4;N;i:5;N;}', NULL),
	(1115, 4, 42, 2, 5, '表达DB物理结构的模型称为（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"逻辑模型";i:1;s:12:"外部模型";i:2;s:12:"内部模型";i:3;s:12:"概念模型";i:4;N;i:5;N;}', NULL),
	(1116, 4, 42, 2, 5, '存取路径分为主存取路径与辅助存取路径，主存取路径主要用于（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"安全检测";i:1;s:12:"主键索引";i:2;s:12:"终端用户";i:3;s:15:"辅助键索引";i:4;N;i:5;N;}', NULL),
	(1117, 4, 42, 2, 5, '不含有多余属性的超键称为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"主键";i:1;s:6:"外键";i:2;s:6:"内键";i:3;s:9:"候选键";i:4;N;i:5;N;}', NULL),
	(1118, 4, 42, 2, 5, 'A值与8值有一对多联系，可写出的函数依赖是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"B←→A";i:1;s:8:"A←→B";i:2;s:5:"A→B";i:3;s:5:"B→A";i:4;N;i:5;N;}', NULL),
	(1119, 4, 42, 2, 5, '如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R属于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"1NF";i:1;s:3:"2NF";i:2;s:3:"3NF";i:3;s:4:"BCNF";i:4;N;i:5;N;}', NULL),
	(1120, 4, 42, 2, 5, '设关系R有r个属性，关系S有S个属性，其中有一个属性是相同的，经过R和S的笛卡尔积操作后，属性个数是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"r+S";i:1;s:7:"r+S一1";i:2;s:3:"r+S";i:3;s:8:"max(r,s)";i:4;N;i:5;N;}', NULL),
	(1121, 4, 42, 2, 5, '下列关系代数操作中，要求两个运算对象其属性结构完全相同的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"笛卡尔积、连接";i:1;s:21:"自然连接、除法";i:2;s:15:"并、交、差";i:3;s:15:"投影、选择";i:4;N;i:5;N;}', NULL),
	(1122, 4, 42, 2, 5, 'SELECT语句的查询结果之间进行集合的交操作的运算符是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"UNION";i:1;s:9:"INTERSECT";i:2;s:6:"EXISTS";i:3;s:6:"EXCEPT";i:4;N;i:5;N;}', NULL),
	(1123, 4, 42, 2, 5, '设某数据库中有学生表(学号，姓名，专业)，若要把“01、张璐、计算机”插入学生表中，则下列语句正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"ADD INT0学生表VALUE(\' 01\'，\'张璐\'，\'计算机\')";i:1;s:56:"INSERT INT0学生表VALUE(\'01\'，\'张璐\'，\'计算机\')";i:2;s:54:"ADD INT0学生表VALUES(\'01\'，\'张璐\'，\'计算机\')";i:3;s:57:"INSERT INT0学生表VALUES(\'01\'，\'张璐\'，\'计算机\')";i:4;N;i:5;N;}', NULL),
	(1124, 4, 42, 2, 5, 'DBMS的恢复子系统采取一系列措施保证在任何情况下保持事务的原子性和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"隔离性";i:1;s:9:"持久性";i:2;s:9:"一致性";i:3;s:9:"安全性";i:4;N;i:5;N;}', NULL),
	(1125, 4, 42, 2, 5, '一个触发器由三部分组成，它们是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"事件一条件一权限";i:1;s:24:"事件一条件一审计";i:2;s:24:"事件一条件～角色";i:3;s:24:"事件一条件一动作";i:4;N;i:5;N;}', NULL),
	(1126, 4, 42, 2, 5, 'SQL Server 2000的主要工具中，执行ToSQL的最佳轻量级工具是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"查询分析器";i:1;s:15:"服务管理器";i:2;s:15:"企业管理器";i:3;s:15:"事件探查器";i:4;N;i:5;N;}', NULL),
	(1127, 4, 42, 2, 5, 'PowerBuilder 9.0提供的操作画板组件的=【：具栏是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"PowerBar";i:1;s:10:"PainterBar";i:2;s:7:"DataBar";i:3;s:7:"FuncBar";i:4;N;i:5;N;}', NULL),
	(1128, 4, 42, 2, 5, '在类图中，关联是对类的实例之间联系的命名，与关联有关的类的个数称为（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"关联元数";i:1;s:12:"关联角色";i:2;s:9:"重复度";i:3;s:12:"关联基数";i:4;N;i:5;N;}', NULL),
	(1129, 4, 42, 4, 5, '数据独立性是指应用程序与数据库的【】之间相互独立。', '', '', '', '【数据结构】', 0, '', NULL, 0, 0, NULL, NULL),
	(1130, 4, 42, 4, 5, '概念设计的任务一般可分为三步来完成：进行数据抽象，设计局部概念模型；将局部概念模型综合成全局概念模型；【】。', '', '', '', '【评审】', 0, '', NULL, 0, 0, NULL, NULL),
	(1131, 4, 42, 4, 5, '属性集U为ABCD，FD集为{A→C，C→A，B→AC,D→AC},则（AB.+为【】。', '', '', '', '【ABC】', 0, '', NULL, 0, 0, NULL, NULL),
	(1132, 4, 42, 4, 5, '将关系代数表达式 转换为元组表达式 【】。', '', '', '', '【[\'{t\', \'R\', \'t\', \'∧t[3]=’d’\', \'}\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1133, 4, 42, 4, 5, '在基本表不需要时，撤销基本表的语句是【】。', '', '', '', '【DROPTABLE】', 0, '', NULL, 0, 0, NULL, NULL),
	(1134, 4, 42, 4, 5, '利用封锁技术，可以避免并发操作引起的各种错误，但有可能产生其他三个问题：活锁、【】和死锁。', '', '', '', '【饿死】', 0, '', NULL, 0, 0, NULL, NULL),
	(1135, 4, 42, 4, 5, '在面向对象技术中，相同类型元素的有序集合称为【】类型。', '', '', '', '【数组】', 0, '', NULL, 0, 0, NULL, NULL),
	(1136, 4, 42, 4, 5, 'T-SQL语言中，在单个Declare命令中声明多个变量时，需要使用【】将它们互相隔开。', '', '', '', '【[\'逗号\', \'或\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1137, 4, 42, 4, 5, 'PowerBuilder9.0中，提供规范化的Workspace(工作空间)对象，让程序员更方便地管理创建的【】。', '', '', '', '【应用对象】', 0, '', NULL, 0, 0, NULL, NULL),
	(1138, 4, 42, 4, 5, 'DBMS必须提供一种功能来保证数据库中数据是正确的，避免非法的不符合语义的错误数据的输入和输出，即所谓【】。', '', '', '', '【[\'垃圾进垃圾出\', \'或 Garbage In Garbage out\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1139, 4, 43, 2, 5, '随着数据管理规模的扩大,数据量急剧增加,下面不属于文件系统缺陷的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据冗余";i:1;s:15:"数据不一致";i:2;s:12:"读脏数据";i:3;s:15:"数据联系弱";i:4;N;i:5;N;}', NULL),
	(1140, 4, 43, 2, 5, '关于逻辑模型,叙述正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"逻辑模型独立于硬件和软件";i:1;s:44:"逻辑模型表达了DB的局部逻辑结构";i:2;s:64:"逻辑模型是从数据库实现的观点出发,对数据建模";i:3;s:39:"逻辑模型主要有实体联系模型";i:4;N;i:5;N;}', NULL),
	(1141, 4, 43, 2, 5, '对于数据库系统生存期,下面不属于物理设计阶段工作的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"存储记录结构设计";i:1;s:15:"设计外模型";i:2;s:24:"确定数据存储位置";i:3;s:21:"存取方法的设计";i:4;N;i:5;N;}', NULL),
	(1142, 4, 43, 2, 5, '在关系模型中,元组个数称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"元数";i:1;s:6:"基数";i:2;s:6:"度数";i:3;s:6:"目数";i:4;N;i:5;N;}', NULL),
	(1143, 4, 43, 2, 5, '对于函数依赖W→A,如果存在X⊂W有X→A成立,那么称W→A是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"平凡依赖";i:1;s:12:"传递依赖";i:2;s:12:"局部依赖";i:3;s:12:"完全依赖";i:4;N;i:5;N;}', NULL),
	(1144, 4, 43, 2, 5, '已知关系R(A,B,C,D,E)有函数依赖集F={A→BC,CD→E,B→D,E→A},则B的闭包B^+是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"{B,D}";i:1;s:7:"{B,C,D}";i:2;s:9:"{B,C,D,E}";i:3;s:11:"{A,B,C,D,E}";i:4;N;i:5;N;}', NULL),
	(1145, 4, 43, 2, 5, '关系代数中投影运算是对关系进行的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"垂直分割";i:1;s:12:"水平分割";i:2;s:6:"结合";i:3;s:30:"先垂直分割后水平分割";i:4;N;i:5;N;}', NULL),
	(1146, 4, 43, 2, 5, '设有关系R(ABCD.和关系S(BCD.,则R×S结果集的元数为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"3";i:1;s:1:"4";i:2;s:1:"6";i:3;s:1:"7";i:4;N;i:5;N;}', NULL),
	(1147, 4, 43, 2, 5, '已知SN是一个字符型字段,下列SQL查询语句\nSELECT SN FROM S\nWHERE SN LIKE \'AB%\'            其执行结果为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:44:"找出含有3个字符\'AB%\'的所有SN字段";i:1;s:58:"找出仅含3个字符且前两个字符为\'AB\'的SN字段";i:2;s:39:"找出含有字符\'AB\'的所有SN字段";i:3;s:42:"找出以字符\'AB\'开头的所有SN字段";i:4;N;i:5;N;}', NULL),
	(1148, 4, 43, 2, 5, '设有学生表STUDENT(学号,姓名,性别,年龄),则向STUDENT表插入一条新记录的正确的SQL语句是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:52:"APPEND INTO STUDENT VALUES(\'d001\',\'王明\',\'女\',18)";i:1;s:52:"INSERT INTO STUDENT VALUES(\'d001\',\'王明\',\'女\',18)";i:2;s:47:"INSERT STUDENT VALUES(\'d001\',\'王明\',\'女\',18)";i:3;s:47:"APPEND STUDENT VALUES(\'d001\',\'王明\',\'女\',18)";i:4;N;i:5;N;}', NULL),
	(1149, 4, 43, 2, 5, 'DBS运行的最小逻辑工作单位是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"数据";i:1;s:6:"事务";i:2;s:6:"记录";i:3;s:6:"函数";i:4;N;i:5;N;}', NULL),
	(1150, 4, 43, 2, 5, '用户只能使用视图定义中的数据,而不能使用视图定义外的其它数据,从而保证了数（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"安全性";i:1;s:9:"完整性";i:2;s:9:"恢复性";i:3;s:9:"并发性";i:4;N;i:5;N;}', NULL),
	(1151, 4, 43, 2, 5, '在SQL Server2000提供的服务中,管理 SQL Server周期性行为的安排,并在发生错误时通知系统管理员的服务是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:"MS SQL Server";i:1;s:16:"SQL Server Agent";i:2;s:24:"Microsoft Server Service";i:3;s:6:"MS DTC";i:4;N;i:5;N;}', NULL),
	(1152, 4, 43, 2, 5, 'Power Builder9.0中,用于生成可执行文件、动态链接库、组件和代理对象的画板是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"结构画板";i:1;s:12:"函数画板";i:2;s:12:"查询画板";i:3;s:12:"工程画板";i:4;N;i:5;N;}', NULL),
	(1153, 4, 43, 2, 5, '在面向对象技术中,相同元素的有序集合,并且允许有重复的元素的复合数据类型（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"行类型";i:1;s:12:"数组类型";i:2;s:12:"列表类型";i:3;s:12:"集合类型";i:4;N;i:5;N;}', NULL),
	(1154, 4, 43, 4, 5, 'DB是长期存储在计算机内、有组织的、统一管理的相关【】的集合。', '', '', '', '【数据】', 0, '', NULL, 0, 0, NULL, NULL),
	(1155, 4, 43, 4, 5, '数据库试运行也称为联合调试,其主要工作包括功能调试和【】调试。', '', '', '', '【性能】', 0, '', NULL, 0, 0, NULL, NULL),
	(1156, 4, 43, 4, 5, '关系模式的设计尽可能使得相应关系中不出现插入、删除和【】等操作异常现象。', '', '', '', '【修改】', 0, '', NULL, 0, 0, NULL, NULL),
	(1157, 4, 43, 4, 5, '关系R和S都是二元关系,则与元组表达式{w|(彐v)(彐v)(R(u)∧S(v)∧u[2]=v[1]∧w[1]=u[1]∧w{2]=v[2]}}等价的关系代数表达式是【】。', '', '', '', '【π1】【[\'4\', \'σ2=3\', \'R×S\']】', 0, '', NULL, 0, 0, NULL, NULL),
	(1158, 4, 43, 4, 5, 'SQL语言中,撤消基本表的语句是【】。', '', '', '', '【DROP TABLE】', 0, '', NULL, 0, 0, NULL, NULL),
	(1159, 4, 43, 4, 5, '数据库中完整性一词是指数据的正确性、有效性和相容性,防止【】进入数据库。', '', '', '', '【错误的数据】', 0, '', NULL, 0, 0, NULL, NULL),
	(1160, 4, 43, 4, 5, '如果多个事务依次执行,则称为事务的【】。', '', '', '', '【串行调度】', 0, '', NULL, 0, 0, NULL, NULL),
	(1161, 4, 43, 4, 5, '存储过程的优点主要是提供了安全机制、改进了执行性能、减少了网络流量和增强了【】。', '', '', '', '【代码的重用性】', 0, '', NULL, 0, 0, NULL, NULL),
	(1162, 4, 43, 4, 5, 'Powerbuilder作为一种数据库前端开发工具,操作的核心是【】中的数据。', '', '', '', '【数据库】', 0, '', NULL, 0, 0, NULL, NULL),
	(1163, 4, 43, 4, 5, '使用SQL/CLI时,函数调用中SQL语句将作为 【】动态地创建和传递。', '', '', '', '【字符串参数】', 0, '', NULL, 0, 0, NULL, NULL),
	(1164, 4, 44, 2, 5, '将相关数据集中存放的物理存储技术是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"非聚集";i:1;s:6:"聚集";i:2;s:6:"授权";i:3;s:6:"回收";i:4;N;i:5;N;}', NULL),
	(1165, 4, 44, 2, 5, '可用于收回权限的SQL语句是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"GRANT";i:1;s:4:"ROLL";i:2;s:6:"REVOKE";i:3;s:6:"RETURN";i:4;N;i:5;N;}', NULL),
	(1166, 4, 44, 2, 5, '对于使用存储过程的好处说法错误的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"可增强SQL语言的功能";i:1;s:30:"可增强SQL语言的灵活性";i:2;s:24:"具有良好的封装性";i:3;s:18:"系统运行稳定";i:4;N;i:5;N;}', NULL),
	(1167, 4, 44, 2, 5, '在触发器的创建中，每个表每个事件每次只允许一个触发器，因此每个表最多支持的触发器是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"1个";i:1;s:4:"3个";i:2;s:4:"6个";i:3;s:4:"8个";i:4;N;i:5;N;}', NULL),
	(1168, 4, 44, 2, 5, '用于删除一个或多个MySQL账户，并消除其权限的语句是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"DROPUSERS";i:1;s:8:"DROPUSER";i:2;s:10:"ALTERUSERS";i:3;s:9:"ALTERUSER";i:4;N;i:5;N;}', NULL),
	(1169, 4, 44, 2, 5, '把数据按照相似性归纳成若干类别的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"概念描述";i:1;s:12:"关联分析";i:2;s:6:"分类";i:3;s:6:"聚类";i:4;N;i:5;N;}', NULL),
	(1170, 4, 44, 2, 5, '数据库技术与人工智能技术相结合出现的数据库系统是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"分布式数据库系统";i:1;s:21:"并行数据库系统";i:2;s:21:"主动数据库系统";i:3;s:21:"移动数据库系统";i:4;N;i:5;N;}', NULL),
	(1171, 4, 44, 4, 5, '引起数据不一致的根源是【】_。', '', '', '', '【数据冗余】', 0, '', NULL, 0, 0, NULL, NULL),
	(1172, 4, 44, 4, 5, '一类较为普遍、常用的数据库设计方法是【】。', '', '', '', '【规范设计法】', 0, '', NULL, 0, 0, NULL, NULL),
	(1173, 4, 44, 4, 5, '数据库恢复是以备份为基础的，它是与备份相对应的【】_和管理操作。', '', '', '', '【系统维护】', 0, '', NULL, 0, 0, NULL, NULL),
	(1174, 4, 44, 4, 5, '图存储数据库是基于图理论构建的，使用结点、属性和【】的概念。', '', '', '', '【边】', 0, '', NULL, 0, 0, NULL, NULL),
	(1175, 4, 44, 4, 5, '数据仓库具有三个常用的重要概念，即粒度、分割和【】。', '', '', '', '【维】', 0, '', NULL, 0, 0, NULL, NULL),
	(1176, 4, 45, 2, 5, '属性的取值范围称为该属性的（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"联系";i:1;s:6:"实体";i:2;s:3:"码";i:3;s:3:"城";i:4;N;i:5;N;}', NULL),
	(1177, 4, 45, 2, 5, '下列不属于数据库系统三级模式结构的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"模式";i:1;s:9:"外模式";i:2;s:9:"内模式";i:3;s:12:"数据模式";i:4;N;i:5;N;}', NULL),
	(1178, 4, 45, 2, 5, '在关系的一个码中移去某个属性，它仍然是这个关系的码，这样的码称为（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"全码";i:1;s:6:"超码";i:2;s:9:"主属性";i:3;s:6:"外码";i:4;N;i:5;N;}', NULL),
	(1179, 4, 45, 2, 5, '若D1＝{a1，a2，a3}，D2＝{1，2，3}，则D1×D2集合中共有元组（  ）个。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:1:"6";i:1;s:1:"8";i:2;s:1:"9";i:3;s:2:"27";i:4;N;i:5;N;}', NULL),
	(1180, 4, 45, 2, 5, '标明不同任务的功能及使用状况的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"操作过程说明书";i:1;s:21:"数据操作特征表";i:2;s:15:"任务分类表";i:3;s:15:"数据流程图";i:4;N;i:5;N;}', NULL),
	(1181, 4, 45, 2, 5, '（   ）的任务是分析并检验模式及子模式的正确性与合理性。', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"设计评价";i:1;s:12:"物理设计";i:2;s:12:"加载数据";i:3;s:18:"应用程序设计";i:4;N;i:5;N;}', NULL),
	(1182, 4, 45, 2, 5, '下列关于SQL的说法中，错误的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"SQL是一个综合的、功能强大的语言";i:1;s:47:"SQL与Java、C等程序设计语言非常相似";i:2;s:24:"SQL由很少的词构成";i:3;s:57:"每个SQL语句都是由一个或多个关键字所组成";i:4;N;i:5;N;}', NULL),
	(1183, 4, 45, 2, 5, '使用 MySQL数据库管理系统构建各种信息管理系统或互联网网站的应用环境，采用LAMP构架方式时，（   ）作为操作系统。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:"UNIX";i:1;s:7:"Windows";i:2;s:5:"Linux";i:3;s:3:"MAC";i:4;N;i:5;N;}', NULL),
	(1184, 4, 45, 2, 5, '在下列 MySQL的内置函数中，属于系统信息函数的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"IF( )函数";i:1;s:15:"IFNULL( )函数";i:2;s:13:"CASE( )函数";i:3;s:16:"VERSION( )函数";i:4;N;i:5;N;}', NULL),
	(1185, 4, 45, 2, 5, '在 SELECT语句的语法结构中，（  ）用于指定组的选择条件。', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:14:"ORDER BY子句";i:1;s:11:"WHERE子句";i:2;s:14:"GROUP BY子句";i:3;s:12:"HAVING子句";i:4;N;i:5;N;}', NULL),
	(1186, 4, 45, 2, 5, '在某表中将学号字段的前四位规定为学生的入学年份，第5位规定为院系的编号。这属于列级约束中的（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"对数据类型的约束";i:1;s:24:"对数据格式的约束";i:2;s:24:"对取值范围的约束";i:3;s:21:"对空值的的约束";i:4;N;i:5;N;}', NULL),
	(1187, 4, 45, 2, 5, '保护数据库以防止不合法的使用而造成数据泄露、更改或破坏，这是指数据的（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"安全性";i:1;s:9:"完整性";i:2;s:12:"并发控制";i:3;s:6:"恢复";i:4;N;i:5;N;}', NULL),
	(1188, 4, 45, 2, 5, '产生数据不一致的主要原因是并发操作破坏了事务的（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"隔离性";i:1;s:9:"一致性";i:2;s:9:"原子性";i:3;s:9:"持续性";i:4;N;i:5;N;}', NULL),
	(1189, 4, 45, 2, 5, '第三代数据库系统应该是以支持（  ）数据模型为主要特征的数据库系统。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"关系";i:1;s:6:"网状";i:2;s:12:"面向对象";i:3;s:12:"面向过程";i:4;N;i:5;N;}', NULL),
	(1190, 4, 45, 2, 5, '下列属于文档型数据库的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"Redis";i:1;s:7:"CouchDB";i:2;s:5:"Hbase";i:3;s:9:"Cassandra";i:4;N;i:5;N;}', NULL),
	(1191, 4, 45, 4, 5, '用户操纵数据库中的数据，实现对数据库的查询、插入、删除、修改等基本操作，是通过数据库管理系统的【】实现。', '', '', '', '【数据操纵语言】', 0, '', NULL, 0, 0, NULL, NULL),
	(1192, 4, 45, 4, 5, '关系数据库的基本特征是【】。', '', '', '', '【使用关系数据模型组织数据】', 0, '', NULL, 0, 0, NULL, NULL),
	(1193, 4, 45, 4, 5, '设有关系模式R(A，B，C)，F＝(A→C，AB→C｝，则R中存在【】函数依赖。', '', '', '', '【部分】', 0, '', NULL, 0, 0, NULL, NULL),
	(1194, 4, 45, 4, 5, '数据库设计的内容包括数据库结构设计和【】。', '', '', '', '【数据库行为设计】', 0, '', NULL, 0, 0, NULL, NULL),
	(1195, 4, 45, 4, 5, '【】属性用作实体的关键字。', '', '', '', '【标识】', 0, '', NULL, 0, 0, NULL, NULL),
	(1196, 4, 45, 4, 5, '字符串常量分为【】和 Unicode字符串常量。', '', '', '', '【ASCII字符串常量】', 0, '', NULL, 0, 0, NULL, NULL),
	(1197, 4, 45, 4, 5, '常用的条件判断语句有IF…THEN…ELSE语句和【】。', '', '', '', '【CASE语句】', 0, '', NULL, 0, 0, NULL, NULL),
	(1198, 4, 45, 4, 5, '权限的转移可以通过在 GRANT语句中使用【】子句来实现。', '', '', '', '【WITH】', 0, '', NULL, 0, 0, NULL, NULL),
	(1199, 4, 45, 4, 5, '【】语句表示回滚。', '', '', '', '【ROLLBACK】', 0, '', NULL, 0, 0, NULL, NULL),
	(1200, 4, 45, 4, 5, 'OLTP主要用于【】处理。', '', '', '', '【操作型】', 0, '', NULL, 0, 0, NULL, NULL),
	(1201, 4, 46, 2, 5, '用户定义数据库中的数据对象，是通过数据库管理系统的（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"数据库备份功能";i:1;s:21:"数据库恢复功能";i:2;s:21:"数据库操纵语言";i:3;s:18:"数据定义语言";i:4;N;i:5;N;}', NULL),
	(1202, 4, 46, 2, 5, '引起数据不一致的根源是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据集成";i:1;s:12:"并发控制";i:2;s:12:"数据冗余";i:3;s:12:"故障恢复";i:4;N;i:5;N;}', NULL),
	(1203, 4, 46, 2, 5, '关系数据库以（  ）作为数据的逻辑模型', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"二维表";i:1;s:12:"关系模型";i:2;s:9:"数据库";i:3;s:6:"关系";i:4;N;i:5;N;}', NULL),
	(1204, 4, 46, 2, 5, '当关系有多个候选码时，选定一个作为主键，若主键为全码，应包含（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"单个属性";i:1;s:12:"两个属性";i:2;s:12:"多个属性";i:3;s:12:"全部属性";i:4;N;i:5;N;}', NULL),
	(1205, 4, 46, 2, 5, '主要反映应用部门原始业务处理的工作流程的是（  ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"数据操作特征表";i:1;s:15:"数据流程图";i:2;s:15:"任务分类表";i:3;s:21:"操作过程说明书";i:4;N;i:5;N;}', NULL),
	(1206, 4, 46, 2, 5, '系统维护中最困难的工作是（  ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"数据库重组与重构";i:1;s:15:"数据库运行";i:2;s:15:"数据库实施";i:3;s:12:"物理设计";i:4;N;i:5;N;}', NULL),
	(1207, 4, 46, 2, 5, '下列关于SQL的说法中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"SQL不是某个特定数据库供应商专有的语言";i:1;s:72:"掌握SQL可以帮助用户与几乎所有的关系数据库进行交互";i:2;s:15:"SQL简单易学";i:3;s:24:"SQL语句区分大小写";i:4;N;i:5;N;}', NULL),
	(1208, 4, 46, 2, 5, '索引在逻辑上通常包含有普通索引、唯一性索引和主键三类。创建主键时，通常使用的关键字是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:5:"INDEX";i:1;s:6:"UNIQUE";i:2;s:11:"PRIMARY KEY";i:3;s:3:"KEY";i:4;N;i:5;N;}', NULL),
	(1209, 4, 46, 2, 5, '在 SELECT语句的语法结构中，（  ）用于对检索到的记录进行分组。', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"FROM子句";i:1;s:11:"WHERE子句";i:2;s:14:"GROUP BY子句";i:3;s:12:"HAVING子句";i:4;N;i:5;N;}', NULL),
	(1210, 4, 46, 2, 5, '下列关于游标的说法中，错误的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:54:"在实际应用中，一个游标可以被多次打开";i:1;s:60:"在定义游标之后，必须打开该游标，才能使用";i:2;s:50:"在使用游标之前，必须先声明(定义)它";i:3;s:69:"句柄必须在游标之前定义，否则系统会出现错误消息";i:4;N;i:5;N;}', NULL),
	(1211, 4, 46, 2, 5, '下列关于存储函数与存储过程的说法中，错误的是（  ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:70:"可以直接对存储函数进行调用，且不需要使用CALL语句";i:1;s:66:"存储函数与存储过程一样，都可以被应用程序调用";i:2;s:40:"存储函数中不能包含 RETURN语句";i:3;s:49:"对存储过程的调用，需要使用CALL语句";i:4;N;i:5;N;}', NULL),
	(1212, 4, 46, 2, 5, '候选键约束可以在 CREATE TABLE或 ALTER TABLE语句中使用关键字（  ）来实现。', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"REFERENCES";i:1;s:11:"FOREIGN KEY";i:2;s:11:"PRIMARY KEY";i:3;s:6:"UNIQUE";i:4;N;i:5;N;}', NULL),
	(1213, 4, 46, 2, 5, '修改用户口令的语句是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:11:"CREATE USER";i:1;s:9:"DROP USER";i:2;s:11:"RENAME USER";i:3;s:12:"SET PASSWORD";i:4;N;i:5;N;}', NULL),
	(1214, 4, 46, 2, 5, '最简单有效的保障封锁其调度是可串行性的方法是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:10:"1级封锁";i:1;s:13:"2级封锁面";i:2;s:10:"3级封锁";i:3;s:15:"两段封锁法";i:4;N;i:5;N;}', NULL),
	(1215, 4, 46, 2, 5, '聚类的目的是（  ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"使对象之间的距离尽可能小";i:1;s:36:"使对象之间的距离尽可能大";i:2;s:108:"使属于同一类别的对象之间的距离尽可能大，而不同类别的对象间的距离尽可能小";i:3;s:108:"使属于同一类别的对象之间的距离尽可能小，而不同类别的对象间的距离尽可能大";i:4;N;i:5;N;}', NULL),
	(1216, 4, 46, 4, 5, '用户通常包括程序员和【】两类用户。', '', '', '', '【数据库终端用户】', 0, '', NULL, 0, 0, NULL, NULL),
	(1217, 4, 46, 4, 5, '关系操作的特点是【】操作方式。一中单方合是', '', '', '', '【集合】', 0, '', NULL, 0, 0, NULL, NULL),
	(1218, 4, 46, 4, 5, '关系规范化理论主要应用于数据库设计中的【】', '', '', '', '【概念设计阶段】', 0, '', NULL, 0, 0, NULL, NULL),
	(1219, 4, 46, 4, 5, '数据应用过程可以借助【】或其他信息及应用结构图形表示。', '', '', '', '【数据流程图】', 0, '', NULL, 0, 0, NULL, NULL),
	(1220, 4, 46, 4, 5, '【】的任务是把在概念结构设计产生的概念模型转换为具体的DBMS所支持的逻辑数据模型。', '', '', '', '【逻辑结构设计】', 0, '', NULL, 0, 0, NULL, NULL),
	(1221, 4, 46, 4, 5, '数据库对象主要有表、【】、规则、视图、触发器、存储过程等。', '', '', '', '【默认约束】', 0, '', NULL, 0, 0, NULL, NULL),
	(1222, 4, 46, 4, 5, '当一个索引不再需要时，可以使用 DROP INDEX语句或【】来进行删除。', '', '', '', '【ALTER TABLE语句】', 0, '', NULL, 0, 0, NULL, NULL),
	(1223, 4, 46, 4, 5, '在 MySQL中，可以在存储过程体中，使用条件判断语句和【】这样两类用于控制语句流程的过程式SQL语句。', '', '', '', '【循环语句】', 0, '', NULL, 0, 0, NULL, NULL),
	(1224, 4, 46, 4, 5, '在 MySQL中，创建触发器的语句是【】。', '', '', '', '【CREATE TRIGGER】', 0, '', NULL, 0, 0, NULL, NULL),
	(1225, 4, 46, 4, 5, '【】是划分数据库发展阶段的基本依据。', '', '', '', '【数据模型】', 0, '', NULL, 0, 0, NULL, NULL),
	(1226, 4, 47, 2, 5, '依照事物状态及其变化方式的不确定性，语法信息可以分为（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"随机信息、模糊信息和偶发信息";i:1;s:42:"随机信息、模糊信息和突发信息";i:2;s:42:"随机信息、确定信息和偶发信息";i:3;s:42:"随机信息、确定信息和突发信息";i:4;N;i:5;N;}', NULL),
	(1227, 4, 47, 2, 5, '在计算机中，常常使用字节作为信息测度的单位，它属于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"基于数据量的信息测度方法";i:1;s:39:"基于 Shannon熵的信息测度方法";i:2;s:39:"基于文件大小的信息测度方法";i:3;s:33:"基于语法的信息测度方法";i:4;N;i:5;N;}', NULL),
	(1228, 4, 47, 2, 5, '摩尔定律预测，微处理器芯片大约每18个月集成度翻番，处理能力提高一倍，体积和价格减半。这体现了现代信息技术的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"数字化特点";i:1;s:15:"系统化特点";i:2;s:15:"智能化特点";i:3;s:15:"小型化特点";i:4;N;i:5;N;}', NULL),
	(1229, 4, 47, 2, 5, '信息资源管理的基础是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"管理科学、计算机科学、数学等";i:1;s:48:"管理科学、信息科学与技术、数学等";i:2;s:45:"管理科学、计算机科学、统计学等";i:3;s:51:"管理科学、信息科学与技术、统计学等";i:4;N;i:5;N;}', NULL),
	(1230, 4, 47, 2, 5, '下列关于 Shannon信息论的说法中，错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:60:"通信的发生是以通信者具有不确定性为前提的";i:1;s:96:"通信的目的就是减少不确定性，而消除不确定的东西正是它所传递的信息";i:2;s:76:"Shannon把信息量定义为随机不确定性（信息熵）程度的增加";i:3;s:103:"Shannon的信息论以概率论为工具，深刻地阐述了通信工程的一系列基本理论问题";i:4;N;i:5;N;}', NULL),
	(1231, 4, 47, 2, 5, '现代信息技术主要包括计算机技术、通信技术、传感技术和控制技术，它们的基础是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"集成电路技术";i:1;s:12:"数字技术";i:2;s:15:"半导体技术";i:3;s:15:"微电子技术";i:4;N;i:5;N;}', NULL),
	(1232, 4, 47, 2, 5, '与依赖经验完成纺织机械革新不同，在信息技术的发展过程中，科学理论与实验始终起着主导作用。这体现了信息革命的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"群体化特征";i:1;s:21:"科学技术化特征";i:2;s:15:"智能化特征";i:3;s:15:"高新性特征";i:4;N;i:5;N;}', NULL),
	(1233, 4, 47, 2, 5, '主体感知事物前已经具有的关于该事物的信息属于（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"实在信息";i:1;s:12:"先验信息";i:2;s:12:"实得信息";i:3;s:12:"后验信息";i:4;N;i:5;N;}', NULL),
	(1234, 4, 47, 2, 5, '信息不同于物质和能量，它不会在使用中被消耗，可以不断积累，甚至是可以再生的，这体现了信息资源的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"不可分性";i:1;s:24:"积累性或非消耗性";i:2;s:15:"认知相对性";i:3;s:12:"不同一性";i:4;N;i:5;N;}', NULL),
	(1235, 4, 47, 2, 5, '微电子技术造就了成千上万的信息技术应用，有人将其概括为“3c” 革命，3c指的是：计算机、通信和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"交换技术";i:1;s:12:"存储技术";i:2;s:12:"控制技术";i:3;s:12:"识别技术";i:4;N;i:5;N;}', NULL),
	(1236, 4, 47, 2, 5, '经济学赋予资源的三个内在属性不包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"可复制性";i:1;s:12:"可选择性";i:2;s:9:"稀缺性";i:3;s:9:"需求性";i:4;N;i:5;N;}', NULL),
	(1237, 4, 47, 2, 5, '信息论奠基人Shannon,把信息量定义为随机不确定性程度的减少。其基本观点是：通信的发生是以（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"通信者具有相似性为前提";i:1;s:36:"通信者具有不确定性为前提";i:2;s:33:"通信者具有相对性为前提";i:3;s:36:"通信者具有不同一性为前提";i:4;N;i:5;N;}', NULL),
	(1238, 4, 47, 2, 5, '信息化使我们面对一个数字化、网络化的信息社会，以下对信息社会的描述中，错误的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:81:"在信息社会中许多有价值的东西，其物质重要性在减轻或消失";i:1;s:84:"由于信息网络的存在，信息传输无视空间地城，时空距离被消除";i:2;s:36:"信息社会具备无限可扩展性";i:3;s:51:"信息社会中原子比非物质的比特更活跃";i:4;N;i:5;N;}', NULL),
	(1239, 4, 47, 2, 5, '以下关于信息革命特征的表述中，正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"信息化";i:1;s:9:"高效化";i:2;s:15:"技术科学化";i:3;s:15:"管理扁平化";i:4;N;i:5;N;}', NULL),
	(1240, 4, 47, 2, 5, '下列不属于信息的“生命周期”（信息过程）的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息分类";i:1;s:12:"信息加工";i:2;s:12:"信息再生";i:3;s:12:"信息施效";i:4;N;i:5;N;}', NULL),
	(1241, 4, 47, 3, 5, '国家信息化建设以信息资源开发利用为核心，按照哪几个层面进行实施（   ）', '', '', '', 'ABC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"领域信息化";i:1;s:15:"区域信息化";i:2;s:15:"企业信息化";i:3;s:15:"个人信息化";i:4;s:15:"城市信息化";i:5;N;}', NULL),
	(1242, 4, 47, 3, 5, '信息具有的性质包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"信息是普遍和无限的";i:1;s:48:"信息依附于媒体且可以独立于源事物";i:2;s:18:"信息可以共享";i:3;s:18:"信息可以变换";i:4;s:30:"信息是动态且有时效的";i:5;N;}', NULL),
	(1243, 4, 47, 3, 5, '信息产业包括（   ）', '', '', '', 'ABC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"信息产品制造业";i:1;s:21:"信息内容生产业";i:2;s:15:"信息服务业";i:3;s:15:"信息交换业";i:4;s:15:"信息加工业";i:5;N;}', NULL),
	(1244, 4, 47, 3, 5, '现代信息技术主要包括（   ）', '', '', '', 'ABDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"计算机技术";i:1;s:12:"通信技术";i:2;s:12:"制造技术";i:3;s:12:"控制技术";i:4;s:12:"传感技术";i:5;N;}', NULL),
	(1245, 4, 47, 3, 5, '信息资源也是一种资源，经济学上赋予它的内在属性包括（   ）', '', '', '', 'BCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"有效性";i:1;s:9:"需求性";i:2;s:9:"稀缺性";i:3;s:12:"可选择性";i:4;s:9:"丰富性";i:5;N;}', NULL),
	(1246, 4, 47, 3, 5, '下列属于信息过程的有（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息获取";i:1;s:12:"信息传递";i:2;s:12:"信息加工";i:3;s:12:"信息再生";i:4;s:12:"信息施效";i:5;N;}', NULL),
	(1247, 4, 47, 3, 5, '从开发和利用的角度看，信息资源具有其他一些与物质、能量资源不同的特性，包括（   ）', '', '', '', 'ABDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"不可分性";i:1;s:15:"认知相对性";i:2;s:9:"统一性";i:3;s:9:"驾驭性";i:4;s:12:"不同一性";i:5;N;}', NULL),
	(1248, 4, 48, 2, 5, '信息化组织工作的核心灵魂是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"信息化组织";i:1;s:15:"信息化资源";i:2;s:9:"CIO机制";i:3;s:12:"信息活动";i:4;N;i:5;N;}', NULL),
	(1249, 4, 48, 2, 5, '数据信息单元单独存放、不能自动地实现信息共享与交换，需要靠人工与外界进行联系的现象，被称为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:7:"T黑洞";i:1;s:13:"I项目泥潭";i:2;s:12:"信息污染";i:3;s:12:"信息孤岛";i:4;N;i:5;N;}', NULL),
	(1250, 4, 48, 2, 5, '信息化战略的主要内容不包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"信息化项目的目标可行性评估";i:1;s:33:"信息化建设的愿景和架构";i:2;s:39:"信息化项目方案的选择与组织";i:3;s:21:"信息化项目规划";i:4;N;i:5;N;}', NULL),
	(1251, 4, 48, 2, 5, 'CIO机制的构成不包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"CIO";i:1;s:21:"信息化领导小组";i:2;s:12:"信息部门";i:3;s:12:"业务部门";i:4;N;i:5;N;}', NULL),
	(1252, 4, 48, 2, 5, '组织战略一般包括三类：总战略、经营战略和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"管理战略";i:1;s:12:"人事战略";i:2;s:12:"职能战略";i:3;s:12:"应急战略";i:4;N;i:5;N;}', NULL),
	(1253, 4, 48, 2, 5, '组织战略的规划方法很多，下列不属于组织战略规划方法的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:"SWOT矩阵法";i:1;s:15:"回归分析法";i:2;s:18:"波特五力模型";i:3;s:18:"价值链分析法";i:4;N;i:5;N;}', NULL),
	(1254, 4, 48, 2, 5, '现代信息化规划主要包括三个层面工作，分别是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"信息化战略规划、信息资源规划和信息化流程规划";i:1;s:67:" 信息化战略规划、信息资源规划和信息化项目规划";i:2;s:66:"信息化战略规划、信息技术规划和信息化流程规划";i:3;s:66:"信息化战略规划、信息技术规划和信息化项目规划";i:4;N;i:5;N;}', NULL),
	(1255, 4, 48, 2, 5, '以下属于CIO能力的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"程序设计能力";i:1;s:21:"数据库设计能力";i:2;s:12:"协调能力";i:3;s:18:"模型构建能力";i:4;N;i:5;N;}', NULL),
	(1256, 4, 48, 2, 5, '企业的辅助活动是指为基本活动提供服务的活动，不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"企业投入的釆购管理";i:1;s:12:"市场营销";i:2;s:12:"技术开发";i:3;s:39:"人力资源管理和企业基础结构";i:4;N;i:5;N;}', NULL),
	(1257, 4, 48, 2, 5, '组织信息化规划的战略目标体现在（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"流程优化、降低风险、管理资源和技术架构";i:1;s:57:"流程优化、竞争优势、管理资源和技术支持";i:2;s:57:"业务匹配、竞争优势、管理资源和技术架构";i:3;s:57:"业务匹配、竞争优势、管理资源和技术支持";i:4;N;i:5;N;}', NULL),
	(1258, 4, 48, 2, 5, 'CIO机制的核心是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息技术部门";i:1;s:3:"CIO";i:2;s:12:"业务部门";i:3;s:21:"信息管理委员会";i:4;N;i:5;N;}', NULL),
	(1259, 4, 48, 2, 5, '组织战略的制定过程不包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"市场分析";i:1;s:30:"战略规划的形成和完善";i:2;s:12:"环境分析";i:3;s:12:"战略决策";i:4;N;i:5;N;}', NULL),
	(1260, 4, 48, 2, 5, '信息资源规划的总体数据规划是基于（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"实体数据分析和应用数据库设计";i:1;s:42:"主体数据分析和主题数据库设计";i:2;s:42:"主体数据分析和应用数据库设计";i:3;s:42:"实体数据分析和主体数据库设计";i:4;N;i:5;N;}', NULL),
	(1261, 4, 48, 2, 5, '以下对主题数据库的描述中，正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"主题数据库是一种集约化的数据库环境";i:1;s:48:"主题数据库是按业务报表原样建库的";i:2;s:51:"主题数据库建立以后要进行数据格式化";i:3;s:39:"主题数据库要求信息的多元化";i:4;N;i:5;N;}', NULL),
	(1262, 4, 48, 2, 5, '信息资源规划的三个步骤是：建立负责信息资源规划的工作组、分析职能城及其业务和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"对职能域数据进行规范化";i:1;s:33:"对职能域数据进行合理化";i:2;s:33:"对职能域数据进行标准化";i:3;s:33:"对职能域数据进行制度化";i:4;N;i:5;N;}', NULL),
	(1263, 4, 48, 2, 5, '信息资源规划的重点工作是主题数据库与数据标准化和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"市场分析";i:1;s:12:"业务分析";i:2;s:12:"环境分析";i:3;s:12:"数据分析";i:4;N;i:5;N;}', NULL),
	(1264, 4, 48, 2, 5, '信息化项目制定质量计划时不需要考虑的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"企业的质量政策";i:1;s:18:"质量检验流程";i:2;s:21:"质量的国际认证";i:3;s:18:"质量检验标准";i:4;N;i:5;N;}', NULL),
	(1265, 4, 48, 3, 5, '信息化项目规划包括（   ）', '', '', '', 'ABCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"范围计划";i:1;s:12:"进度计划";i:2;s:12:"成本计划";i:3;s:12:"质量计划";i:4;s:12:"人力计划";i:5;N;}', NULL),
	(1266, 4, 48, 3, 5, '信息化战略规划的主要步骤包括（   ）', '', '', '', 'ABD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"基础信息调研";i:1;s:27:"现状评估与问题分析";i:2;s:21:"信息化方案评价";i:3;s:36:"信息化战略目标设计和制定";i:4;s:12:"效果反馈";i:5;N;}', NULL),
	(1267, 4, 48, 3, 5, '以下对信息化组织机构的职能描述中，错误的有（   ）', '', '', '', 'BC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"信息系统研发与管理";i:1;s:30:"信息资源的处理与传输";i:2;s:27:"信息系统调研与设计";i:3;s:33:"信息系统运行维护与管理";i:4;s:27:"信息资源管理与服务";i:5;N;}', NULL),
	(1268, 4, 48, 3, 5, '现代的信息化规划主要包括（   ）', '', '', '', 'ABC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息资源规划";i:1;s:21:"信息化项目规划";i:2;s:21:"信息化战略规划";i:3;s:21:"信息化组织规划";i:4;s:21:"信息化流程规划";i:5;N;}', NULL),
	(1269, 4, 49, 2, 5, '为完成信息系统资源的合理开发与高效利用、发挥信息系统在企业运行中的重要作用而采取一系列管理措施的工作是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息系统开发";i:1;s:12:"资源管理";i:2;s:15:"信息化管理";i:3;s:24:"信息系统资源管理";i:4;N;i:5;N;}', NULL),
	(1270, 4, 49, 2, 5, '需求分析的三个主要过程，不包括（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"可行性评估";i:1;s:12:"需求评估";i:2;s:12:"风险评估";i:3;s:18:"项目总体安排";i:4;N;i:5;N;}', NULL),
	(1271, 4, 49, 2, 5, '对信息系统用户培训的内容不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"计算机知识";i:1;s:27:"管理制度的具体规定";i:2;s:21:"信息系统的概念";i:3;s:21:"目标系统的概况";i:4;N;i:5;N;}', NULL),
	(1272, 4, 49, 2, 5, '决策支持系统属于（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"战略层的信息系统";i:1;s:24:"管理层的信息系统";i:2;s:24:"知识层的信息系统";i:3;s:24:"操作层的信息系统";i:4;N;i:5;N;}', NULL),
	(1273, 4, 49, 2, 5, '在信息系统项目开发管理中进行质量控制的首要工作是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"合理化工作流程";i:1;s:18:"控制成本预算";i:2;s:24:"制定质量控制标准";i:3;s:24:"提高开发工作效率";i:4;N;i:5;N;}', NULL),
	(1274, 4, 49, 2, 5, '信息系统的审计过程不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"准备阶段";i:1;s:12:"分析阶段";i:2;s:12:"实施阶段";i:3;s:12:"报告阶段";i:4;N;i:5;N;}', NULL),
	(1275, 4, 49, 2, 5, '以下对信息系统资源的理解中，正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"信息系统资源就其物质性而言是无限的";i:1;s:42:"对信息利用的潜在能力是有限的";i:2;s:75:"符合社会法律、法规和道德规范的信息系统资源是有益的";i:3;s:45:"任何信息系统资源都没有质的差别";i:4;N;i:5;N;}', NULL),
	(1276, 4, 49, 2, 5, '对“一把手原则”的理解，错误的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"这是项目开发管理的核心";i:1;s:33:"这是项目开发遵循的原则";i:2;s:45:"项目开发管理就是由一把手说了算";i:3;s:51:"可成立有“一把手”参与的项目委员会";i:4;N;i:5;N;}', NULL),
	(1277, 4, 49, 2, 5, '在经济方面对信息系统进行评价，评价内容主要是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"管理流程是否优化";i:1;s:12:"系统性能";i:2;s:21:"系统的成本效益";i:3;s:30:"系统资源是否充分利用";i:4;N;i:5;N;}', NULL),
	(1278, 4, 49, 2, 5, '信息系统最重要的要素是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"人";i:1;s:6:"硬件";i:2;s:6:"软件";i:3;s:6:"数据";i:4;N;i:5;N;}', NULL),
	(1279, 4, 49, 2, 5, '信息系统的生命周期可划分为（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:96:"系统规划、系统分析、系统设计、系统实施、系统运行与维护等五个阶段";i:1;s:87:"系统规划、系统分析、系统设计、系统实施、系统审计等五个阶段";i:2;s:96:"系统分析、系统设计、系统实施、系统运行与维护、系统审计等五个阶段";i:3;s:96:"系统调研、系统分析、系统设计、系统实施、系统运行与维护等五个阶段";i:4;N;i:5;N;}', NULL),
	(1280, 4, 49, 2, 5, '支持战略层的信息系统是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"DSS";i:1;s:3:"TPS";i:2;s:3:"MIS";i:3;s:3:"ESS";i:4;N;i:5;N;}', NULL),
	(1281, 4, 49, 2, 5, '项目质量控制的最后步骤是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"建立项目的质量衡量标准";i:1;s:24:"编写项目进度报告";i:2;s:33:"召开项目开发情况通报会";i:3;s:18:"采取调整措施";i:4;N;i:5;N;}', NULL),
	(1282, 4, 49, 2, 5, '信息系统运行维护管理是指信息系统上线后对信息系统运行过程中的哪些要素进行管理的活动（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"人员、硬件、软件、数据、规程等";i:1;s:45:"人员、硬件、软件、组织、规程等";i:2;s:45:"人员、硬件、软件、资源、规程等";i:3;s:45:"人员、硬件、软件、信息、规程等";i:4;N;i:5;N;}', NULL),
	(1283, 4, 49, 2, 5, '信息系统资源观中最核心的观点是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"信息系统资源系统观";i:1;s:27:"信息系统资源辩证观";i:2;s:27:"信息系统资源层次观";i:3;s:27:"信息系统资源开放观";i:4;N;i:5;N;}', NULL),
	(1284, 4, 49, 2, 5, '对于全组织的信息系统的开发，需成立项目委员会，下设（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"项目管理组";i:1;s:15:"项目评审组";i:2;s:15:"项目开发组";i:3;s:51:"项目管理组、项目评审组和项目开发组";i:4;N;i:5;N;}', NULL),
	(1285, 4, 49, 2, 5, '有助于终端用户熟悉系统的使用方法与操作过程的文档是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"系统分析说明书";i:1;s:21:"系统设计说明书";i:2;s:21:"系统开发合同书";i:3;s:12:"用户手册";i:4;N;i:5;N;}', NULL),
	(1286, 4, 49, 3, 5, '信息系统运行维护管理的内容包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"人员管理";i:1;s:18:"日常运行管理";i:2;s:36:"信息系统的数据和文档管理";i:3;s:42:"信息系统维护、评价和审计管理";i:4;s:14:"IT服务管理";i:5;N;}', NULL),
	(1287, 4, 49, 3, 5, '导致信息系统维护的内外部因素有（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"外部环境的改变";i:1;s:42:"组织管理方式和业务过程的改变";i:2;s:27:"用户需求的增减改变";i:3;s:39:"运行硬软件平台的变化与升级";i:4;s:21:"设计中存在问题";i:5;N;}', NULL),
	(1288, 4, 49, 3, 5, '信息系统的逻辑模型包括（   ）', '', '', '', 'ABCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"数据流程图";i:1;s:12:"数据字典";i:2;s:18:"处理逻辑说明";i:3;s:12:"存取分析";i:4;s:12:"数据来源";i:5;N;}', NULL),
	(1289, 4, 49, 3, 5, '信息系统文档主要包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"系统手册";i:1;s:12:"用户手册";i:2;s:15:"管理员手册";i:3;s:12:"操作规程";i:4;s:18:"有关管理制度";i:5;N;}', NULL),
	(1290, 4, 50, 2, 5, '信息采集要根据单位的方向、任务和服务对象的实际需求，即信息采集必须有明确的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"目的性";i:1;s:9:"系统性";i:2;s:9:"经济性";i:3;s:9:"预见性";i:4;N;i:5;N;}', NULL),
	(1291, 4, 50, 2, 5, '定点采集法是指聘请专门的信息采集人员定点采集相关信息资源，例如（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"生物多样性专题调查";i:1;s:30:"交通路口设置的摄像头";i:2;s:18:"参加各种会议";i:3;s:15:"参加展览会";i:4;N;i:5;N;}', NULL),
	(1292, 4, 50, 2, 5, '信息采集的系统性原则是指（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:45:"尽可能准确地采集符合需求的信息";i:1;s:45:"尽可能全面地采集符合需求的信息";i:2;s:45:"尽可能及时地采集符合需求的信息";i:3;s:45:"尽可能经济地采集符合需求的信息";i:4;N;i:5;N;}', NULL),
	(1293, 4, 50, 2, 5, '随着科学技术的发展，人类发明了许多用作信息资源载体的新兴材料载体，包括磁性载体，如（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"硅片、集成电路";i:1;s:16:" 磁带、磁盘";i:2;s:12:"光盘、DVD";i:3;s:18:"蛋白质、细菌";i:4;N;i:5;N;}', NULL),
	(1294, 4, 50, 2, 5, '信息用户是指（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"具有信息需求的人";i:1;s:24:"具有信息行为的人";i:2;s:24:"具有信息能力的人";i:3;s:48:"既具有信息需求又具有信息行为的人";i:4;N;i:5;N;}', NULL),
	(1295, 4, 50, 2, 5, '下述信息源中，属于非记录型信息源的是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"图书、声像";i:1;s:15:"样品、标本";i:2;s:15:"专业数据库";i:3;s:15:"数字出版物";i:4;N;i:5;N;}', NULL),
	(1296, 4, 50, 2, 5, '信息需求是引发信息行为的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"原动力";i:1;s:6:"基础";i:2;s:6:"根本";i:3;s:9:"创造力";i:4;N;i:5;N;}', NULL),
	(1297, 4, 50, 2, 5, '非程式化决策主要由（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"高层管理人员完成";i:1;s:24:"中层管理人员完成";i:2;s:33:"中层或高层管理人员完成";i:3;s:24:"基层管理人员完成";i:4;N;i:5;N;}', NULL),
	(1298, 4, 50, 2, 5, '决策过程可以分为三个阶段：发现问题、分析和设计可能的解决方案和（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"分析与比较多个解决方案";i:1;s:30:"选择其中一个解决方案";i:2;s:30:"执行其中一个解决方案";i:3;s:39:"选择并执行其中一个解决方案";i:4;N;i:5;N;}', NULL),
	(1299, 4, 50, 2, 5, '很多地方设置的监视电视信号、监听电台信号都属于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息定向采集";i:1;s:18:"信息定点采集";i:2;s:18:"信息现场采集";i:3;s:18:"信息定题采集";i:4;N;i:5;N;}', NULL),
	(1300, 4, 50, 2, 5, '按照信息库的存储手段不同，可将信息库划分为人工信息库和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"文献信息库";i:1;s:15:"机器信息库";i:2;s:15:"数值信息库";i:3;s:15:"检索信息库";i:4;N;i:5;N;}', NULL),
	(1301, 4, 50, 3, 5, '信息存储是指将经过加工处理后的信息，按照一定的规定记录在相应的信息载体上，其作用在于（   ）', '', '', '', 'ABDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"方便检索";i:1;s:12:"延长寿命";i:2;s:12:"利于交易";i:3;s:12:"利于共享";i:4;s:12:"方便管理";i:5;N;}', NULL),
	(1302, 4, 50, 3, 5, '若按照信息库的存储内容划分，可将其分为（   ）', '', '', '', 'ABCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"文献信息库";i:1;s:15:"数值信息库";i:2;s:15:"事实信息库";i:3;s:15:"综合信息库";i:4;s:15:"编年信息库";i:5;N;}', NULL),
	(1303, 4, 50, 3, 5, '信息筛选和判别过程中应该重点注的内容包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"虚构信息";i:1;s:12:"拼凑信息";i:2;s:12:"夸张信息";i:3;s:12:"模糊信息";i:4;s:12:"残缺信息";i:5;N;}', NULL),
	(1304, 4, 51, 2, 5, '一项标准编号为DB21/863-94的标准属于（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"国家标准";i:1;s:12:"行业标准";i:2;s:12:"地方标准";i:3;s:12:"企业标准";i:4;N;i:5;N;}', NULL),
	(1305, 4, 51, 2, 5, '标准化横向深入到各个专业的技术领域以及每一专业技术领域的各个环节，从而体现了标准化工作的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"统一性";i:1;s:9:"政策性";i:2;s:9:"专业性";i:3;s:15:"横向综合性";i:4;N;i:5;N;}', NULL),
	(1306, 4, 51, 2, 5, '标准化的信息资源管理过程包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"学习和贯彻标准";i:1;s:21:"检测和分类标准";i:2;s:21:"识别和提取标准";i:3;s:21:"处理和交换标准";i:4;N;i:5;N;}', NULL),
	(1307, 4, 51, 2, 5, '信息资源管理标准化的内容包含标准化技术、标准化设施、标准化术语以及（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"标准化数据";i:1;s:15:"标准化信息";i:2;s:15:"标准化文献";i:3;s:21:"标准化管理过程";i:4;N;i:5;N;}', NULL),
	(1308, 4, 51, 2, 5, '以下有关“术语标准化”的陈述中，正确的是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:36:"技术标准化优于术语标准化";i:1;s:60:"术语标准化的目的是区分国际标准和国内标准";i:2;s:42:"术语标准化要以集体的方式进行";i:3;s:39:"术语标准化应遵循差异性原则";i:4;N;i:5;N;}', NULL),
	(1309, 4, 51, 2, 5, '信息资源管理标准的出台包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"制定和实施两个过程";i:1;s:27:"制定和修订两个过程";i:2;s:27:"分析和实施两个过程";i:3;s:27:"分析和修订两个过程";i:4;N;i:5;N;}', NULL),
	(1310, 4, 51, 2, 5, '一项标准编号为 “GB/T5632-99”的标准属于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"国家标准";i:1;s:12:"行业标准";i:2;s:12:"地方标准";i:3;s:12:"企业标准";i:4;N;i:5;N;}', NULL),
	(1311, 4, 51, 2, 5, '信息资源管理整个标准化工作的中心是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"标准的内容";i:1;s:21:"标准的指导原则";i:2;s:21:"标准的基本方法";i:3;s:24:"标准的制定和实施";i:4;N;i:5;N;}', NULL),
	(1312, 4, 51, 2, 5, '“建立最佳秩序、取得最佳效益”是建立标准体系的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"基本原理";i:1;s:12:"基本方法";i:2;s:12:"基本目标";i:3;s:12:"基本动力";i:4;N;i:5;N;}', NULL),
	(1313, 4, 51, 2, 5, '标准的作用归根结底来源于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"统一";i:1;s:6:"价值";i:2;s:6:"方便";i:3;s:6:"管理";i:4;N;i:5;N;}', NULL),
	(1314, 4, 51, 2, 5, '《标准化法》适用于在中国境内的-切企业、事业单位、机关、科研机构和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"工商部门";i:1;s:12:"税务部门";i:2;s:12:"学术团体";i:3;s:12:"高等院校";i:4;N;i:5;N;}', NULL),
	(1315, 4, 52, 2, 5, '本质上，信息资源安全管理问题是指信息可用性和权属受到（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"破坏";i:1;s:6:"侵犯";i:2;s:6:"占领";i:3;s:6:"威胁";i:4;N;i:5;N;}', NULL),
	(1316, 4, 52, 2, 5, '数据库的日志文件用来记录数据库的每一次（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"查询活动";i:1;s:12:"删除活动";i:2;s:12:"排序活动";i:3;s:12:"更新活动";i:4;N;i:5;N;}', NULL),
	(1317, 4, 52, 2, 5, '最基本的系统软件是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"Office软件";i:1;s:12:"绘图软件";i:2;s:12:"操作系统";i:3;s:7:"Windows";i:4;N;i:5;N;}', NULL),
	(1318, 4, 52, 2, 5, '恶意程序具有破坏性、非法性和（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"传染性";i:1;s:9:"隐蔽性";i:2;s:9:"娱乐性";i:3;s:9:"复制性";i:4;N;i:5;N;}', NULL),
	(1319, 4, 52, 2, 5, '信息系统管理的对象就是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"数据";i:1;s:6:"信息";i:2;s:6:"程序";i:3;s:6:"代码";i:4;N;i:5;N;}', NULL),
	(1320, 4, 52, 2, 5, '信息系统安全的行为规范管理包括两个层面，分别是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"国家和社会组织";i:1;s:21:"企业和工商部门";i:2;s:21:"机构和社会组织";i:3;s:15:"国家和企业";i:4;N;i:5;N;}', NULL),
	(1321, 4, 52, 2, 5, '逻辑炸弹是指嵌入在合法程序中的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"注解";i:1;s:6:"注释";i:2;s:6:"代码";i:3;s:6:"文字";i:4;N;i:5;N;}', NULL),
	(1322, 4, 52, 2, 5, '数据加密的本质是一种（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"数据传递";i:1;s:12:"文本传递";i:2;s:12:"数据变换";i:3;s:12:"文本变换";i:4;N;i:5;N;}', NULL),
	(1323, 4, 52, 2, 5, '本质上,与信息资源安全相关的是信息的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"加工和使用";i:1;s:15:"处理和存储";i:2;s:15:"利用和权属";i:3;s:15:"利用和存储";i:4;N;i:5;N;}', NULL),
	(1324, 4, 52, 2, 5, '信息安全技术的核心是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"行为规范";i:1;s:12:"系统安全";i:2;s:12:"实体安全";i:3;s:18:"技术安全管理";i:4;N;i:5;N;}', NULL),
	(1325, 4, 52, 2, 5, '通过设置在内网与公网之间的硬件或软件的组合，并限制外部非授权用户访问内部网络的网络安全技术是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"防火墙";i:1;s:3:"VPN";i:2;s:4:"VLAN";i:3;s:3:"PKI";i:4;N;i:5;N;}', NULL),
	(1326, 4, 52, 2, 5, '在信息资源安全问题上受到威胁的是信息的权属和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信用卡类";i:1;s:12:"电子支票";i:2;s:12:"电子现金";i:3;s:12:"网上银行";i:4;N;i:5;N;}', NULL),
	(1327, 4, 52, 2, 5, '防止非授权用户进入系统或非法存取系统资源的软件安全管理机制是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"身份识别与鉴别";i:1;s:12:"访问控制";i:2;s:18:"最小特权管理";i:3;s:12:"安全审计";i:4;N;i:5;N;}', NULL),
	(1328, 4, 52, 2, 5, '从技术角度考虑，防治外来恶意程序（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"防火墙";i:1;s:12:"数据加密";i:2;s:12:"身份认证";i:3;s:12:"数字签名";i:4;N;i:5;N;}', NULL),
	(1329, 4, 52, 2, 5, '以下名称中表示公钥算法的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"VPN";i:1;s:3:"PKI";i:2;s:2:"CA";i:3;s:3:"RSA";i:4;N;i:5;N;}', NULL),
	(1330, 4, 52, 3, 5, '信息资源安全策略应该是（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"简明的";i:1;s:9:"原则的";i:2;s:12:"可审核的";i:3;s:9:"可行的";i:4;s:9:"动态的";i:5;N;}', NULL),
	(1331, 4, 52, 3, 5, '信息资源的场地环境安全主要有（   ）', '', '', '', 'ABC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"场地安全";i:1;s:18:"空气调节系统";i:2;s:12:"防火管理";i:3;s:9:"采光度";i:4;s:12:"准入管理";i:5;N;}', NULL),
	(1332, 4, 52, 3, 5, '信息资源硬件介质安全要注意（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"防火";i:1;s:9:"防高温";i:2;s:12:"防水防潮";i:3;s:6:"防霉";i:4;s:6:"防磁";i:5;N;}', NULL),
	(1333, 4, 52, 3, 5, '计算机病毒具有这样一些特点，它们分别是（   ）', '', '', '', 'ABCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"隐蔽性";i:1;s:9:"传染性";i:2;s:9:"潜伏性";i:3;s:9:"破坏性";i:4;s:9:"恶作剧";i:5;N;}', NULL),
	(1334, 4, 52, 3, 5, '下列关于信息资源安全管理的说法中，正确的有（   ）', '', '', '', 'ACE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:60:"信息资源安全管理涉及到多种技术和组织手段";i:1;s:57:"所有的安全问题都是同等重要、不分等级的";i:2;s:57:"信息资源安全管理本质上属于风险管理范畴";i:3;s:66:"信息资源安全管理涉及的是管理活动，与技术无关";i:4;s:78:"信息资源安全管理要针对存在的信息资源安全问题采取措施";i:5;N;}', NULL),
	(1335, 4, 52, 3, 5, '信息资源安全管理解决信息资源的安全问题包括（   ）', '', '', '', 'ABDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"可用性";i:1;s:9:"保密性";i:2;s:9:"风险性";i:3;s:9:"认证性";i:4;s:9:"一致性";i:5;N;}', NULL),
	(1336, 4, 53, 2, 5, '企业信息化建设需要完成三个层面的工作，分别是构建信息网络、开发信息系统和（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"利用信息资源";i:1;s:18:"业务流程重组";i:2;s:18:"企业战略规划";i:3;s:18:"市场营销设计";i:4;N;i:5;N;}', NULL),
	(1337, 4, 53, 2, 5, '企业信息资源管理的最终目标是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"效率";i:1;s:6:"效果";i:2;s:6:"销量";i:3;s:6:"营利";i:4;N;i:5;N;}', NULL),
	(1338, 4, 53, 2, 5, 'CRM是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"消费需求管理";i:1;s:18:"客户等级管理";i:2;s:18:"客户需求管理";i:3;s:18:"客户关系管理";i:4;N;i:5;N;}', NULL),
	(1339, 4, 53, 2, 5, '按照信源划分，政府信息可分为（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"内生信息和外生信息";i:1;s:27:"内发信息和外发信息";i:2;s:27:"内传信息和外传信息";i:3;s:27:"内接信息和外接信息";i:4;N;i:5;N;}', NULL),
	(1340, 4, 53, 2, 5, '企业信息是企业生产运作和管理所需的一切（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"好用信息";i:1;s:12:"有用信息";i:2;s:12:"机密信息";i:3;s:12:"高层信息";i:4;N;i:5;N;}', NULL),
	(1341, 4, 53, 2, 5, '据统计，目前各级政府部门大约集聚了全社会信息资源总量的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:4:" 50%";i:1;s:4:"	60%";i:2;s:4:"	70%";i:3;s:4:"	80%";i:4;N;i:5;N;}', NULL),
	(1342, 4, 53, 2, 5, '在政府信息资源管理领域，行政手段直接出炉于（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"行政机构";i:1;s:12:"政府部门";i:2;s:12:"法律部门";i:3;s:12:"税务部门";i:4;N;i:5;N;}', NULL),
	(1343, 4, 53, 2, 5, '联想信息化成功的前提是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"信息化战略";i:1;s:12:"业务主导";i:2;s:15:"信息化组织";i:3;s:12:"信息系统";i:4;N;i:5;N;}', NULL),
	(1344, 4, 53, 2, 5, '政府信息资源管理的目标不包括（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"树立政府形象";i:1;s:24:"提高政府经济效益";i:2;s:27:"为政府决策当好参谋";i:3;s:24:"提高政府办公效率";i:4;N;i:5;N;}', NULL),
	(1345, 4, 53, 2, 5, '企业经营的外部环境因素不包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"消费者需求情况";i:1;s:27:"同性质企业竞争情况";i:2;s:21:"政府的法规政策";i:3;s:21:"企业的生产能力";i:4;N;i:5;N;}', NULL),
	(1346, 4, 53, 2, 5, '按所有制划分，企业可以分为全民所有制企业、集体所有制企业、私营企业、中外合资企业、外资企业和（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"商业企业";i:1;s:12:"合伙企业";i:2;s:12:"跨国企业";i:3;s:21:"股份合作制企业";i:4;N;i:5;N;}', NULL),
	(1347, 4, 53, 3, 5, '从时效上看，企业信息可以划分为（   ）', '', '', '', 'ABD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"沉淀信息";i:1;s:12:"累计信息";i:2;s:12:"固定信息";i:3;s:12:"即时信息";i:4;s:12:"变动信息";i:5;N;}', NULL),
	(1348, 4, 54, 2, 5, '按信息表现形式划分，信息可分为（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:57:"书写介质信息、磁介质信息、宅；介质信息";i:1;s:51:"实物型信息、记录型信息、智力型信息";i:2;s:42:"文字信息、图像信息、声音信息";i:3;s:42:"一次信息、二次信息、三次信息";i:4;N;i:5;N;}', NULL),
	(1349, 4, 54, 2, 5, '同样的信息对于不同的人或组织在不同的时间下可能具有不同的意义和价值，这反映了信息资源的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"不可分性";i:1;s:12:"尊消耗性";i:2;s:12:"不同一性";i:3;s:15:"认知相对性";i:4;N;i:5;N;}', NULL),
	(1350, 4, 54, 2, 5, '促进信息资源管理产生的主要因素不包含（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"工业技术革命";i:1;s:20:"  “信息爆炸”";i:2;s:39:"数据库管理等应用学科的发展";i:3;s:27:"信息资源地位的提高";i:4;N;i:5;N;}', NULL),
	(1351, 4, 54, 2, 5, '软件或信息系统等信息产品的使用与其应用环境密不可分，卡尔·夏皮罗和哈尔·瓦里安在他们著作《信息规则》中把这种不可分称为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"关联";i:1;s:6:"集成";i:2;s:6:"集中";i:3;s:6:"捆绑";i:4;N;i:5;N;}', NULL),
	(1352, 4, 54, 2, 5, '组织信息化工作的重心在于支持（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"事务处理自动化";i:1;s:21:"管理控制集成化";i:2;s:21:"管理决策智能化";i:3;s:21:"业务流程标准化";i:4;N;i:5;N;}', NULL),
	(1353, 4, 54, 2, 5, '信息资源规划是信息化建设工作的核心，其重点工作不涉及（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"业务分析";i:1;s:21:"建立主题数据库";i:2;s:15:"数据标准化";i:3;s:21:"系统设计与开发";i:4;N;i:5;N;}', NULL),
	(1354, 4, 54, 2, 5, '数据单独存放、不能自动地实现信息共享与交换，需要依靠人工与外界进行联系的一种\n现象是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息黑洞";i:1;s:12:"信息孤岛";i:2;s:12:"信息泥潭";i:3;s:12:"信息污染";i:4;N;i:5;N;}', NULL),
	(1355, 4, 54, 2, 5, 'IT服务管理的理念是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:39:"以客户为导向，以制度为中心";i:1;s:39:"以流程为导向，以客户为中心";i:2;s:39:"以客户力导向，以流程为中心";i:3;s:39:"以流程为导向，以剃度为中心";i:4;N;i:5;N;}', NULL),
	(1356, 4, 54, 2, 5, '信息系统项目开发评审的基础和核心是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"质量设计标准";i:1;s:18:"质量文档标准";i:2;s:18:"质量控制标准";i:3;s:18:"质量分析标准";i:4;N;i:5;N;}', NULL),
	(1357, 4, 54, 2, 5, '信息系统是一个人机系统，涉及人员大致可以分为两类：终端用户和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"系统分析人员";i:1;s:18:"系统设计人员";i:2;s:24:"系统维护管理人员";i:3;s:18:"系统操作人员";i:4;N;i:5;N;}', NULL),
	(1358, 4, 54, 2, 5, '系统集成为整合优化信息系统资源提供了（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"工程科学思想";i:1;s:18:"工程技术手段";i:2;s:18:"工程技术工具";i:3;s:18:"工程科学方法";i:4;N;i:5;N;}', NULL),
	(1359, 4, 54, 2, 5, '下列属于三次文献的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"期刊论文";i:1;s:12:"研究报告";i:2;s:15:"专利说明书";i:3;s:18:"学科年度总结";i:4;N;i:5;N;}', NULL),
	(1360, 4, 54, 2, 5, '信息定量分析方法有许多荤枣，动态规划属于（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:21:"文献计量分析法";i:1;s:15:"预测分析法";i:2;s:15:"决策分析法";i:3;s:15:"回归分析法";i:4;N;i:5;N;}', NULL),
	(1361, 4, 54, 2, 5, '一个复杂产品或服务由各种不同的部分组成，每个部门都有相应的标准，必须科学、系\n统地将这些标准综合考虑，组成一个标准系统。这种信息资源管理标准化的方法是（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"程序化";i:1;s:6:"组合";i:2;s:6:"综合";i:3;s:6:"统一";i:4;N;i:5;N;}', NULL),
	(1362, 4, 54, 2, 5, '在软件开发过程中，采用结构化、模块优设计标准，可有效地提高软件的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"可扩充性";i:1;s:9:"可靠性";i:2;s:12:"可重用性";i:3;s:12:"可维护性";i:4;N;i:5;N;}', NULL),
	(1363, 4, 54, 2, 5, 'IS0按专业性质设立技术委员会（TC）、分技术委员会（SC），其成员分别为P成员和O成员。则下面论述正确的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"P成员只可以参加TC的工作";i:1;s:33:"P成员只可以参加SC的工作";i:2;s:41:"O成员可以参加TC和SC的技术工作";i:3;s:58:"O成员可以了解工作情况及获取有关信息资料";i:4;N;i:5;N;}', NULL),
	(1364, 4, 54, 2, 5, '对于安装使用的软件，限制非法使用可以借助（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"软件狗";i:1;s:12:"压缩技术";i:2;s:12:"软件备份";i:3;s:12:"数字签名";i:4;N;i:5;N;}', NULL),
	(1365, 4, 54, 2, 5, '信息资源安全策略从宏观的危度反映了组织整体上的安全思想，一般而言其制定者是组织的（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"高管层";i:1;s:9:"经营层";i:2;s:9:"操作层";i:3;s:9:"经理层";i:4;N;i:5;N;}', NULL),
	(1366, 4, 54, 2, 5, '明文“Like You”的密文是“Mhld Znv”，若接此加密规律，明文“Shanghai”的密文是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:8:"Tibohibj";i:1;s:10:"  Tgbohibj";i:2;s:9:" Tgbohibp";i:3;s:9:" Tgbmhgbh";i:4;N;i:5;N;}', NULL),
	(1367, 4, 54, 2, 5, '企业信息化过程呈现的特点不包含（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"循序渐进";i:1;s:39:"信息技术与企业管理不断融合";i:2;s:18:"一次性高投入";i:3;s:21:"高投入与高风险";i:4;N;i:5;N;}', NULL),
	(1368, 4, 54, 3, 5, '经济学赋予资源的皮在属性有（   ）', '', '', '', 'BCE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"非竞争性";i:1;s:9:"需求性";i:2;s:9:"稀缺性";i:3;s:12:"可扩展性";i:4;s:12:"可选择性";i:5;N;}', NULL),
	(1369, 4, 54, 3, 5, '信息化规划的战略目标体现在（   ）', '', '', '', 'ACDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"业务匹配";i:1;s:12:"信息集成";i:2;s:12:"竞争优势";i:3;s:12:"管理资源";i:4;s:12:"技术架构";i:5;N;}', NULL),
	(1370, 4, 54, 3, 5, '以下属于DBA的主要操作有（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:24:"安装和升级数据库";i:1;s:33:"监控和优化数据库的性能";i:2;s:30:"制定数据库的备份计划";i:3;s:24:"数据库备份及恢复";i:4;s:21:"登记数据库用户";i:5;N;}', NULL),
	(1371, 4, 54, 3, 5, '数字化信息源包括（   ）', '', '', '', 'ABD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"组织内部的信息系统";i:1;s:15:"专业数据库";i:2;s:15:"样本、样品";i:3;s:30:"互联网上的数字出版物";i:4;s:12:"声像资料";i:5;N;}', NULL),
	(1372, 4, 54, 3, 5, '信息资源管理标准化的指导原则主要有（   ）', '', '', '', 'ABDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"效益原则";i:1;s:12:"系统原则";i:2;s:12:"替代原则";i:3;s:12:"优化原则";i:4;s:12:"动态原则";i:5;N;}', NULL),
	(1373, 4, 55, 2, 5, '要真正发挥信息的功效，需要将信息提升为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"消息和情报";i:1;s:15:"知识和智能";i:2;s:15:"经验和策略";i:3;s:15:"数据和智慧";i:4;N;i:5;N;}', NULL),
	(1374, 4, 55, 2, 5, '以下关于“信息化”的表述中，错误的是（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:157:"信息化特指一个具体组织实体（政府部门、事业单位或企业）应用信息技术提高信\n息资源开发和利用效率的过程与活动";i:1;s:84:"信息化是继农业化、工业化之后人类生存和发展的一个历史阶段";i:2;s:81:"信息化是指信息技术在国民经济和社会生活中逐步应用的过程";i:3;s:33:"信息化特指建设信息网络";i:4;N;i:5;N;}', NULL),
	(1375, 4, 55, 2, 5, '常用信息测度方法是按反映信息内容数量的数据所占计算机存储装置空间大小来衡量信息量的大小，这种信息量测度方法是基于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"语法信息";i:1;s:12:"语义信息";i:2;s:12:"语用信息";i:3;s:12:"随机信息";i:4;N;i:5;N;}', NULL),
	(1376, 4, 55, 2, 5, '认识论层次的信息可分为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"实在信息、先验信息和实得信息";i:1;s:42:"语法信息、语义信息和语用信息";i:2;s:42:"随机信息、模糊信息和偶发信息";i:3;s:42:"动态信息、静态信息和常态信息";i:4;N;i:5;N;}', NULL),
	(1377, 4, 55, 2, 5, '实物型信息、记录型信息、智力型信息等划分是根据（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息记录方式";i:1;s:18:"信息存储介质";i:2;s:24:"信息加工处理深度";i:3;s:18:"信息应用领域";i:4;N;i:5;N;}', NULL),
	(1378, 4, 55, 2, 5, '根据 Hartley信息量测度公式，2个烽火合传输1条信息的信息量H为（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:13:"H=1xlog比特";i:1;s:14:"H=1×log比特";i:2;s:14:"H=2×log比特";i:3;s:14:"H=2×log比特";i:4;N;i:5;N;}', NULL),
	(1379, 4, 55, 2, 5, '主题数据库要求信息源的唯一性，即（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:42:"所有源信息一次多处地进入系统";i:1;s:42:"所有源信息一次一处地进入系统";i:2;s:42:"所有源信息多次一处地进入系统";i:3;s:42:"所有源信息多次多处地进入系统";i:4;N;i:5;N;}', NULL),
	(1380, 4, 55, 2, 5, '在项目实施前，信息化项目规划的全面计划内容包括（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"时间、质量、资金等";i:1;s:27:"人力、物力、财力等";i:2;s:33:"目标、工程质量、工期等";i:3;s:36:"范围、进度、成本、质量等";i:4;N;i:5;N;}', NULL),
	(1381, 4, 55, 2, 5, '根据诺兰模型，早期信息化规划局限于技术（战术）层面的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"信息系统集成";i:1;s:24:"信息系统项目规划";i:2;s:18:"信息资源规划";i:3;s:18:"数据管理规划";i:4;N;i:5;N;}', NULL),
	(1382, 4, 55, 2, 5, '数据标准化决定着信息资源处理、检索和传输的质量与效率，包括（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:51:"数据元素标准化和信息分类编码标准化";i:1;s:51:"信息分类编码标准化和用户视图标准化";i:2;s:45:"数据元素标准化和用户视图标准化";i:3;s:48:"信息分类编码标准化和信息传输标准";i:4;N;i:5;N;}', NULL),
	(1383, 4, 55, 2, 5, '从下而上开展信息化规划的方式较适用于（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:27:"业务相对稳定的组织";i:1;s:36:"有较明确新发展战略的组织";i:2;s:27:"业务发展迅速的组织";i:3;s:30:"发展战略不明确的组织";i:4;N;i:5;N;}', NULL),
	(1384, 4, 55, 2, 5, '办公自动化系统（OAS）典型功能是文字处理、电子邮件和电子日历等，它属于（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"战略层";i:1;s:9:"管理层";i:2;s:9:"知识层";i:3;s:9:"操作层";i:4;N;i:5;N;}', NULL),
	(1385, 4, 55, 2, 5, '任何信息系统资源都有质的优劣和规模大小两重性的问题，该问题所属范畴是信息系统资源的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"层次观";i:1;s:9:"开放观";i:2;s:9:"系统观";i:3;s:9:"辩证观";i:4;N;i:5;N;}', NULL),
	(1386, 4, 55, 2, 5, '系统运行情况的记录应事先制定登记格式和登记要点，具体记录工作人员主要是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"分析人员";i:1;s:12:"使用人员";i:2;s:12:"设计人员";i:3;s:12:"管理人员";i:4;N;i:5;N;}', NULL),
	(1387, 4, 55, 2, 5, '搜索引擎的核心技术之一是全文检索，其主要检索对象是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"文本信息";i:1;s:12:"数据结构";i:2;s:15:"图像和视频";i:3;s:9:"元数据";i:4;N;i:5;N;}', NULL),
	(1388, 4, 55, 2, 5, '对著录后的信息载体按照一定规律加注标识符号的活动过程称为（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息筛选";i:1;s:12:"信息标引";i:2;s:12:"信息编目";i:3;s:12:"信息分类";i:4;N;i:5;N;}', NULL),
	(1389, 4, 55, 2, 5, '以Q开始的标准代号表示这种标准是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"国家标准";i:1;s:12:"企业标准";i:2;s:12:"行业标准";i:3;s:12:"地区标准";i:4;N;i:5;N;}', NULL),
	(1390, 4, 55, 2, 5, '关于信息资源管理标准的出台，下列说法正确的是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:66:"信息资源管理标准的出台包括制定和修订两个过程";i:1;s:66:"信息资源管理标准的出台包括调查和制定两个过程";i:2;s:66:"信息资源管理标准的出台包括制定和发布两个过程";i:3;s:66:"信息资源管理标准的出台包括提交和审批两个过程";i:4;N;i:5;N;}', NULL),
	(1391, 4, 55, 2, 5, '一般电源功率要超过所有设备负载的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"80%";i:1;s:4:"100%";i:2;s:4:"125%";i:3;s:4:"200%";i:4;N;i:5;N;}', NULL),
	(1392, 4, 55, 2, 5, '以下没有使用加密技术的访问控制技术是（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:3:"VPN";i:1;s:12:"文件压缩";i:2;s:15:"真实性认证";i:3;s:27:"数据库用户口令管理";i:4;N;i:5;N;}', NULL),
	(1393, 4, 55, 3, 5, '现代信息技术的发展呈现出的特征包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:9:"数字化";i:1;s:9:"小型化";i:2;s:9:"网络化";i:3;s:9:"智能化";i:4;s:9:"系统化";i:5;N;}', NULL),
	(1394, 4, 55, 3, 5, '国家信息化体系包含的要素有（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息资源";i:1;s:12:"信息网络";i:2;s:27:"信息技术应用与产业";i:3;s:21:"信息化人才队伍";i:4;s:36:"信息化政策法规和标准规范";i:5;N;}', NULL),
	(1395, 4, 55, 3, 5, '信息系统能够向用户提供的信息服务包括（   ）', '', '', '', 'ABCDE', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"信息检索";i:1;s:12:"统计报表";i:2;s:12:"控制决策";i:3;s:12:"事务处理";i:4;s:12:"规划设计";i:5;N;}', NULL),
	(1396, 4, 55, 3, 5, '作为信息用户的人类个体或群体的特征包括（   ）', '', '', '', 'ABC', 0, '', NULL, 0, 0, 'a:6:{i:0;s:18:"拥有信息需求";i:1;s:27:"具备利用信息的能力";i:2;s:27:"具有接受信息的能力";i:3;s:27:"具有产生信息的能力";i:4;s:24:"具备信息认证能力";i:5;N;}', NULL),
	(1397, 4, 55, 3, 5, '术语标准化应遵循的原则主要有（   ）', '', '', '', 'ABCD', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"优先原则";i:1;s:12:"简化原则";i:2;s:15:"灵活性原则";i:3;s:15:"广义性原则";i:4;s:12:"外推原则";i:5;N;}', NULL),
	(1400, 4, 57, 2, 5, '摩尔定律预测，微处理器芯片大约每18个月集成度翻番，处理能力提高一倍，体积\n和价格减半。这体现了现代信息技术的（   ）', '', '', '', 'D', 0, '', NULL, 0, 0, 'a:6:{i:0;s:15:"数字化特点";i:1;s:15:"系统化特点";i:2;s:15:"智能化特点";i:3;s:15:"小型化特点";i:4;N;i:5;N;}', NULL),
	(1401, 4, 58, 2, 5, '信息不同于物质和能量，它不会在使用中被消耗，可以不断积累，甚至是可以再生 的，这体现了信息资源的（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"不可分性";i:1;s:24:"积累性或非消耗性";i:2;s:15:"认知相对性";i:3;s:12:"不同一性";i:4;N;i:5;N;}', NULL),
	(1402, 4, 59, 2, 5, '微电子技术造就了成千上万的信息技术应用，有人将其概括为“3c” 革命，3c指的是计算机、通信和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"交换技术";i:1;s:12:"存储技术";i:2;s:12:"控制技术";i:3;s:12:"识别技术";i:4;N;i:5;N;}', NULL),
	(1403, 4, 59, 2, 5, '信息论奠基人Shannon,把信息量定义为随机不确定性程度的减少。其基本观点是:通信的发生是以（   ）', '', '', '', 'B', 0, '', NULL, 0, 0, 'a:6:{i:0;s:33:"通信者具有相似性为前提";i:1;s:36:"通信者具有不确定性为前提";i:2;s:33:"通信者具有相对性为前提";i:3;s:36:"通信者具有不同一性为前提";i:4;N;i:5;N;}', NULL),
	(1404, 4, 60, 2, 5, '信息资源管理标准是实践经验的（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:6:"升华";i:1;s:6:"延伸";i:2;s:6:"总结";i:3;s:6:"检验";i:4;N;i:5;N;}', NULL),
	(1405, 4, 56, 2, 5, '硬件系统的安全机制主要包括内存保护、进程控制和（   ）', '', '', '', 'C', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"木马控制";i:1;s:12:"病毒查杀";i:2;s:19:"输入/输出控制";i:3;s:12:"编程测试";i:4;N;i:5;N;}', NULL),
	(1406, 4, 56, 2, 5, '企业信息化成功的前提是（   ）', '', '', '', 'A', 0, '', NULL, 0, 0, 'a:6:{i:0;s:12:"业务主导";i:1;s:12:"信息主导";i:2;s:12:"数据主导";i:3;s:12:"领导主导";i:4;N;i:5;N;}', NULL);
/*!40000 ALTER TABLE `ims_goouc_practice_question` ENABLE KEYS */;

/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
